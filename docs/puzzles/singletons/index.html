<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">Singletons | Chialisp</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://chialisp.com/docs/puzzles/singletons"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Singletons | Chialisp"><meta data-react-helmet="true" name="description" content="One of the most important puzzles in the Chia ecosystem is the singleton."><meta data-react-helmet="true" property="og:description" content="One of the most important puzzles in the Chia ecosystem is the singleton."><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://chialisp.com/docs/puzzles/singletons"><link data-react-helmet="true" rel="alternate" href="https://chialisp.com/docs/puzzles/singletons" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://chialisp.com/docs/puzzles/singletons" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.35749df4.css">
<link rel="preload" href="/assets/js/runtime~main.5582d1e8.js" as="script">
<link rel="preload" href="/assets/js/main.3d802437.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><b class="navbar__title">Chialisp</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">Docs</a><a href="https://chia.net" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>Chia.net<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><a href="https://github.com/Chia-Network/chialisp-web" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></div><div class="navbar__items navbar__items--right"><div class="react-toggle toggle_2i4l react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_iYfV">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">ðŸŒž</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="navbar__search searchBarContainer_I7kZ"><input placeholder="Search" aria-label="Search" class="navbar__search-input"><div class="loadingRing_Zg7X searchBarLoadingRing_J5Ez"><div></div><div></div><div></div><div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button class="clean-btn backToTopButton_i9tI" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh menuWithAnnouncementBar_+O1J"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Getting Started</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Chialisp</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/">Language Overview</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/common_functions">Common Functions and Design Patterns</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/coins_spends_and_wallets">Coins, Spends and Wallets</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/coin_lifecycle">Lifecycle of a Coin</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/security">Security</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/debugging">Debugging</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/optimization">Optimization</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/standard_transaction">The Standard Transaction</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">Standard Puzzles</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/puzzles/singletons">Singletons</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/puzzles/pooling">Pooling</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/puzzles/cats">Chia Asset Tokens (CATs)</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/puzzles/offers">Offers</a></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Tutorials</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">CLVM</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/glossary">Glossary</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/faq">FAQ</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/resources">Resources</a></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Singletons</h1></header><p>One of the most important puzzles in the Chia ecosystem is the <strong>singleton</strong>.
This is a puzzle that assures anyone who looks at can see that it has a unique ID that no other coin has.
Parties can decide to accept messages or commitments from that unique ID with the assurance that the party who controls the singleton is not double dipping or impersonating someone else.</p><p>This puzzle is an <a href="/docs/common_functions">outer puzzle</a> and is used to wrap pooling puzzles, NFTs, and decentralized identities.
Any inner puzzle can be wrapped with this puzzle if it has necessity for uniqueness.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="design-choices"></a>Design choices<a class="hash-link" href="#design-choices" title="Direct link to heading">#</a></h2><p>A few design choices were made in the creation of this puzzle so let&#x27;s go over them now:</p><ul><li><strong>Singletons are always odd.</strong>  In order to assure that a singleton does not duplicate itself, it needs some way to verify that its children do not consist of more than one new singleton.
It does this by verifying that only one of its children is odd.
It is either a new singleton, or it is the <strong>melt value</strong> and will be ignored (more on that later).
Odd was chosen over even because you may want to have singletons create other, non-singleton coins at times (like 0 amount messages for the DID) and having the singleton be odd just makes this easier.
Coins can be multiples of 10 so you can send a full XCH rather than an XCH and a mojo.
No matter how many even amounts you subtract from an odd amount, the end result will always be odd.</li><li><strong>Singletons always wrap their odd child.</strong> This abstracts some of the singleton functionality away from the inner puzzles.
If an inner puzzle creates an odd coin, it doesn&#x27;t have to worry about making it a singleton, the <a href="https://chialisp.com/docs/common_functions/#outer-and-inner-puzzles" target="_blank" rel="noopener noreferrer">outer puzzle will take care of that</a>.
It also prevents an inner puzzle from accidentally melting the singleton by forgetting to wrap its odd output.</li><li><strong>A specific magic melt value determines whether the singleton wraps its child.</strong> If you would like to destroy a singleton and use its amount to create a new non-singleton coin, you need to output a <code>CREATE_COIN</code> condition that uses the amount <code>-113</code>.
When the singleton outer puzzle sees that condition, it filters it out.
This amount was arbitrarily chosen and is negative because a coin with negative amount cannot exist. Therefore, it is an unlikely accidental output of an inner puzzle.
This is chosen to prevent an inner puzzle from accidentally melting a singleton by forgetting to create an odd output.
It must deliberately specify to melt the singleton.
Keep in mind that the melt value <em>does</em> count as the odd output, but is ignored, creating the need to burn one mojo of coin value in order to melt (all of the outputs must be even).
Usually there will be a transaction fee anyways so it likely just becomes part of that.
You should also be wary of the amount of control you give to people who you partially lend your singleton to.
If they can freely create conditions, it may be possible for them to melt your singleton against your wishes.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="the-launcher"></a>The Launcher<a class="hash-link" href="#the-launcher" title="Direct link to heading">#</a></h2><p>We need to ensure that only one singleton is created with the same ID.
This is surprisingly difficult.
The crux of the issue is that we have no control over the coin that creates the singleton.
We could rely on a curried in id, but it&#x27;s easy enough for someone to create the exact same singleton by currying in the same id.
Instead, we could use the parent coin ID which would be unique to all of its descendants, however, you could still create multiple singletons in that first spend.</p><p>This is technically detectable by crawling up the chain and checking the first non-singleton coin to see if it had multiple singleton children, but this is inefficient and we would like all of our logic to be contained to the puzzles.</p><p>Instead, what we can use is a <strong>launcher</strong> which is a specific puzzle that does exactly one thing: create a single singleton.
We then need to curry this launcher puzzle hash into our singleton and have the first singleton assert that it, in fact, came from a parent whose puzzle hash was the launcher puzzle hash.
Then, when people look at our singleton, they can see that the launcher puzzle hash is the hash of what they know to be a puzzle that creates only one singleton.
They don&#x27;t need to go back to the original parent and verify because the singleton puzzle takes care of that right from the start!</p><p>So what does the launcher look like?  Here&#x27;s the source:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI chialisp"><pre tabindex="0" class="prism-code language-chialisp codeBlock_rtdJ thin-scrollbar" style="color:#383a42;background-color:#fafafa;font-weight:bold"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">(mod (singleton_full_puzzle_hash amount key_value_list)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (include condition_codes.clvm)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun sha256tree (TREE)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      (if (l TREE)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          (sha256 2 (sha256tree (f TREE)) (sha256tree (r TREE)))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          (sha256 1 TREE)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; main</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (list (list CREATE_COIN singleton_full_puzzle_hash amount)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        (list CREATE_COIN_ANNOUNCEMENT (sha256tree (list singleton_full_puzzle_hash amount key_value_list))))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Essentially two lines, so not too bad right?  One of the first things you may notice is that we don&#x27;t curry anything in.
We actually cannot curry anything in because we want this puzzle hash to be constant among all singletons.
That way, even if someone isn&#x27;t familiar with us, they know that if we came from this specific launcher puzzle hash, we can be trusted to be a unique singleton.</p><p>For the most part, you simply put in <code>CREATE_COIN</code> parameters and the puzzle creates the singleton for you.
The tricky part is the announcement creation.
Since these parameters are not curried in, we somehow need them to be immune from the manipulations of malicious full nodes.
We cannot curry in a pubkey to sign them, or else our puzzle hash is no longer static. Our solution to this conundrum is to create an announcement from this puzzle that its parent asserts in the same block.
Usually, the parent is going to be a standard coin. In the standard coin, we sign the puzzle that makes the conditions.
If we create an <code>ASSERT_COIN_ANNOUNCEMENT</code> condition, we implicitly sign that too. That means we can implicitly sign all of the launcher solution values through asserting this announcement.
If any of those values are changed, the coin that creates the launcher will fail and thus the launcher will never be created!</p><p>The last thing to note is the seemingly useless <code>key_value_list</code> that is passed in as an argument and announced.
The purpose for this is to communicate information to blockchain observers.
Sometimes you want to be able to know information about a puzzle before it is revealed.
The only way we can get this information on chain is from the parent&#x27;s puzzle reveal so sometimes it is useful to have useless parameters be part of the solution in order to make it easier to follow the puzzle&#x27;s on chain state.
Remember that you pay cost for every byte though so keep it concise.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="the-singleton-top-layer"></a>The Singleton Top Layer<a class="hash-link" href="#the-singleton-top-layer" title="Direct link to heading">#</a></h2><p>Here&#x27;s the full source, we&#x27;ll break it down after:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI chialisp"><pre tabindex="0" class="prism-code language-chialisp codeBlock_rtdJ thin-scrollbar" style="color:#383a42;background-color:#fafafa;font-weight:bold"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">(mod (</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">       SINGLETON_STRUCT</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">       INNER_PUZZLE</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">       lineage_proof</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">       my_amount</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">       inner_solution</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">     )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">     ;; SINGLETON_STRUCT = (MOD_HASH . (LAUNCHER_ID . LAUNCHER_PUZZLE_HASH))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">     ; SINGLETON_STRUCT, INNER_PUZZLE are curried in by the wallet</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; This puzzle is a wrapper around an inner smart puzzle which guarantees uniqueness.</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; It takes its singleton identity from a coin with a launcher puzzle which guarantees that it is unique.</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (include condition_codes.clib)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (include curry-and-treehash.clib)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (include singleton_truths.clib)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; takes a lisp tree and returns the hash of it</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun sha256tree (TREE)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      (if (l TREE)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          (sha256 2 (sha256tree (f TREE)) (sha256tree (r TREE)))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          (sha256 1 TREE)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; &quot;assert&quot; is a macro that wraps repeated instances of &quot;if&quot;</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; usage: (assert A0 A1 ... An R)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; all of A0, A1, ... An must evaluate to non-null, or an exception is raised</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; return the value of R (if we get that far)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defmacro assert items</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (if (r items)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        (list if (f items) (c assert (r items)) (q . (x)))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        (f items)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun-inline mod_hash_for_singleton_struct (SINGLETON_STRUCT) (f SINGLETON_STRUCT))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun-inline launcher_id_for_singleton_struct (SINGLETON_STRUCT) (f (r SINGLETON_STRUCT)))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun-inline launcher_puzzle_hash_for_singleton_struct (SINGLETON_STRUCT) (r (r SINGLETON_STRUCT)))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ;; return the full puzzlehash for a singleton with the innerpuzzle curried in</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; puzzle-hash-of-curried-function is imported from curry-and-treehash.clinc</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun-inline calculate_full_puzzle_hash (SINGLETON_STRUCT inner_puzzle_hash)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">     (puzzle-hash-of-curried-function (mod_hash_for_singleton_struct SINGLETON_STRUCT)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">                                      inner_puzzle_hash</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">                                      (sha256tree SINGLETON_STRUCT)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">     )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; assembles information from the solution to create our own full ID including asserting our parent is a singleton</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun create_my_ID (SINGLETON_STRUCT full_puzzle_hash parent_parent parent_inner_puzzle_hash parent_amount my_amount)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (sha256 (sha256 parent_parent (calculate_full_puzzle_hash SINGLETON_STRUCT parent_inner_puzzle_hash) parent_amount)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            full_puzzle_hash</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            my_amount)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ;; take a boolean and a non-empty list of conditions</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ;; strip off the first condition if a boolean is set</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ;; this is used to remove `(CREATE_COIN xxx -113)`</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ;; pretty sneaky, eh?</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun strip_first_condition_if (boolean condition_list)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (if boolean</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      (r condition_list)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      condition_list</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun-inline morph_condition (condition SINGLETON_STRUCT)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (list (f condition) (calculate_full_puzzle_hash SINGLETON_STRUCT (f (r condition))) (f (r (r condition))))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ;; return the value of the coin created if this is a `CREATE_COIN` condition, or 0 otherwise</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun-inline created_coin_value_or_0 (condition)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (if (= (f condition) CREATE_COIN)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        (f (r (r condition)))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        0</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ;; Returns a (bool . bool)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun odd_cons_m113 (output_amount)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (c</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      (= (logand output_amount 1) 1) ;; is it odd?</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      (= output_amount -113) ;; is it the escape value?</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; Assert exactly one output with odd value exists - ignore it if value is -113</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ;; this function iterates over the output conditions from the inner puzzle &amp; solution</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ;; and both checks that exactly one unique singleton child is created (with odd valued output),</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ;; and wraps the inner puzzle with this same singleton wrapper puzzle</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ;;</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ;; The special case where the output value is -113 means a child singleton is intentionally</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ;; *NOT* being created, thus forever ending this singleton&#x27;s existence</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun check_and_morph_conditions_for_singleton (SINGLETON_STRUCT conditions has_odd_output_been_found)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      (if conditions</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        (morph_next_condition SINGLETON_STRUCT conditions has_odd_output_been_found (odd_cons_m113 (created_coin_value_or_0 (f conditions))))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        (if has_odd_output_been_found</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            0</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            (x)  ;; no odd output found</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">   )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">   ;; a continuation of `check_and_morph_conditions_for_singleton` with booleans `is_output_odd` and `is_output_m113`</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">   ;; precalculated</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">   (defun morph_next_condition (SINGLETON_STRUCT conditions has_odd_output_been_found (is_output_odd . is_output_m113))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">       (assert</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          (not (all is_output_odd has_odd_output_been_found))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          (strip_first_condition_if</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">             is_output_m113</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">             (c (if is_output_odd</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">                    (morph_condition (f conditions) SINGLETON_STRUCT)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">                    (f conditions)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">                )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">                (check_and_morph_conditions_for_singleton SINGLETON_STRUCT (r conditions) (any is_output_odd has_odd_output_been_found))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">             )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">   )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; this final stager asserts our ID</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; it also runs the innerpuz with the innersolution with the &quot;truths&quot; added</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; it then passes that output conditions from the innerpuz to the morph conditions function</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun stager_three (SINGLETON_STRUCT lineage_proof my_id full_puzhash innerpuzhash my_amount INNER_PUZZLE inner_solution)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (c (list ASSERT_MY_COIN_ID my_id) (check_and_morph_conditions_for_singleton SINGLETON_STRUCT (a INNER_PUZZLE (c (truth_data_to_truth_struct my_id full_puzhash innerpuzhash my_amount lineage_proof SINGLETON_STRUCT) inner_solution)) 0))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; this checks whether we are an eve spend or not and calculates our full coin ID appropriately and passes it on to the final stager</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; if we are the eve spend it also adds the additional checks that our parent&#x27;s puzzle is the standard launcher format and that out parent ID is the same as our singleton ID</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun stager_two (SINGLETON_STRUCT lineage_proof full_puzhash innerpuzhash my_amount INNER_PUZZLE inner_solution)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (stager_three</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      SINGLETON_STRUCT</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      lineage_proof</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      (if (is_not_eve_proof lineage_proof)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          (create_my_ID</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            SINGLETON_STRUCT</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            full_puzhash</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            (parent_info_for_lineage_proof lineage_proof)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            (puzzle_hash_for_lineage_proof lineage_proof)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            (amount_for_lineage_proof lineage_proof)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            my_amount</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          (if (=</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">                (launcher_id_for_singleton_struct SINGLETON_STRUCT)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">                (sha256 (parent_info_for_eve_proof lineage_proof) (launcher_puzzle_hash_for_singleton_struct SINGLETON_STRUCT) (amount_for_eve_proof lineage_proof))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">              )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">              (sha256 (launcher_id_for_singleton_struct SINGLETON_STRUCT) full_puzhash my_amount)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">              (x)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      full_puzhash</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      innerpuzhash</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      my_amount</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      INNER_PUZZLE</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      inner_solution</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; this calculates our current full puzzle hash and passes it to stager two</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun stager_one (SINGLETON_STRUCT lineage_proof my_innerpuzhash my_amount INNER_PUZZLE inner_solution)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (stager_two SINGLETON_STRUCT lineage_proof (calculate_full_puzzle_hash SINGLETON_STRUCT my_innerpuzhash) my_innerpuzhash my_amount INNER_PUZZLE inner_solution)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; main</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; if our value is not an odd amount then we are invalid</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; this calculates my_innerpuzhash and passes all values to stager_one</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (if (logand my_amount 1)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (stager_one SINGLETON_STRUCT lineage_proof (sha256tree INNER_PUZZLE) my_amount INNER_PUZZLE inner_solution)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (x)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Quite a bit isn&#x27;t it?  Let&#x27;s start with the arguments:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI chialisp"><pre tabindex="0" class="prism-code language-chialisp codeBlock_rtdJ thin-scrollbar" style="color:#383a42;background-color:#fafafa;font-weight:bold"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">(</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  SINGLETON_STRUCT</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  INNER_PUZZLE</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  lineage_proof</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  my_amount</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  inner_solution</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>SINGLETON_STRUCT</code> is a collection of three things:</p><ul><li>The tree hash of this module</li><li>The launcher coin ID (this acts as the unique ID for the singleton)</li><li>The launcher puzzle hash</li></ul><p>The reason they are grouped into a single structure is because they are passed through almost every function. It increases readability and optimization if they are passed through as a single variable until it is time to deconstruct them.</p><p><code>INNER_PUZZLE</code> is the inner puzzle to this wrapper puzzle.</p><p><code>lineage_proof</code> takes one of two formats:</p><ul><li><code>(parent_parent_coin_info parent_inner_puzzle_hash parent_amount)</code></li><li><code>(parent_parent_coin_info parent_amount)</code>
You may wonder, given the similarity, why not just use the first format?  We use the separate formats because we use the length of the structure to tip us off to whether or not this is the <strong>eve spend</strong>.
The eve spend is the first spend of a singleton after its creation.
We use this lineage proof to verify that our parent was a singleton.
However, in the first spend, the parent is not a singleton and we actually execute a different path where we verify that our parent was a singleton launcher instead.</li></ul><p><code>my_amount</code> is the amount of the coin being spent and will be asserted implicitly through ASSERT_MY_COIN_ID.</p><p><code>inner_solution</code> is the solution the to inner puzzle.</p><p>Next, let&#x27;s look at our main entry point:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI chialisp"><pre tabindex="0" class="prism-code language-chialisp codeBlock_rtdJ thin-scrollbar" style="color:#383a42;background-color:#fafafa;font-weight:bold"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">(if (logand my_amount 1)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (stager_one SINGLETON_STRUCT lineage_proof (sha256tree INNER_PUZZLE) my_amount INNER_PUZZLE inner_solution)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (x)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>The control flow here is very simple.
If we&#x27;re not odd, we raise, if we are, we pass everything through to the next stage (with the additional hash of the inner puzzle).
One small thing to note is that a singleton can actually be even, but it will never be able to be spent.
Either the person will pass in the true amount and the puzzle will raise, or they will pass in a phony amount and the ASSERT_MY_ID will fail. If an attacker were to launch an even singleton or create one as one the even children of the singleton, it would succeed, but be stuck forever.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI chialisp"><pre tabindex="0" class="prism-code language-chialisp codeBlock_rtdJ thin-scrollbar" style="color:#383a42;background-color:#fafafa;font-weight:bold"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">(defun stager_one (SINGLETON_STRUCT lineage_proof my_innerpuzhash my_amount INNER_PUZZLE inner_solution)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (stager_two SINGLETON_STRUCT lineage_proof (calculate_full_puzzle_hash SINGLETON_STRUCT my_innerpuzhash) my_innerpuzhash my_amount INNER_PUZZLE inner_solution)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>We now move on to the first of a few &quot;stagers&quot;. The purpose of these functions is to calculate values that are used multiple times only once.
In the next stage we use our full puzzle hash three times so it&#x27;s best to calculate it once and pass it to the next function instead.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI chialisp"><pre tabindex="0" class="prism-code language-chialisp codeBlock_rtdJ thin-scrollbar" style="color:#383a42;background-color:#fafafa;font-weight:bold"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">(defun stager_two (SINGLETON_STRUCT lineage_proof full_puzhash innerpuzhash my_amount INNER_PUZZLE inner_solution)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (stager_three</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    SINGLETON_STRUCT</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    lineage_proof</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (if (is_not_eve_proof lineage_proof)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        (create_my_ID</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          SINGLETON_STRUCT</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          full_puzhash</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          (parent_info_for_lineage_proof lineage_proof)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          (puzzle_hash_for_lineage_proof lineage_proof)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          (amount_for_lineage_proof lineage_proof)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          my_amount</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        (if (=</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">              (launcher_id_for_singleton_struct SINGLETON_STRUCT)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">              (sha256 (parent_info_for_eve_proof lineage_proof) (launcher_puzzle_hash_for_singleton_struct SINGLETON_STRUCT) (amount_for_eve_proof lineage_proof))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            (sha256 (launcher_id_for_singleton_struct SINGLETON_STRUCT) full_puzhash my_amount)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            (x)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    full_puzhash</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    innerpuzhash</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    my_amount</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    INNER_PUZZLE</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    inner_solution</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>This stage looks like a lot, but really all it&#x27;s doing is calculating the current coin ID for the next function to use.
Note before we start looking at it that the lineage proof is frequently being passed to functions that are not part of this file.
These are part of the <code>singleton_truths.clib</code> library which we will discuss in the next stage.
For now, just know that it is accessing the correct values from the lineage proof and is a lot cleaner than writing things like <code>(f (r lineage_proof)) (f (r (r lineage_proof)))</code> with no indication of what they mean.</p><p>The first if statement checks if <code>lineage_proof</code> indicates that this is not the eve spend (three proof elements instead of two).
If it is not the eve spend, it calculates our ID using the information in the <code>lineage_proof</code> to generate our parent ID.</p><p>If it <em>is</em> the eve spend, there is an extra check which verifies that the launcher ID and launcher puzzle hash we have (both inside the <code>SINGLETON_STRUCT</code>) are correct. We do so by calculating the launcher ID from information in our lineage proof and the launcher puzzle hash.
We then assert that it is equal to the curried in value.
This is an extremely important step because it ensures that every singleton after this singleton can trust the launcher ID and puzzle hash since it will be forcefully curried in from this &quot;eve&quot; singleton and every child singleton knows that the eve singleton checked it.</p><p>After the eve singleton has verified the launcher info, it can now trust the launcher ID as its parent ID and create its own ID by hashing in the <code>full_puzhash</code> from the last stage and <code>my_amount</code>.
Let&#x27;s talk about the final &quot;stager&quot;:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI chialisp"><pre tabindex="0" class="prism-code language-chialisp codeBlock_rtdJ thin-scrollbar" style="color:#383a42;background-color:#fafafa;font-weight:bold"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">(defun stager_three (SINGLETON_STRUCT lineage_proof my_id full_puzhash innerpuzhash my_amount INNER_PUZZLE inner_solution)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (c (list ASSERT_MY_COIN_ID my_id) (check_and_morph_conditions_for_singleton SINGLETON_STRUCT (a INNER_PUZZLE (c (truth_data_to_truth_struct my_id full_puzhash innerpuzhash my_amount lineage_proof SINGLETON_STRUCT) inner_solution)) 0))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>This stage is where the conditions will end up coming out of.
First, it prepends an <code>ASSERT_MY_COIN_ID</code> so that all of the solution values we have been assuming to be true up until this point are implicitly asserted by the network.
We prepend this condition to the output of <code>check_and_morph_conditions_for_singleton</code> which will take the output from the inner puzzle and check for singleton specific things (only one odd output, wrap the child singleton, etc.)</p><p>Notice that we are prepending something to the solution before we use it to solve the inner puzzle.
We are using a function from <code>singleton_truths.clib</code> that takes all of the listed information and combines it into a single structure to pass to the inner puzzle.
This allows the inner puzzle to use information that the singleton has already calculated and verified in its own puzzle at almost no additional cost!</p><p>Keep in mind that this means an inner puzzle needs to know that it is going inside a singleton or else all of its solution arguments will be shifted to the right.
An existing inner puzzle can be very easily adapted, however, to fit inside a singleton using a shallow outer layer of: <code>(a (q . INNER_PUZZLE) (r 1))</code> which strips off the first value of the solution before solving the inner puzzle.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI chialisp"><pre tabindex="0" class="prism-code language-chialisp codeBlock_rtdJ thin-scrollbar" style="color:#383a42;background-color:#fafafa;font-weight:bold"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">(defun check_and_morph_conditions_for_singleton (SINGLETON_STRUCT conditions has_odd_output_been_found)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (if conditions</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (morph_next_condition SINGLETON_STRUCT conditions has_odd_output_been_found (odd_cons_m113 (created_coin_value_or_0 (f conditions))))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (if has_odd_output_been_found</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        0</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        (x)  ;; no odd output found</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">(defun morph_next_condition (SINGLETON_STRUCT conditions has_odd_output_been_found (is_output_odd . is_output_m113))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">   (assert</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      (not (all is_output_odd has_odd_output_been_found))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      (strip_first_condition_if</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">         is_output_m113</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">         (c (if is_output_odd</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">                (morph_condition (f conditions) SINGLETON_STRUCT)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">                (f conditions)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">            (check_and_morph_conditions_for_singleton SINGLETON_STRUCT (r conditions) (any is_output_odd has_odd_output_been_found))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">         )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>This section is a bit unique in that it recurses by handing values back and forth to each other.
Our main entry point is through the first block: <code>check_and_morph_conditions_for_singleton</code> which checks first if we still have conditions.
If we don&#x27;t, we check to see if the <code>has_odd_output_been_found</code> flag has been set and raise if it hasn&#x27;t been.</p><p>If we do have remaining conditions, we pass them to the next function along with the results of checking the first condition to see if it is a <code>CREATE_COIN</code> whose output is odd or the melt value.</p><p>In <code>morph_next_condition</code> we first assert that we have not found a second odd output.
If we have, we raise.
If we have not already run into an odd output, we head to a rather confusing section of the control flow.
The outermost function call essentially waits for the final recursive output and strips out the melt condition if it was found.
That recursive output is generated by taking the first condition, wrapping it in a singleton outer puzzle if it&#x27;s odd, and then passing the rest of the conditions back to <code>check_and_morph_conditions_for_singleton</code> with the <code>has_odd_output_been_found</code> flag set if relevant.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="pay-to-singleton"></a>Pay to Singleton<a class="hash-link" href="#pay-to-singleton" title="Direct link to heading">#</a></h2><p>Now that you understand how a singleton functions, we can now look at an example of &quot;paying to&quot; a singleton or locking up a coin in such a way that only the owner of a specific singleton can unlock it.
The idea is that you curry in the necessary information to calculate the singleton&#x27;s puzzle hash and then assert an announcement from the singleton that says that it is time to claim the funds locked up in the puzzle. Since the puzzle hash will be unique to that singleton (due to the launcher ID being curried in), only that singleton will be able to create the appropriate announcement. Here&#x27;s the puzzle:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI chialisp"><pre tabindex="0" class="prism-code language-chialisp codeBlock_rtdJ thin-scrollbar" style="color:#383a42;background-color:#fafafa;font-weight:bold"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">(mod (</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">       SINGLETON_MOD_HASH</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">       LAUNCHER_ID</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">       LAUNCHER_PUZZLE_HASH</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">       singleton_inner_puzzle_hash</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">       my_id</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">     )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; SINGLETON_MOD_HASH is the mod-hash for the singleton_top_layer puzzle</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; LAUNCHER_ID is the ID of the singleton we are commited to paying to</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; LAUNCHER_PUZZLE_HASH is the puzzle hash of the launcher</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; singleton_inner_puzzle_hash is the innerpuzzlehash for our singleton at the current time</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; my_id is the coin_id of the coin that this puzzle is locked into</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (include condition_codes.clvm)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (include curry-and-treehash.clinc)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; takes a lisp tree and returns the hash of it</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun sha256tree (TREE)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      (if (l TREE)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          (sha256 2 (sha256tree (f TREE)) (sha256tree (r TREE)))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">          (sha256 1 TREE)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">      )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ;; return the full puzzlehash for a singleton with the innerpuzzle curried in</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; puzzle-hash-of-curried-function is imported from curry-and-treehash.clinc</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun-inline calculate_full_puzzle_hash (SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH inner_puzzle_hash)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">     (puzzle-hash-of-curried-function SINGLETON_MOD_HASH</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">                                      inner_puzzle_hash</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">                                      (sha256tree (c SINGLETON_MOD_HASH (c LAUNCHER_ID LAUNCHER_PUZZLE_HASH)))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">     )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (defun-inline claim_rewards (SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH singleton_inner_puzzle_hash my_id)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (list</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 (calculate_full_puzzle_hash SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH singleton_inner_puzzle_hash) my_id))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        (list CREATE_COIN_ANNOUNCEMENT &#x27;$&#x27;)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">        (list ASSERT_MY_COIN_ID my_id))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  )</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  ; main</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">  (claim_rewards SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH singleton_inner_puzzle_hash my_id)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Most of this puzzle should be self explanatory especially if you&#x27;ve gone through the puzzles above.
Let focus on just the conditions we are creating from the <code>claim_rewards</code> function:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI chialisp"><pre tabindex="0" class="prism-code language-chialisp codeBlock_rtdJ thin-scrollbar" style="color:#383a42;background-color:#fafafa;font-weight:bold"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">(list</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 (calculate_full_puzzle_hash SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH singleton_inner_puzzle_hash) my_id))</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (list CREATE_COIN_ANNOUNCEMENT &#x27;$&#x27;)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">    (list ASSERT_MY_COIN_ID my_id)</span></span><span class="token-line" style="color:#383a42;font-weight:bold"><span class="token plain">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>We are both asserting an announcement from the singleton and creating one for it.
The assertion is fundamental to the fact that we only want to be claimed by a very specific singleton.
Due to the launcher ID being curried into the singleton&#x27;s puzzle hash, it will be unique to every singleton and can thereby only be claimed by the singleton whose launcher ID we specify.
We cannot use the singleton&#x27;s coin ID, because if we curried that in, the singleton could spend and then this puzzle becomes unsolvable!</p><p>The announcement that we create is simply for the singleton to assert that we are also being spent.
This is necessary due to the fact that <a href="https://chialisp.com/docs/security#replay-attacks" target="_blank" rel="noopener noreferrer">nodes may try and exclude this spend</a> causing the singleton to spend without claiming these rewards.
Since this coin cannot be signed, we must ensure somehow that if it is excluded, the whole spend bundle fails.
We use <code>&#x27;$&#x27;</code> because it&#x27;s one byte and somewhat relevant.</p><p>The coin ID assertion is simply to ensure that we are being told the truth about our id. Otherwise, we could piggy back on another claim by using that coin&#x27;s ID and asserting the announcement that the singleton creates for it.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/Chia-Network/chialisp-web/edit/main/docs/puzzles/singletons.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/standard_transaction"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« The Standard Transaction</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/puzzles/pooling"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Pooling Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#design-choices" class="table-of-contents__link">Design choices</a></li><li><a href="#the-launcher" class="table-of-contents__link">The Launcher</a></li><li><a href="#the-singleton-top-layer" class="table-of-contents__link">The Singleton Top Layer</a></li><li><a href="#pay-to-singleton" class="table-of-contents__link">Pay to Singleton</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs">Getting Started</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/ref/clvm">CLVM Reference</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://developers.chia.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Chia Developers Forum<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://keybase.io/team/chia_network.public" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Keybase<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://twitter.com/chia_project" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://www.chia.net/blog/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/Chia-Network/clvm" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><a class="footerLogoLink_SRtH" href="/"><img src="/img/full_logo_white.svg" alt="Chialisp full logo" class="themedImage_TMUO themedImage--light_4Vu1 footer__logo"><img src="/img/full_logo_white.svg" alt="Chialisp full logo" class="themedImage_TMUO themedImage--dark_uzRr footer__logo"></a></div><div class="footer__copyright">Â© 2022 Chia Network Inc., Licensed under the <a href="https://github.com/Chia-Network/chialisp-web/blob/main/LICENSE" target="_blank">Apache License, Version 2.0</a> | <a href="https://www.chia.net/terms">Terms</a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.5582d1e8.js"></script>
<script src="/assets/js/main.3d802437.js"></script>
</body>
</html>