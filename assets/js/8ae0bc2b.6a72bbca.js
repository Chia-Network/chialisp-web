(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[56],{9098:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"clvm","title":"CLVM","description":"Chialisp is compiled to bytecode, which is executed on the Chialisp Virtual Machine. CLVM is as minimal as possible, and doesn\'t have direct support for language constructs such as functions, constants, and modules.","source":"@site/docs/clvm.md","sourceDirName":".","slug":"/clvm","permalink":"/clvm","draft":false,"unlisted":false,"editUrl":"https://github.com/Chia-Network/chialisp-web/blob/main/docs/clvm.md","tags":[],"version":"current","frontMatter":{"id":"clvm","title":"CLVM","slug":"/clvm"},"sidebar":"someSidebar","previous":{"title":"Pooling","permalink":"/pooling"}}');var i=t(4848),r=t(8453),a=t(3823);t(11);const l={id:"clvm",title:"CLVM",slug:"/clvm"},o=void 0,h={},d=[{value:"Syntax",id:"syntax",level:2},{value:"Quoting Atoms",id:"quoting-atoms",level:3},{value:"Program Evaluation",id:"program-evaluation",level:2},{value:"Environment",id:"environment",level:2},{value:"Integer Representation",id:"integer-representation",level:2},{value:"Serialization",id:"serialization",level:2},{value:"Nil",id:"nil",level:3},{value:"Small Atoms",id:"small-atoms",level:3},{value:"Large Atoms",id:"large-atoms",level:3},{value:"Cons Pairs",id:"cons-pairs",level:3},{value:"Deserialization",id:"deserialization",level:2},{value:"Nil",id:"nil-1",level:3},{value:"Small Atoms",id:"small-atoms-1",level:3},{value:"Large Atoms",id:"large-atoms-1",level:3},{value:"Cons Pairs",id:"cons-pairs-1",level:3},{value:"Back references",id:"back-references",level:3},{value:"Programs as Parameters",id:"programs-as-parameters",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Chialisp is compiled to bytecode, which is executed on the Chialisp Virtual Machine. CLVM is as minimal as possible, and doesn't have direct support for language constructs such as functions, constants, and modules."}),"\n",(0,i.jsx)(n.p,{children:"This is all implemented by the Chialisp compiler. Although many of the operators are derived from CLVM, many things about Chialisp deviate from the bytecode it compiles to."}),"\n",(0,i.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,i.jsxs)(n.p,{children:["The core language syntax of CLVM is the same as Chialisp. However, it's a much more barebones language with less of the ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Syntactic_sugar",children:"syntactic sugar"})," you may be used to regarding the operators available. Additionally, there are differences in the interpretation of certain things such as numbers. This is explained in more detail below."]}),"\n",(0,i.jsx)(n.h3,{id:"quoting-atoms",children:"Quoting Atoms"}),"\n",(0,i.jsx)(n.p,{children:"In Chialisp, you can write an atom directly like this:"}),"\n",(0,i.jsx)(a.A,{flavor:"chialisp",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-chialisp",children:'"hello"\n'})})}),"\n",(0,i.jsx)(n.p,{children:"However, CLVM will treat that as a call to access the program's environment (explained below)."}),"\n",(0,i.jsx)(n.p,{children:"As a result, all atoms that are intended to be treated as a value must be quoted like this:"}),"\n",(0,i.jsx)(a.A,{flavor:"clvm",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-chialisp",children:'(q . "hello")\n'})})}),"\n",(0,i.jsx)(n.p,{children:"If you forget to do this, you will end up with either an unexpected value, or a path into atom error."}),"\n",(0,i.jsx)(n.h2,{id:"program-evaluation",children:"Program Evaluation"}),"\n",(0,i.jsxs)(n.p,{children:["The syntax of CLVM is similar to Lisp. It is a parenthesized ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Polish_notation",children:"Polish notation"})," that puts the operator before the arguments when reading left to right."]}),"\n",(0,i.jsx)(n.p,{children:"A program is represented as a binary tree. The root of the tree is the least nested object in the program tree, with inner operator calls and values embedded recursively inside of it."}),"\n",(0,i.jsx)(n.p,{children:"In the following example, the outer parentheses represent the cons pair that is the root of the tree:"}),"\n",(0,i.jsx)(a.A,{flavor:"clvm",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-chialisp",children:"(+ (q . 1) (q . 2))\n"})})}),"\n",(0,i.jsxs)(n.p,{children:["Whenever a program is called, it always has an environment (which will be described in more detail later), which is a CLVM value. This value, which is usually a list, holds all of the arguments passed into the program. This is the second command-line argument to ",(0,i.jsx)(n.code,{children:"brun"}),", with the default environment being nil."]}),"\n",(0,i.jsx)(n.p,{children:"If the program being evaluated is a cons pair, then all of the parameters (contained in the right slot of the cons pair) are evaluated. Next, an operator call is made and the result of that function call is returned. The value on the left is the operator that is being called, and the values on the right are its operands."}),"\n",(0,i.jsx)(n.p,{children:"If CLVM is running in strict mode, an unknown opcode will cause the program to terminate. During developer testing, CLVM may be run in non-strict mode, which allows for unknown opcodes to be used and treated as no-ops."}),"\n",(0,i.jsxs)(n.p,{children:["The quote operator, ",(0,i.jsx)(n.code,{children:"q"}),", is ",(0,i.jsx)(n.a,{href:"/syntax#quoting",children:"special"}),". When it is recognized by the interpreter, it causes whatever is on the right to be returned as a value rather than being evaluated as a program. In every other case, the right hand side is evaluated, then passed as operands to the operator on the left."]}),"\n",(0,i.jsx)(n.p,{children:"A CLVM program can be thought of as a binary tree."}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of an operator call:"}),"\n",(0,i.jsx)(a.A,{flavor:"clvm",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-chialisp",children:"(+ (q . 1) (q . 2))\n"})})}),"\n",(0,i.jsxs)(n.p,{children:["The operator is the opcode ",(0,i.jsx)(n.code,{children:"+"}),", which is built-in to the CLVM runtime."]}),"\n",(0,i.jsx)(n.p,{children:"Here is a graph of the program, as stored in memory:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"      [ ]\n     /   \\\n    +     [ ]\n         /   \\\n      [q, 1]  [ ]\n             /   \\\n         [q, 2]  nil\n"})}),"\n",(0,i.jsx)(n.p,{children:"After the first reduction, the program looks like this:"}),"\n",(0,i.jsx)(a.A,{flavor:"chialisp",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-chialisp",children:"(+ 1 2)\n"})})}),"\n",(0,i.jsx)(n.p,{children:"Here is a graph of the new program, as stored in memory:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"      [ ]\n     /   \\\n    +     [ ]\n         /   \\\n        1     [ ]\n             /   \\\n            2    nil\n"})}),"\n",(0,i.jsxs)(n.p,{children:["After the second reduction, and the ",(0,i.jsx)(n.code,{children:"+"})," operator call, it results in the following value:"]}),"\n",(0,i.jsx)(a.A,{flavor:"chialisp",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-chialisp",children:"3\n"})})}),"\n",(0,i.jsx)(n.h2,{id:"environment",children:"Environment"}),"\n",(0,i.jsx)(n.p,{children:"CLVM programs have an environment, which is the value that is used as input. This is also how constants are implemented within programs."}),"\n",(0,i.jsx)(n.p,{children:"Because the environment is just a tree of cons pairs like any other value, it's easy to access individual nodes on that tree using numbers. In fact, this is done so often in CLVM that the default meaning of a number is to access the node at that index. If you want the actual value of the number, you need to quote it."}),"\n",(0,i.jsx)(n.p,{children:"This is what the first few layers of the environment's binary tree numbering looks like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"              1\n             / \\\n            /   \\\n           /     \\\n          /       \\\n         /         \\\n        /           \\\n       2             3\n      / \\           / \\\n     /   \\         /   \\\n    4      6      5     7\n   / \\    / \\    / \\   / \\\n  8   12 10  14 9  13 11  15\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The entire environment can be accessed using ",(0,i.jsx)(n.code,{children:"1"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"You can use the following formula to find any node on the tree:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"first(n) = n * 2\nrest(n) = n * 2 + 1\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of how the environment works in practice:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"brun '1' '(200 500)' # (200 500)\nbrun '2' '(200 500)' # 200 - first\nbrun '3' '(200 500)' # (500) - rest\nbrun '5' '(200 500)' # 500 - first of rest\n"})}),"\n",(0,i.jsx)(n.h2,{id:"integer-representation",children:"Integer Representation"}),"\n",(0,i.jsx)(n.p,{children:"Arithmetic operations will interpret its operands as two's complement, big endian, signed integers. The most significant bit denotes whether a number is negative."}),"\n",(0,i.jsxs)(n.p,{children:["In order to represent a positive integer where the first byte begins with the bit 1, it is necessary to prepend a ",(0,i.jsx)(n.code,{children:"0x00"})," byte. Otherwise, it would be interpreted as a negative integer. Said another way, if a positive integer's first byte is at least ",(0,i.jsx)(n.code,{children:"0x80"}),", then it will be prepended with ",(0,i.jsx)(n.code,{children:"0x00"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Because of this, ",(0,i.jsx)(n.code,{children:"0xFF"})," means -1, whereas ",(0,i.jsx)(n.code,{children:"0x00FF"})," means 255."]}),"\n",(0,i.jsxs)(n.p,{children:["You are likely to encounter this when using the output of an integer operation as the input of a byte operation such as ",(0,i.jsx)(n.code,{children:"sha256"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Since atoms are of arbitrary length, the same integer can be represented by many different atoms. For example, ",(0,i.jsx)(n.code,{children:"0x01"})," and ",(0,i.jsx)(n.code,{children:"0x0001"})," both represent ",(0,i.jsx)(n.code,{children:"1"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Arithmetic operations which return integers always return the shortest representation for numbers (e.g. ",(0,i.jsx)(n.code,{children:"0xFF"})," for ",(0,i.jsx)(n.code,{children:"-1"}),")."]}),"\n",(0,i.jsx)(n.h2,{id:"serialization",children:"Serialization"}),"\n",(0,i.jsx)(n.p,{children:"CLVM is typically stored in binary format, so that it can be quickly read and executed without parsing. It is fairly simple to serialize it into binary format, since programs are stored in a tree structure."}),"\n",(0,i.jsx)(n.p,{children:"Each value is stored as a series of one or more bytes. Data is laid out in a way such that only one value can be encoded in each set of bytes."}),"\n",(0,i.jsx)(n.p,{children:"Because a value may either be an atom or a cons pair, it is necessary to differentiate between the two."}),"\n",(0,i.jsx)(n.h3,{id:"nil",children:"Nil"}),"\n",(0,i.jsxs)(n.p,{children:["The value for nil is unique (represented as ",(0,i.jsx)(n.code,{children:"0x80"})," in hex) and different than zero."]}),"\n",(0,i.jsx)(n.h3,{id:"small-atoms",children:"Small Atoms"}),"\n",(0,i.jsx)(n.p,{children:"Values that are 7 bits or fewer can be represented as a single byte, equivalent to the atom's value itself."}),"\n",(0,i.jsx)(n.h3,{id:"large-atoms",children:"Large Atoms"}),"\n",(0,i.jsx)(n.p,{children:"Values longer than 7 bits are represented as a sequence of bytes that encode the size, followed by the value."}),"\n",(0,i.jsx)(n.p,{children:"The first serialized byte determines the number of size bytes. The size takes up anywhere from 1 to 6 bytes in total, including the first. The size then determines the number of bytes denoting the value - anywhere from 0 to 17,179,869,183 bytes long."}),"\n",(0,i.jsx)(n.p,{children:"The following table shows the bits used to indicate the number of size bytes."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Size Bytes"}),(0,i.jsx)(n.th,{children:"Max Length"}),(0,i.jsx)(n.th,{children:"Byte 1"}),(0,i.jsx)(n.th,{children:"Byte 2"}),(0,i.jsx)(n.th,{children:"Byte 3"}),(0,i.jsx)(n.th,{children:"Byte 4"}),(0,i.jsx)(n.th,{children:"Byte 5"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"0x3F"}),(0,i.jsx)(n.td,{children:"1 ..."}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"2"}),(0,i.jsx)(n.td,{children:"0x1FFF"}),(0,i.jsx)(n.td,{children:"11 ..."}),(0,i.jsx)(n.td,{children:"..."}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"3"}),(0,i.jsx)(n.td,{children:"0xFFFFF"}),(0,i.jsx)(n.td,{children:"111 ..."}),(0,i.jsx)(n.td,{children:"..."}),(0,i.jsx)(n.td,{children:"..."}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"4"}),(0,i.jsx)(n.td,{children:"0x7FFFFFF"}),(0,i.jsx)(n.td,{children:"1111 ..."}),(0,i.jsx)(n.td,{children:"..."}),(0,i.jsx)(n.td,{children:"..."}),(0,i.jsx)(n.td,{children:"..."}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"5"}),(0,i.jsx)(n.td,{children:"0x3FFFFFFFF"}),(0,i.jsx)(n.td,{children:"11111 ..."}),(0,i.jsx)(n.td,{children:"..."}),(0,i.jsx)(n.td,{children:"..."}),(0,i.jsx)(n.td,{children:"..."}),(0,i.jsx)(n.td,{children:"..."})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"In other words, the number of bits set to 1 at the start of the first size byte indicate the total number of size bytes."}),"\n",(0,i.jsx)(n.h3,{id:"cons-pairs",children:"Cons Pairs"}),"\n",(0,i.jsxs)(n.p,{children:["A cons pair is represented with the byte ",(0,i.jsx)(n.code,{children:"0xFF"}),". The two values that follow are the first and rest of the pair, respectively."]}),"\n",(0,i.jsx)(n.h2,{id:"deserialization",children:"Deserialization"}),"\n",(0,i.jsx)(n.p,{children:"To deserialize a program, simply do the same steps in reverse."}),"\n",(0,i.jsx)(n.h3,{id:"nil-1",children:"Nil"}),"\n",(0,i.jsxs)(n.p,{children:["If the first byte is ",(0,i.jsx)(n.code,{children:"0x80"}),", the value is nil."]}),"\n",(0,i.jsx)(n.h3,{id:"small-atoms-1",children:"Small Atoms"}),"\n",(0,i.jsx)(n.p,{children:"If the first byte is 7 or fewer bits in length, the value is an atom equivalent to that byte."}),"\n",(0,i.jsx)(n.h3,{id:"large-atoms-1",children:"Large Atoms"}),"\n",(0,i.jsx)(n.p,{children:"If the first byte is more than 7 bits in length, you will need to do a bit of math to figure out the size and value of the atom."}),"\n",(0,i.jsx)(n.p,{children:"Here is a table you can reference:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"First Byte Max"}),(0,i.jsx)(n.th,{children:"Skipped Bits"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"0xBF"}),(0,i.jsx)(n.td,{children:"2"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"0xDF"}),(0,i.jsx)(n.td,{children:"3"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"0xEF"}),(0,i.jsx)(n.td,{children:"4"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"0xF7"}),(0,i.jsx)(n.td,{children:"5"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"0xFB"}),(0,i.jsx)(n.td,{children:"6"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["The number of skipped bits is also the number of total bytes the size is encoded in. For example, the value ",(0,i.jsx)(n.code,{children:"0xE3"})," would have 4 skipped bits and 4 size bytes, because it is below ",(0,i.jsx)(n.code,{children:"0xEF"}),"."]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.p,{children:"The number of size bytes includes the first."}),(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["It is possible, although discouraged, to encode the length of the atom in more bytes than necessary to fit the number. i.e. have unnecessary leading zeroes. This is similar to ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/UTF-8#Overlong_encodings",children:"UTF-8 overlong encoding"}),". It is not safe to compare CLVM programs in serialized form, since identical programs may compare not equal. To compare programs, use tree hash."]})})]}),"\n",(0,i.jsx)(n.h3,{id:"cons-pairs-1",children:"Cons Pairs"}),"\n",(0,i.jsxs)(n.p,{children:["A cons pair begins with the special value ",(0,i.jsx)(n.code,{children:"0xFF"}),". The first and rest values can be read individually after."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, ",(0,i.jsx)(n.code,{children:"(1 . 2)"})," would be represented as ",(0,i.jsx)(n.code,{children:"0xFF0102"}),". Once you read ",(0,i.jsx)(n.code,{children:"0xFF"}),", you know that the next value is the first of the cons pair, which is ",(0,i.jsx)(n.code,{children:"0x01"}),". Then, the rest of the cons pair is the final value, which in this case is ",(0,i.jsx)(n.code,{children:"0x02"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Lists are typically chains of cons pairs that end in a nil terminator."}),"\n",(0,i.jsx)(n.h3,{id:"back-references",children:"Back references"}),"\n",(0,i.jsxs)(n.p,{children:["As of the hard fork at block height 5 496 000, CLVM serialization was extended with ",(0,i.jsx)(n.em,{children:"back references"}),". This feature allows to refer back to previous CLVM structure, that should be duplicated in the deserialized output. This feature is also sometimes referred to as CLVM compression."]}),"\n",(0,i.jsx)(n.p,{children:"The compression comes from being able to collapse repeated structures. It only needs to be included once, and then referred back to every time it is repeated. This is especially helpful in a block generator where the same puzzle reveal may be included multiple times, for coins secured by the same puzzle. The curried parameters are not repeated, but the underlying puzzle is."}),"\n",(0,i.jsxs)(n.p,{children:["A back reference is introduced by a ",(0,i.jsx)(n.code,{children:"0xFE"})," byte. This byte is followed by an atom that's interpreted as a ",(0,i.jsx)(n.em,{children:"path"}),". The path points into a tree of previously parsed expressions (environment). The lookup works the same as into the CLVM execution ",(0,i.jsx)(n.a,{href:"#Environment",children:"Environnment"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"CLVM trees are parsed bottom-up, left to right. As each atom is parsed, it is prepended to the environment. As each pair is parsed, it pops the top two values of the environment, forms a pair that is then prepended to the environment. Each back-reference performs a path lookup into the environment and prepends the resulting sub tree to the environment."}),"\n",(0,i.jsxs)(n.p,{children:["For example, the following buffer is a serialization of ",(0,i.jsx)(n.code,{children:'("foobar" . ("foobar" . NIL))'}),", ",(0,i.jsx)(n.code,{children:"ff86666f6f626172fe01"}),". It is parsed in the order described in the tree below:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"   [3]\n  /   \\\n 1     2 (backref)\n"})}),"\n",(0,i.jsx)(n.p,{children:"The environment is looks like this in each step:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:'parse atom "foobar"'}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'       []\n      /  \\\n     /    \\\n"foobar"   NIL\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:["parse back reference ",(0,i.jsx)(n.code,{children:"01"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'             []\n            /  \\\n           /    \\\n          /      \\\n         /        \\\n        /          \\\n       []          []\n      /  \\        /  \\\n     /    \\      /    \\\n "foobar" NIL "foobar" NIL\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"parse pair. pop top 2 items and form a pair"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'       []\n      /  \\\n     /    \\\n    /      \\\n "foobar"  []\n          /  \\\n         /    \\\n      "foobar" NIL\n'})}),"\n",(0,i.jsx)(n.h2,{id:"programs-as-parameters",children:"Programs as Parameters"}),"\n",(0,i.jsx)(n.p,{children:"CLVM does not have operators for defining and calling functions. However, it does allow programs to be passed into the environment, as well as executing a value as a program with a new environment."}),"\n",(0,i.jsx)(n.p,{children:"This behavior is how functions are implemented in the Chialisp compiler."}),"\n",(0,i.jsxs)(n.p,{children:["Here is a CLVM program that executes the program contained in the first environment value with its own environment, ",(0,i.jsx)(n.code,{children:"(12)"}),":"]}),"\n",(0,i.jsx)(a.A,{flavor:"clvm",input:"((* 2 (q . 2)))",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-chialisp",children:"(a 2 (q . (12)))\n"})})}),"\n",(0,i.jsx)(n.p,{children:"Taking this further, we can make the program run a new program that only uses values from the original environment:"}),"\n",(0,i.jsx)(a.A,{flavor:"clvm",input:"((* 5 (q . 2)) 10)",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-chialisp",children:"(a 2 1)\n"})})}),"\n",(0,i.jsx)(n.p,{children:"We can use this technique to implement recursive functions."})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},3823:(e,n,t)=>{"use strict";t.d(n,{A:()=>g});var s=t(5293),i=t(11),r=t(1765),a=t(6540),l=t(5604),o=t(6069),h=t.n(o),d=t(5871),c=t.n(d),p=t(9031),u=t.n(p);function x(e){return e instanceof Array||(0,a.isValidElement)(e)?a.Children.toArray(e).reduce(((e,n)=>{let t="";return t=(0,a.isValidElement)(n)&&j(n)?x(n.props.children):(0,a.isValidElement)(n)&&!j(n)?"":m(n),e.concat(t)}),""):m(e)}function m(e){return null==e||"boolean"==typeof e||"{}"===JSON.stringify(e)?"":e.toString()}function j(e){return(0,a.isValidElement)(e)&&Boolean(e.props.children)}var f=t(4848);function g(e){let{children:n,flavor:t,input:o,tests:h,reporter:d}=e;const{colorMode:p}=(0,s.G)(),m=(0,a.useMemo)((()=>x(n).trim()),[]),[j,g]=(0,a.useState)(m),[y,v]=(0,a.useState)(o??Object.keys(h??{})[0]?.trim()??""),[w,k]=(0,a.useState)(""),[F,C]=(0,a.useState)(0n),[T,z]=(0,a.useState)(null),L=e=>e.replace("Error: ",""),A=(e,n)=>{try{return e.run(n)}catch(t){return k(`While evaluating: ${L(""+t)}`),null}},M=()=>{const e=(()=>{try{return i.Program.fromSource(j)}catch(e){return k(`While parsing: ${L(""+e)}`),null}})();if(!e)return;const n="clvm"===t||e.isCons&&e.first.equals(i.Program.fromText("mod")),s=(e=>{if(t&&"chialisp"!==t)return e;try{return e.compile().value}catch(n){return k(`While compiling: ${L(""+n)}`),null}})(e);if(!s)return;const r=y?i.Program.fromSource(y):i.Program.nil,a=n?A(s,r):{value:s,cost:0n};a&&(k(a.value.toSource()),C(a.cost));let l=!0;for(const[t,o]of Object.entries(h??{})){const e=i.Program.fromSource(t),r=n?A(s,e)?.value:s;if(!r||r.toSource()!==o){l=!1;break}}d?.(l),z(l)},V=T?l.CMH:l.QCr,[S,q]=a.useState(!1);return(0,a.useEffect)((()=>q(!0)),[]),(0,f.jsx)(r.f4,{Prism:globalThis.Prism,theme:S&&("dark"===p?c():u()),code:j,language:"chialisp",children:e=>{let{className:n,style:s}=e;return(0,f.jsxs)("pre",{className:n,style:{...s,position:"relative"},children:[y?(0,f.jsxs)(f.Fragment,{children:[(0,f.jsx)(b,{code:y,setCode:v,language:"chialisp"}),(0,f.jsx)("hr",{style:{marginTop:"14px",marginBottom:"14px"}})]}):"",(0,f.jsx)(b,{code:j,setCode:g,language:"chialisp"}),(0,f.jsx)("div",{style:{position:"absolute",top:"16px",right:"16px"},children:(0,f.jsxs)("div",{style:{display:"flex",alignItems:"center",gap:"14px"},children:[(0,f.jsx)("span",{style:{marginRight:"8px"},children:t&&"chialisp"!==t?"CLVM":"Chialisp"}),!y&&(0,f.jsx)(l.TlQ,{size:24,className:"icon-button",cursor:"pointer",onClick:()=>v("()")}),(0,f.jsx)(l.gSK,{size:24,className:"icon-button",cursor:"pointer",onClick:M})]})}),w?(0,f.jsxs)(f.Fragment,{children:[(0,f.jsx)("hr",{style:{marginTop:"14px",marginBottom:"14px"}}),(0,f.jsx)("div",{style:{display:"inline-block"},children:(0,f.jsx)(b,{code:w,language:"chialisp"})}),w&&(0,f.jsxs)(f.Fragment,{children:[(0,f.jsx)("div",{style:{display:"inline-block",position:"absolute",right:"60px"},children:(0,f.jsx)(b,{code:`Cost: ${F}`,language:"chialisp"})}),(0,f.jsx)(V,{size:24,color:T?"#77FF77":"#FF7777",style:{position:"absolute",bottom:"16px",right:"16px"}})]})]}):""]})}})}function b(e){let{code:n,setCode:t,language:i}=e;const{colorMode:l}=(0,s.G)(),[o,d]=a.useState(!1);return(0,a.useEffect)((()=>d(!0)),[]),(0,f.jsx)(f.Fragment,{children:(0,f.jsx)(r.f4,{Prism:globalThis.Prism,theme:o&&("dark"===l?c():u()),code:n,language:i,children:e=>{let{tokens:s,getLineProps:i,getTokenProps:r}=e,a=s.map(((e,n)=>(0,f.jsx)("div",{...i({line:e}),children:e.map(((e,n)=>(0,f.jsx)("span",{...r({token:e})},n)))},n)));return t?(0,f.jsx)(h(),{value:n,onValueChange:e=>t(e),highlight:()=>a,padding:0}):a}})})}},5871:e=>{e.exports={plain:{color:"#F8F8F2",backgroundColor:"#282A36",fontWeight:"bold"},styles:[{types:["keyword"],style:{color:"rgb(189, 147, 249)"}},{types:["listop","class-name","quotes"],style:{color:"rgb(80, 250, 123)"}},{types:["builtin"],style:{color:"rgb(5, 227, 223)"}},{types:["number","hexadecimal","string","boolean"],style:{color:"rgb(255, 184, 108)",fontWeight:"normal"}},{types:["punctuation","symbol"],style:{color:"rgb(248, 248, 242)"}},{types:["variable"],style:{fontStyle:"italic"}},{types:["comment"],style:{color:"rgb(98, 114, 164)",fontWeight:"normal"}},{types:["function","car"],style:{color:"rgb(241, 250, 140)"}}]}},9031:e=>{e.exports={plain:{color:"#383a42",backgroundColor:"#fafafa",fontWeight:"bold"},styles:[{types:["keyword"],style:{color:"#990096"}},{types:["listop","class-name","quotes"],style:{color:"#006100"}},{types:["builtin"],style:{color:"#127EAF"}},{types:["number","hexadecimal","string","boolean"],style:{color:"#B35C00",fontWeight:"normal"}},{types:["punctuation","symbol"],style:{color:"#383a42"}},{types:["variable"],style:{fontStyle:"italic"}},{types:["comment"],style:{color:"#73737D",fontWeight:"normal"}},{types:["function","car"],style:{color:"#0045DB"}}]}}}]);