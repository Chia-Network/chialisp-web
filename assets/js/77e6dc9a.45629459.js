"use strict";(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[8586],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=p(n),d=r,h=c["".concat(s,".").concat(d)]||c[d]||m[d]||i;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5603:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return m}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),l=["components"],o={id:"high_level_lang",title:"Language Overview",slug:"/"},s=void 0,p={unversionedId:"high_level_lang",id:"high_level_lang",title:"Language Overview",description:"Chialisp is a high-level, LISP-like language for implementing smart-contract capabilities called puzzles on Chia. Chialisp program compiles into Chialisp Virtual Machine (CLVM). CLVM is serialized and stored directly on the blockchain and is a matter of consensus; it can never be changed. While CLVM powers Chialip, they share many fundamental concepts. Click through the CLVM basic to learn more about CLVM.",source:"@site/docs/high_level_lang.md",sourceDirName:".",slug:"/",permalink:"/docs/",draft:!1,editUrl:"https://github.com/Chia-Network/chialisp-web/edit/main/docs/high_level_lang.md",tags:[],version:"current",frontMatter:{id:"high_level_lang",title:"Language Overview",slug:"/"},sidebar:"someSidebar",previous:{title:"First Smart Coin",permalink:"/docs/getting_started/first_smart_coin"},next:{title:"Common Functions and Design Patterns",permalink:"/docs/common_functions"}},u={},m=[{value:"Values",id:"values",level:2},{value:"Atoms",id:"atoms",level:3},{value:"Cons Boxes",id:"cons-boxes",level:3},{value:"Chialisp program",id:"chialisp-program",level:2},{value:"Operators",id:"operators",level:2},{value:"Arithematic",id:"arithematic",level:3},{value:"Control Flow",id:"control-flow",level:3},{value:"Comparison",id:"comparison",level:3},{value:"Constructing a List",id:"constructing-a-list",level:3},{value:"Quote",id:"quote",level:3},{value:"Program Structure",id:"program-structure",level:2},{value:"mod",id:"mod",level:3},{value:"include",id:"include",level:3},{value:"Functions, Macros and Constants",id:"functions-macros-and-constants",level:3},{value:"Example: Factorial",id:"example-factorial",level:3},{value:"Example: Squaring a List",id:"example-squaring-a-list",level:3}],c={toc:m};function d(e){var t=e.components,n=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Chialisp is a high-level, LISP-like language for implementing smart-contract capabilities called ",(0,i.kt)("strong",{parentName:"p"},"puzzles")," on Chia. Chialisp program compiles into Chialisp Virtual Machine (CLVM). CLVM is serialized and stored directly on the blockchain and is a matter of consensus; it can never be changed. While CLVM powers Chialip, they share many fundamental concepts. Click through the ",(0,i.kt)("a",{parentName:"p",href:"clvm/basics"},"CLVM basic")," to learn more about CLVM."),(0,i.kt)("p",null,"If you are new to Chialisp, check out the ",(0,i.kt)("a",{parentName:"p",href:"getting_started/intro_to_chialisp"},"Chialisp Getting Started Guides")," first."),(0,i.kt)("h2",{id:"values"},"Values"),(0,i.kt)("p",null,"There are no variables in Chialisp. Values are stored in two different objects: ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Lisp_(programming_language)#Atoms"},"atoms")," and ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Cons"},"cons boxes"),". A cons box is a pair of objects; the objects in a cons box can either be an atom or another cons box."),(0,i.kt)("h3",{id:"atoms"},"Atoms"),(0,i.kt)("p",null,"An atom is an array of bytes. These bytes can be interpreted both as a signed big-endian integer or a byte string, depending on the operator using it. "),(0,i.kt)("p",null,"All atoms are immutable; therefore, operators that perform computations on atoms create new atoms for the result."),(0,i.kt)("p",null,"Atoms can be printed in three different ways: decimal, hexadecimal, and string. Hexadecimal values are prefixed by ",(0,i.kt)("inlineCode",{parentName:"p"},"0x"),", and strings are quoted in ",(0,i.kt)("inlineCode",{parentName:"p"},'"'),"."),(0,i.kt)("h3",{id:"cons-boxes"},"Cons Boxes"),(0,i.kt)("p",null,"Cons boxes are represented as parentheses with two elements separated by a ",(0,i.kt)("inlineCode",{parentName:"p"},"."),".\nFor example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},'(200 . "hello")\n\n("hello" . ("world" . "!!!"))\n')),(0,i.kt)("p",null,"A cons box always has two elements. For example, the following is not a valid cons box,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(200 . 300 . 400)\n")),(0,i.kt)("h2",{id:"chialisp-program"},"Chialisp program"),(0,i.kt)("p",null,"The building blocks of the Chialisp program are lists and operators. A list is any space-separated, ordered group of one or more items inside parenthesis brackets. A strict definition of a list is a representation of consecutive cons boxes terminated in a null atom ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),".\nChialisp simplified the representation by allowing omitting implied inner parenthesis brackets in the list. For example, the following expressions are equal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(200 . (300 . (400 . ())))\n\n(200 300 400)\n")),(0,i.kt)("p",null,"A Chialisp program is a list of ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Polish_notation"},"prefix notation")," form. A valid Chialisp program requires:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The first item in the list must be a valid operator"),(0,i.kt)("li",{parentName:"ol"},"Every item after the first must be a valid program")),(0,i.kt)("p",null,"Take the arithmetic addition operator '+' for example; the list (+ 2 3) computes the sum of integers 2 and 3. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"run '(+ 2 3)'\n5\n")),(0,i.kt)("h2",{id:"operators"},"Operators"),(0,i.kt)("h3",{id:"arithematic"},"Arithematic"),(0,i.kt)("p",null,"The arithmetic operators ",(0,i.kt)("inlineCode",{parentName:"p"},"+, -, *, /")," and divmod treat their arguments as signed integers."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Operator"),(0,i.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("pre",null,"+")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("pre",null,"(+ a0 a1 ...)")),(0,i.kt)("td",{parentName:"tr",align:null},"It takes any number of integer operands and sums them. If given no arguments, zero is returned.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("pre",null,"-")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("pre",null,"(- a0 a1 ...)")),(0,i.kt)("td",{parentName:"tr",align:null},"It takes one or more integer operands and adds a0 to the negative of the rest. Giving zero arguments returns 0.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("pre",null,"*")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("pre",null,"(* a0 a1 ...)")),(0,i.kt)("td",{parentName:"tr",align:null},"It takes any number of integer operands and returns the product.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("pre",null,"/")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("pre",null,"(/ A B)")),(0,i.kt)("td",{parentName:"tr",align:null},"It divides two integers and returns the floored quotient. Rounding for ",(0,i.kt)("inlineCode",{parentName:"td"},"/"),": ",(0,i.kt)("ul",null," ",(0,i.kt)("li",null,(0,i.kt)("inlineCode",{parentName:"td"},"(/ 1 2)")," => ()")," ",(0,i.kt)("li",null,(0,i.kt)("inlineCode",{parentName:"td"},"(/ 2 2)")," => 1")," ",(0,i.kt)("li",null,(0,i.kt)("inlineCode",{parentName:"td"},"(/ 4 2)")," => 2 "))," The treatment of negative dividend and divisors is as follows:",(0,i.kt)("ul",null,(0,i.kt)("li",null,(0,i.kt)("inlineCode",{parentName:"td"},"(/ -1 1)")," => -1"),(0,i.kt)("li",null,(0,i.kt)("inlineCode",{parentName:"td"},"(/ 1 -1)")," => -1"),(0,i.kt)("li",null,(0,i.kt)("inlineCode",{parentName:"td"},"(/ -1 -1)")," =>  1"))," A division with a remainder always rounds towards negative infinity, not toward zero:",(0,i.kt)("ul",null,(0,i.kt)("li",null,(0,i.kt)("inlineCode",{parentName:"td"},"(/ -3 2)")," => -2"),(0,i.kt)("li",null,(0,i.kt)("inlineCode",{parentName:"td"},"(/ 3 2)")," => 1"))," This means that ",(0,i.kt)("inlineCode",{parentName:"td"},"-a / b")," is not always equal to ",(0,i.kt)("inlineCode",{parentName:"td"},"-(a / b)"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("pre",null,"divmod")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("pre",null,"(divmod A B)")),(0,i.kt)("td",{parentName:"tr",align:null},"Ittakes two integers and returns a cons-box containing the floored quotient and the remainder.")))),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Once Chia\u2019s blockchain reaches a height of 2,300,000 (around July 22, 2022), all nodes running version 1.3 or greater will reject all spends which attempt to use the div operator for negative division. ",(0,i.kt)("a",{parentName:"p",href:"https://www.chia.net/2022/03/04/divided-we-fork.en.html"},"Learn more about the change."))),(0,i.kt)("h3",{id:"control-flow"},"Control Flow"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Operator"),(0,i.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("pre",null,"if")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("pre",null," (if A B C) ")),(0,i.kt)("td",{parentName:"tr",align:null},"If A is (), return C, otherwise return B. ",(0,i.kt)("inlineCode",{parentName:"td"},"if")," condition takes exactly three operands .")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("pre",null," x")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("pre",null,"(x X Y ...)")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"x")," raises exception and immediately fails execution, with the argument list passed up into the (python) exception. No other CLVM instructions are run after this instruction is evaluated It takes an arbitrary number of arguments (even zero).")))),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"if")," does a lazy evaluation form, so we do not need to worry about the unused code path being evaluated."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"$ run '(if 1 (q . \"success\") (x))' '(100)'\n\"success\"\n\n$ run '(if 0 (q . \"success\") (x))' '(100)'\nFAIL: clvm raise ()\n"))),(0,i.kt)("h3",{id:"comparison"},"Comparison"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Operator"),(0,i.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("pre",null,"=")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("pre",null,"(= A B)")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"=")," equal returns 1 if A and B are both atoms and both equal. Otherwise (). Do not use this to test if two programs are identical. That is determined by their tree hash. Nil tests equal to zero, but nil is not equal to a single zero byte.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("pre",null,">")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("pre",null,"(> A B)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns 1 if A and B are both atoms and A is greater than B, interpreting both as two's complement signed integers. Otherwise (). (> A B) means A > B in infix syntax.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("pre",null,">s")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("pre",null,"(>s A B)")),(0,i.kt)("td",{parentName:"tr",align:null},'Returns 1 if A and B are both atoms and A is greater than B, interpreting both as an array of unsigned bytes. Otherwise (). Compared to strcmp. (>s "a" "b") => ()')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("pre",null,"not")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("pre",null,"(not A)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns 1 if A evaluates to (). Otherwise, returns ().")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("pre",null,"all")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("pre",null,"(all A B ...)")),(0,i.kt)("td",{parentName:"tr",align:null},"Takes an arbitrary number of arguments (even zero). Returns () if any of the arguments evaluate to (). Otherwise, returns 1.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("pre",null," any")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("pre",null,"(any A B ...)")),(0,i.kt)("td",{parentName:"tr",align:null},"Takes an arbitrary number of arguments (even zero). Returns 1 if any of the arguments evaluate to something other than (). Otherwise, returns ().")))),(0,i.kt)("h3",{id:"constructing-a-list"},"Constructing a List"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"list")," takes any number of parameters and returns them put inside a list.\nThis saves us from having to manually create nested ",(0,i.kt)("inlineCode",{parentName:"p"},"(c (A) (c (B) (q ())))")," calls, which can get messy quickly."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},'$ run \'(list 100 "test" 0xdeadbeef)\'\n(100 "test" 0xdeadbeef)\n')),(0,i.kt)("h3",{id:"quote"},"Quote"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"qq")," allows us to quote something with selected portions being evaluated inside by using ",(0,i.kt)("inlineCode",{parentName:"p"},"unquote"),".\nThe advantages of this may not be immediately obvious but are extremely useful in practice as it allows us to substitute sections of predetermined code."),(0,i.kt)("p",null,"Suppose we are writing a program that returns another coin's puzzle.\nWe know that a puzzle takes the form: ",(0,i.kt)("inlineCode",{parentName:"p"},"(c (c (q . 50) (c (q . 0xpubkey) (c (sha256 2) (q . ())))) (a 5 11))"),"\nHowever, we will want to change 0xpubkey to a value passed to us through our solution."),(0,i.kt)("p",null,"Note: ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," allows us to access the arguments in the higher-level language (",(0,i.kt)("inlineCode",{parentName:"p"},"@")," == 1)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"$ run '(qq (c (c (q . 50) (c (q . (unquote (f @))) (c (sha256 2) ()))) (a 5 11)))' '(0xdeadbeef)'\n\n(c (c (q . 50) (c (q . 0xdeadbeef) (c (sha256 2) ()))) (a 5 11))\n")),(0,i.kt)("h2",{id:"program-structure"},"Program Structure"),(0,i.kt)("h3",{id:"mod"},"mod"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"(mod A B)")," takes two or more parameters. The first is used to name parameters that are passed in, and the rest are the higher-level script that is to be compiled."),(0,i.kt)("p",null,"Below we name our arguments ",(0,i.kt)("inlineCode",{parentName:"p"},"arg_one")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"arg_two")," and then access ",(0,i.kt)("inlineCode",{parentName:"p"},"arg_one")," inside our main program."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"$ run '(mod (arg_one arg_two) (list arg_one))'\n(c 2 ())\n")),(0,i.kt)("p",null,"As you can see, it returns our program in compiled lower level form."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"$ brun '(c 2 ())' '(100 200 300)'\n(100)\n")),(0,i.kt)("p",null,"You may be wondering what other parameters ",(0,i.kt)("inlineCode",{parentName:"p"},"mod")," takes between variable names and source code."),(0,i.kt)("h3",{id:"include"},"include"),(0,i.kt)("p",null,"If you want to import some functionality that you frequently use without having to copy/paste it between files, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"include"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},";; condition_codes.clvm\n(\n (defconstant AGG_SIG_ME 50)\n (defconstant CREATE_COIN 51)\n)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},';;main.clvm\n(mod (pubkey msg puzzle_hash amount)\n\n (include "condition_codes.clvm")\n\n (list (list AGG_SIG_ME pubkey msg) (list CREATE_COIN puzzle_hash amount))\n\n)\n')),(0,i.kt)("p",null,"When running main.clvm with ",(0,i.kt)("inlineCode",{parentName:"p"},"run"),", make sure to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"-i")," option to specify in which directories to look for includable files.\nIf our condition_codes.clvm file was in the directory ",(0,i.kt)("inlineCode",{parentName:"p"},"./libraries/chialisp/"),", then you would pass that to ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," so that it knows where to find it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"run -i ./libraries/chialisp/ main.clvm\n")),(0,i.kt)("p",null,"Also, note that the included files are in a special format. Everything that is defined goes into a single set of parentheses like in condition_codes.clvm above.\nYou can then use any of those constants/functions when writing your program without having to import each one individually.\nThe compiler will only include things that you use, so don't worry about including a large library file when attempting to optimize the size of your program."),(0,i.kt)("h3",{id:"functions-macros-and-constants"},"Functions, Macros and Constants"),(0,i.kt)("p",null,"In the higher-level language we can define functions, macros, and constants before our program by using ",(0,i.kt)("inlineCode",{parentName:"p"},"defun"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"defun-inline"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"defmacro"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"defconstant"),"."),(0,i.kt)("p",null,"We can define as many of these as we like before the main source code.\nUsually, a program will be structured like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(mod (arg_one arg_two)\n (defconstant const_name value)\n (defun function_name (parameter_one parameter_two) *function_code*)\n (defun another_function (param_one param_two param_three) *function_code*)\n (defun-inline utility_function (param_one param_two) *function_code*)\n (defmacro macro_name (param_one param_two) *macro_code*)\n\n (main *program*)\n)\n")),(0,i.kt)("p",null,"A few things to note:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Functions can reference themselves in their code, but macros and inlines cannot as they are inserted at compile time."),(0,i.kt)("li",{parentName:"ul"},"Both functions and macros can reference other functions, macros, and constants."),(0,i.kt)("li",{parentName:"ul"},"Macros that refer to their parameters must be quasiquoted with the parameters unquoted"),(0,i.kt)("li",{parentName:"ul"},"Be careful of infinite loops in macros that reference other macros."),(0,i.kt)("li",{parentName:"ul"},"Comments can be written with semicolons"),(0,i.kt)("li",{parentName:"ul"},"Inline functions are generally more cost-effective than regular functions except when reusing calculated arguments: ",(0,i.kt)("inlineCode",{parentName:"li"},"(defun-inline foo (X) (+ X X)) (foo (* 200 300))")," will perform the expensive multiplication twice")),(0,i.kt)("h3",{id:"example-factorial"},"Example: Factorial"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(mod (arg_one)\n ; function definitions\n (defun factorial (input)\n (if (= input 1) 1 (* (factorial (- input 1)) input))\n )\n\n ; main\n (factorial arg_one)\n)\n")),(0,i.kt)("p",null,"We can save these files to .clvm files, which can be run from the command line.\nSaving the above example as ",(0,i.kt)("inlineCode",{parentName:"p"},"factorial.clvm")," allows us to do the following."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"$ run factorial.clvm\n(a (q 2 2 (c 2 (c 5 ()))) (c (q 2 (i (= 5 (q . 1)) (q 1 . 1) (q 18 (a 2 (c 2 (c (- 5 (q . 1)) ()))) 5)) 1) 1))\n\n$ brun '(a (q 2 2 (c 2 (c 5 ()))) (c (q 2 (i (= 5 (q . 1)) (q 1 . 1) (q 18 (a 2 (c 2 (c (- 5 (q . 1)) ()))) 5)) 1) 1))' '(5)'\n120\n")),(0,i.kt)("h3",{id:"example-squaring-a-list"},"Example: Squaring a List"),(0,i.kt)("p",null,"Now let's do an example that uses macros as well.\nWhen writing a macro, it must be quasiquoted with the parameters being unquoted."),(0,i.kt)("p",null,"We can also take this time to show another feature of the compiler.\nYou can name each parameter in a list or name the list itself.\nThis works at any place where you name parameters and allows you to handle lists where you aren't sure of the size."),(0,i.kt)("p",null,"Here we define a macro to square a parameter and then a function to square a list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(mod (args)\n\n (defmacro square (input)\n (qq (* (unquote input) (unquote input)))\n )\n\n (defun sqre_list (my_list)\n (if my_list\n (c (square (f my_list)) (sqre_list (r my_list)))\n my_list\n )\n )\n\n (sqre_list args)\n)\n")),(0,i.kt)("p",null,"Compiling and running this code results in this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"$ run square_list.clvm\n(a (q 2 2 (c 2 (c 5 ()))) (c (q 2 (i 5 (q 4 (* 9 9) (a 2 (c 2 (c 13 ())))) (q . 5)) 1) 1))\n\n$ brun '(a (q 2 2 (c 2 (c 5 ()))) (c (q 2 (i 5 (q 4 (* 9 9) (a 2 (c 2 (c 13 ())))) (q . 5)) 1) 1))' '((10 9 8 7))'\n(100 81 64 49)\n")))}d.isMDXComponent=!0}}]);