"use strict";(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[202],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),h=p(n),d=r,c=h["".concat(s,".").concat(d)]||h[d]||m[d]||i;return n?a.createElement(c,l(l({ref:t},u),{},{components:n})):a.createElement(c,l({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2352:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return m}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),l=["components"],o={id:"clvm",title:"CLVM",slug:"/clvm"},s=void 0,p={unversionedId:"clvm",id:"clvm",title:"CLVM",description:"Chialisp is compiled to bytecode, which is executed on the Chialisp Virtual Machine. CLVM is as minimal as possible, and doesn't have direct support for language constructs such as functions, constants, and modules.",source:"@site/docs/clvm.md",sourceDirName:".",slug:"/clvm",permalink:"/clvm",draft:!1,editUrl:"https://github.com/Chia-Network/{{ REPOSITORY_NAME }}/blob/main/docs/clvm.md",tags:[],version:"current",frontMatter:{id:"clvm",title:"CLVM",slug:"/clvm"},sidebar:"someSidebar",previous:{title:"Pooling",permalink:"/pooling"}},u={},m=[{value:"Syntax",id:"syntax",level:2},{value:"Quoting Atoms",id:"quoting-atoms",level:3},{value:"Program Evaluation",id:"program-evaluation",level:2},{value:"Environment",id:"environment",level:2},{value:"Integer Representation",id:"integer-representation",level:2},{value:"Serialization",id:"serialization",level:2},{value:"Nil",id:"nil",level:3},{value:"Small Atoms",id:"small-atoms",level:3},{value:"Large Atoms",id:"large-atoms",level:3},{value:"Cons Pairs",id:"cons-pairs",level:3},{value:"Deserialization",id:"deserialization",level:2},{value:"Nil",id:"nil-1",level:3},{value:"Small Atoms",id:"small-atoms-1",level:3},{value:"Large Atoms",id:"large-atoms-1",level:3},{value:"Cons Pairs",id:"cons-pairs-1",level:3},{value:"Programs as Parameters",id:"programs-as-parameters",level:2}],h={toc:m};function d(e){var t=e.components,n=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Chialisp is compiled to bytecode, which is executed on the Chialisp Virtual Machine. CLVM is as minimal as possible, and doesn't have direct support for language constructs such as functions, constants, and modules."),(0,i.kt)("p",null,"This is all implemented by the Chialisp compiler. Although many of the operators are derived from CLVM, many things about Chialisp deviate from the bytecode it compiles to."),(0,i.kt)("h2",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"The core language syntax of CLVM is the same as Chialisp. However, it's a much more barebones language with less of the ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Syntactic_sugar"},"syntactic sugar")," you may be used to regarding the operators available. Additionally, there are differences in the interpretation of certain things such as numbers. This is explained in more detail below."),(0,i.kt)("h3",{id:"quoting-atoms"},"Quoting Atoms"),(0,i.kt)("p",null,"In Chialisp, you can write an atom directly like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},'"hello"\n')),(0,i.kt)("p",null,"However, CLVM will treat that as a call to access the program's environment (explained below)."),(0,i.kt)("p",null,"As a result, all atoms that are intended to be treated as a value must be quoted like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},'(q . "hello")\n')),(0,i.kt)("p",null,"If you forget to do this, you will end up with either an unexpected value, or a path into atom error."),(0,i.kt)("h2",{id:"program-evaluation"},"Program Evaluation"),(0,i.kt)("p",null,"The syntax of CLVM is similar to Lisp. It is a parenthesized ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Polish_notation"},"Polish notation")," that puts the operator before the arguments when reading left to right."),(0,i.kt)("p",null,"A program is represented as a binary tree. The root of the tree is the least nested object in the program tree, with inner operator calls and values embedded recursively inside of it."),(0,i.kt)("p",null,"In the following example, the outer parentheses represent the cons pair that is the root of the tree:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(+ (q . 1) (q . 2))\n")),(0,i.kt)("p",null,"Whenever a program is called, it always has an environment (which will be described in more detail later), which is a CLVM value. This value, which is usually a list, holds all of the arguments passed into the program. This is the second command-line argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"brun"),", with the default environment being nil."),(0,i.kt)("p",null,"If the program being evaluated is a cons pair, then all of the parameters (contained in the right slot of the cons pair) are evaluated. Next, an operator call is made and the result of that function call is returned. The value on the left is the operator that is being called, and the values on the right are its operands."),(0,i.kt)("p",null,"If CLVM is running in strict mode, an unknown opcode will cause the program to terminate. During developer testing, CLVM may be run in non-strict mode, which allows for unknown opcodes to be used and treated as no-ops."),(0,i.kt)("p",null,"The quote operator, ",(0,i.kt)("inlineCode",{parentName:"p"},"q"),", is special. When it is recognized by the interpreter, it causes whatever is on the right to be returned as a value rather than being evaluated as a program. In every other case, the right hand side is evaluated, then passed as operands to the operator on the left."),(0,i.kt)("p",null,"A CLVM program can be thought of as a binary tree."),(0,i.kt)("p",null,"Here is an example of an operator call:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(+ (q . 1) (q . 2))\n")),(0,i.kt)("p",null,"The operator is the opcode ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", which is built-in to the CLVM runtime."),(0,i.kt)("p",null,"Here is a graph of the program, as stored in memory:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"      [ ]\n     /   \\\n    +     [ ]\n         /   \\\n      [q, 1]  [ ]\n             /   \\\n         [q, 2]  nil\n")),(0,i.kt)("p",null,"After the first reduction, the program looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(+ 1 2)\n")),(0,i.kt)("p",null,"Here is a graph of the new program, as stored in memory:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"      [ ]\n     /   \\\n    +     [ ]\n         /   \\\n        1     [ ]\n             /   \\\n            2    nil\n")),(0,i.kt)("p",null,"After the second reduction, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," operator call, it results in the following value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"3\n")),(0,i.kt)("h2",{id:"environment"},"Environment"),(0,i.kt)("p",null,"CLVM programs have an environment, which is the value that is used as input. This is also how constants are implemented within programs."),(0,i.kt)("p",null,"Because the environment is just a tree of cons pairs like any other value, it's easy to access individual nodes on that tree using numbers. In fact, this is done so often in CLVM that the default meaning of a number is to access the node at that index. If you want the actual value of the number, you need to quote it."),(0,i.kt)("p",null,"This is what the first few layers of the environment's binary tree numbering looks like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"              1\n             / \\\n            /   \\\n           /     \\\n          /       \\\n         /         \\\n        /           \\\n       2             3\n      / \\           / \\\n     /   \\         /   \\\n    4      6      5     7\n   / \\    / \\    / \\   / \\\n  8   12 10  14 9  13 11  15\n")),(0,i.kt)("p",null,"The entire environment can be accessed using ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,i.kt)("p",null,"You can use the following formula to find any node on the tree:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"first(n) = n * 2\nrest(n) = n * 2 + 1\n")),(0,i.kt)("p",null,"Here is an example of how the environment works in practice:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"brun '1' '(200 500)' # (200 500)\nbrun '2' '(200 500)' # 200 - first\nbrun '3' '(200 500)' # (500) - rest\nbrun '5' '(200 500)' # 500 - first of rest\n")),(0,i.kt)("h2",{id:"integer-representation"},"Integer Representation"),(0,i.kt)("p",null,"Arithmetic operations will interpret its operands as two's complement, big endian, signed integers. The most significant bit denotes whether a number is negative."),(0,i.kt)("p",null,"In order to represent a positive integer where the first byte begins with the bit 1, it is necessary to prepend a ",(0,i.kt)("inlineCode",{parentName:"p"},"0x00")," byte. Otherwise, it would be interpreted as a negative integer. Said another way, if a positive integer's first byte is at least ",(0,i.kt)("inlineCode",{parentName:"p"},"0x80"),", then it will be prepended with ",(0,i.kt)("inlineCode",{parentName:"p"},"0x00"),"."),(0,i.kt)("p",null,"Because of this, ",(0,i.kt)("inlineCode",{parentName:"p"},"0xFF")," means -1, whereas ",(0,i.kt)("inlineCode",{parentName:"p"},"0x00FF")," means 255."),(0,i.kt)("p",null,"You are likely to encounter this when using the output of an integer operation as the input of a byte operation such as ",(0,i.kt)("inlineCode",{parentName:"p"},"sha256"),"."),(0,i.kt)("p",null,"Since atoms are of arbitrary length, the same integer can be represented by many different atoms. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"0x01")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"0x0001")," both represent ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,i.kt)("p",null,"Arithmetic operations which return integers always return the shortest representation for numbers (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"0xFF")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"-1"),")."),(0,i.kt)("h2",{id:"serialization"},"Serialization"),(0,i.kt)("p",null,"CLVM is typically stored in binary format, so that it can be quickly read and executed without parsing. It is fairly simple to serialize it into binary format, since programs are stored in a tree structure."),(0,i.kt)("p",null,"Each value is stored as a series of one or more bytes. Data is laid out in a way such that only one value can be encoded in each set of bytes."),(0,i.kt)("p",null,"Because a value may either be an atom or a cons pair, it is necessary to differentiate between the two."),(0,i.kt)("h3",{id:"nil"},"Nil"),(0,i.kt)("p",null,"The value for nil is unique (represented as ",(0,i.kt)("inlineCode",{parentName:"p"},"0x80")," in hex) and different than zero."),(0,i.kt)("h3",{id:"small-atoms"},"Small Atoms"),(0,i.kt)("p",null,"Values that are 7 bits or fewer can be represented as a single byte, equivalent to the atom's value itself."),(0,i.kt)("h3",{id:"large-atoms"},"Large Atoms"),(0,i.kt)("p",null,"Values longer than 7 bits are represented as a sequence of bytes that encode the size, followed by the value."),(0,i.kt)("p",null,"The first serialized byte determines the number of size bytes. The size takes up anywhere from 1 to 6 bytes in total, including the first. The size then determines the number of bytes denoting the value - anywhere from 0 to 17,179,869,183 bytes long."),(0,i.kt)("p",null,"The following table shows the bits used to indicate the number of size bytes."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Size Bytes"),(0,i.kt)("th",{parentName:"tr",align:null},"Max Length"),(0,i.kt)("th",{parentName:"tr",align:null},"Byte 1"),(0,i.kt)("th",{parentName:"tr",align:null},"Byte 2"),(0,i.kt)("th",{parentName:"tr",align:null},"Byte 3"),(0,i.kt)("th",{parentName:"tr",align:null},"Byte 4"),(0,i.kt)("th",{parentName:"tr",align:null},"Byte 5"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"0x3F"),(0,i.kt)("td",{parentName:"tr",align:null},"1 ..."),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"0x1FFF"),(0,i.kt)("td",{parentName:"tr",align:null},"11 ..."),(0,i.kt)("td",{parentName:"tr",align:null},"..."),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"3"),(0,i.kt)("td",{parentName:"tr",align:null},"0xFFFFF"),(0,i.kt)("td",{parentName:"tr",align:null},"111 ..."),(0,i.kt)("td",{parentName:"tr",align:null},"..."),(0,i.kt)("td",{parentName:"tr",align:null},"..."),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"4"),(0,i.kt)("td",{parentName:"tr",align:null},"0x7FFFFFF"),(0,i.kt)("td",{parentName:"tr",align:null},"1111 ..."),(0,i.kt)("td",{parentName:"tr",align:null},"..."),(0,i.kt)("td",{parentName:"tr",align:null},"..."),(0,i.kt)("td",{parentName:"tr",align:null},"..."),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"5"),(0,i.kt)("td",{parentName:"tr",align:null},"0x3FFFFFFFF"),(0,i.kt)("td",{parentName:"tr",align:null},"11111 ..."),(0,i.kt)("td",{parentName:"tr",align:null},"..."),(0,i.kt)("td",{parentName:"tr",align:null},"..."),(0,i.kt)("td",{parentName:"tr",align:null},"..."),(0,i.kt)("td",{parentName:"tr",align:null},"...")))),(0,i.kt)("p",null,"In other words, the number of bits set to 1 at the start of the first size byte indicate the total number of size bytes."),(0,i.kt)("h3",{id:"cons-pairs"},"Cons Pairs"),(0,i.kt)("p",null,"A cons pair is represented with the byte ",(0,i.kt)("inlineCode",{parentName:"p"},"0xFF"),". The two values that follow are the first and rest of the pair, respectively."),(0,i.kt)("h2",{id:"deserialization"},"Deserialization"),(0,i.kt)("p",null,"To deserialize a program, simply do the same steps in reverse."),(0,i.kt)("h3",{id:"nil-1"},"Nil"),(0,i.kt)("p",null,"If the first byte is ",(0,i.kt)("inlineCode",{parentName:"p"},"0x80"),", the value is nil."),(0,i.kt)("h3",{id:"small-atoms-1"},"Small Atoms"),(0,i.kt)("p",null,"If the first byte is 7 or fewer bits in length, the value is an atom equivalent to that byte."),(0,i.kt)("h3",{id:"large-atoms-1"},"Large Atoms"),(0,i.kt)("p",null,"If the first byte is more than 7 bits in length, you will need to do a bit of math to figure out the size and value of the atom."),(0,i.kt)("p",null,"Here is a table you can reference:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"First Byte Max"),(0,i.kt)("th",{parentName:"tr",align:null},"Skipped Bits"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"0xBF"),(0,i.kt)("td",{parentName:"tr",align:null},"2")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"0xDF"),(0,i.kt)("td",{parentName:"tr",align:null},"3")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"0xEF"),(0,i.kt)("td",{parentName:"tr",align:null},"4")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"0xF7"),(0,i.kt)("td",{parentName:"tr",align:null},"5")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"0xFB"),(0,i.kt)("td",{parentName:"tr",align:null},"6")))),(0,i.kt)("p",null,"The number of skipped bits is also the number of total bytes the size is encoded in. For example, the value ",(0,i.kt)("inlineCode",{parentName:"p"},"0xE3")," would have 4 skipped bits and 4 size bytes, because it is below ",(0,i.kt)("inlineCode",{parentName:"p"},"0xEF"),"."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The number of size bytes includes the first.")),(0,i.kt)("h3",{id:"cons-pairs-1"},"Cons Pairs"),(0,i.kt)("p",null,"A cons pair begins with the special value ",(0,i.kt)("inlineCode",{parentName:"p"},"0xFF"),". The first and rest values can be read individually after."),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"(1 . 2)")," would be represented as ",(0,i.kt)("inlineCode",{parentName:"p"},"0xFF0102"),". Once you read ",(0,i.kt)("inlineCode",{parentName:"p"},"0xFF"),", you know that the next value is the first of the cons pair, which is ",(0,i.kt)("inlineCode",{parentName:"p"},"0x01"),". Then, the rest of the cons pair is the final value, which in this case is ",(0,i.kt)("inlineCode",{parentName:"p"},"0x02"),"."),(0,i.kt)("p",null,"Lists are typically chains of cons pairs that end in a nil terminator."),(0,i.kt)("h2",{id:"programs-as-parameters"},"Programs as Parameters"),(0,i.kt)("p",null,"CLVM does not have operators for defining and calling functions. However, it does allow programs to be passed into the environment, as well as executing a value as a program with a new environment."),(0,i.kt)("p",null,"This behavior is how functions are implemented in the Chialisp compiler."),(0,i.kt)("p",null,"Here is a CLVM program that executes the program contained in the first environment value with its own environment, ",(0,i.kt)("inlineCode",{parentName:"p"},"(12)"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"brun '(a 2 (q . (12)))' '((* 2 (q . 2)))'\n")),(0,i.kt)("p",null,"This should output the following result:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"24\n")),(0,i.kt)("p",null,"Taking this further, we can make the program run a new program that only uses values from the original environment:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"brun '(a 2 1)' '((* 5 (q . 2)) 10)'\n")),(0,i.kt)("p",null,"This should output the following result:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"20\n")),(0,i.kt)("p",null,"We can use this technique to implement recursive functions."))}d.isMDXComponent=!0}}]);