"use strict";(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[13],{9273:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"primitives/cats","title":"CATs","description":"Chia Asset Tokens are fungible tokens that are issued on the Chia blockchain. The CAT puzzle ensures that the supply of a specific CAT never changes unless the rules of issuance specific to that CAT are followed. These are enforced using a separate Chialisp program called the Token and Asset Issuance Limitations (TAIL).","source":"@site/docs/primitives/cats.md","sourceDirName":"primitives","slug":"/cats","permalink":"/cats","draft":false,"unlisted":false,"editUrl":"https://github.com/Chia-Network/chialisp-web/blob/main/docs/primitives/cats.md","tags":[],"version":"current","frontMatter":{"title":"CATs","slug":"/cats"},"sidebar":"someSidebar","previous":{"title":"Singletons","permalink":"/singletons"},"next":{"title":"NFTs","permalink":"/nfts"}}');var s=t(4848),a=t(8453);const o={title:"CATs",slug:"/cats"},r=void 0,l={},c=[{value:"Code Examples",id:"code-examples",level:2},{value:"chia-blockchain",id:"chia-blockchain",level:3},{value:"chia-rs",id:"chia-rs",level:3},{value:"chia-wallet-lib",id:"chia-wallet-lib",level:3},{value:"CAT Code",id:"code",level:2},{value:"Single-Issuance TAIL",id:"single",level:3},{value:"Multi-Issuance TAIL",id:"multi",level:3},{value:"Usage",id:"usage",level:2},{value:"Design Decisions",id:"design-decisions",level:2},{value:"Created coins become CATs with the same TAIL",id:"wrapping",level:4},{value:"Unless TAIL is revealed, spends must net zero",id:"accounting",level:4},{value:"CATs must match their parent or use the TAIL",id:"lineage",level:4},{value:"CATs enforce prefixes for coin announcements",id:"prefixes",level:4},{value:"TAILs are given a list of pre-calculated truths",id:"truths",level:4},{value:"CATs have the option to use hinting",id:"hinting",level:4},{value:"Spend Accounting",id:"accounting",level:2},{value:"Extra Delta",id:"extra-delta",level:2},{value:"TAIL Program",id:"tail",level:2},{value:"Limitations of the TAIL",id:"tail-limitations",level:2},{value:"Valuation",id:"valuation",level:2},{value:"Reasons for Melting",id:"reasons-for-melting",level:2},{value:"Removal From Circulation",id:"removal-from-circulation",level:3},{value:"Value Exchange",id:"value-exchange",level:3},{value:"Ephemeral Tokens",id:"ephemeral-tokens",level:3},{value:"Truth Table",id:"truth-table",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Chia Asset Tokens are fungible tokens that are issued on the Chia blockchain. The CAT puzzle ensures that the supply of a specific CAT never changes unless the rules of issuance specific to that CAT are followed. These are enforced using a separate Chialisp program called the ",(0,s.jsx)(n.a,{href:"#tail",children:"Token and Asset Issuance Limitations (TAIL)"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Aside from the TAIL, there is also an ",(0,s.jsx)(n.a,{href:"/chialisp-inner-puzzles",children:"inner puzzle"})," that the CAT wraps around. The inner puzzle controls the ownership of the specific coin, and when the coin is spent, the new puzzle is wrapped in the CAT again. Typically, you wrap the ",(0,s.jsx)(n.a,{href:"/standard-transactions",children:"standard transaction"})," so that you can send CATs to Chia wallet addresses."]}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.p,{children:"The first version, known as CAT1, reached its end of life at block 2,311,760 on July 26th, 2022."}),(0,s.jsxs)(n.p,{children:["It has been replaced with the current CAT2 standard because of ",(0,s.jsx)(n.a,{href:"https://www.chia.net/2022/07/25/upgrading-the-cat-standard.en.html",children:"a vulnerability discovered during a security audit"}),"."]})]}),"\n",(0,s.jsxs)(n.p,{children:["To learn more about the terminology used on this page, check out the ",(0,s.jsx)(n.a,{href:"https://www.chia.net/2021/09/23/chia-token-standard-naming.en.html",children:"blog entry explaining CAT naming conventions"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Additionally, fungible tokens can be split apart and merged together, whereas non-fungible tokens are indivisible."}),"\n",(0,s.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,s.jsx)(n.h3,{id:"chia-blockchain",children:"chia-blockchain"}),"\n",(0,s.jsx)(n.p,{children:"The official Chia wallet has a reference implementation for the following in Python:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/010cedf83718aa8e4d97da76f892fe69387a5d82/chia/wallet/cat_wallet/cat_wallet.py#L784",children:"Spend CAT coins"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"chia-rs",children:"chia-rs"}),"\n",(0,s.jsx)(n.p,{children:"Wallet code can use the following reference methods:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/chia_rs/blob/wallet-dev/chia-primitives/src/primitives/cat.rs",children:"Puzzle and solution types"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/chia_rs/blob/2334c842f694444da317fa7432f308f159f62d70/chia-wallet/src/wallet.rs#L209",children:"Issue new CAT"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/chia_rs/blob/2334c842f694444da317fa7432f308f159f62d70/chia-wallet/src/wallet.rs#L545",children:"Spend CAT coins"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/chia_rs/blob/2334c842f694444da317fa7432f308f159f62d70/chia-wallet/src/wallet.rs#L399",children:"Send CATs to puzzle hash"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"chia-wallet-lib",children:"chia-wallet-lib"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/node-chia-wallet-lib",children:"Chia wallet library NPM package"})," has the following reference implementation:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/node-chia-wallet-lib/blob/6c8d564538be121079596e492fa0da497c9dd39c/src/types/puzzles/AssetToken.ts#L63",children:"Issue new CAT"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/node-chia-wallet-lib/blob/6c8d564538be121079596e492fa0da497c9dd39c/src/types/puzzles/AssetToken.ts#L102",children:"Spend CAT coins"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"code",children:"CAT Code"}),"\n",(0,s.jsxs)(n.p,{children:["This is the source code of the CAT, which can also be found in the chia-blockchain repository in the puzzle ",(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/fad414132e6950e79e805629427af76bf9ddcbc5/chia/wallet/puzzles/cat_v2.clvm",children:(0,s.jsx)(n.code,{children:"cat_v2.clvm"})}),":"]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Expand CAT2 puzzle"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-chialisp",metastring:'title="cat_v2.clvm"',children:"; Coins locked with this puzzle are spendable cats.\n;\n; Choose a list of n inputs (n>=1), I_1, ... I_n with amounts A_1, ... A_n.\n;\n; We put them in a ring, so \"previous\" and \"next\" have intuitive k-1 and k+1 semantics,\n; wrapping so {n} and 0 are the same, ie. all indices are mod n.\n;\n; Each coin creates 0 or more coins with total output value O_k.\n; Let D_k = the \"debt\" O_k - A_k contribution of coin I_k, ie. how much debt this input accumulates.\n; Some coins may spend more than they contribute and some may spend less, ie. D_k need\n; not be zero. That's okay. It's enough for the total of all D_k in the ring to be 0.\n;\n; A coin can calculate its own D_k since it can verify A_k (it's hashed into the coin id)\n; and it can sum up `CREATE_COIN` conditions for O_k.\n;\n; Defines a \"subtotal of debts\" S_k for each coin as follows:\n;\n; S_1 = 0\n; S_k = S_{k-1} + D_{k-1}\n;\n; Here's the main trick that shows the ring sums to 0.\n; You can prove by induction that S_{k+1} = D_1 + D_2 + ... + D_k.\n; But it's a ring, so S_{n+1} is also S_1, which is 0. So D_1 + D_2 + ... + D_k = 0.\n; So the total debts must be 0, ie. no coins are created or destroyed.\n;\n; Each coin's solution includes I_{k-1}, I_k, and I_{k+1} along with proofs that I_{k}, and I_{k+1} are CATs of the same type.\n; Each coin's solution includes S_{k-1}. It calculates D_k = O_k - A_k, and then S_k = S_{k-1} + D_{k-1}\n;\n; Announcements are used to ensure that each S_k follows the pattern is valid.\n; Announcements automatically commit to their own coin id.\n; Coin I_k creates an announcement that further commits to I_{k-1} and S_{k-1}.\n;\n; Coin I_k gets a proof that I_{k+1} is a cat, so it knows it must also create an announcement\n; when spent. It checks that I_{k+1} creates an announcement committing to I_k and S_k.\n;\n; So S_{k+1} is correct iff S_k is correct.\n;\n; Coins also receive proofs that their neighbours are CATs, ensuring the announcements aren't forgeries.\n; Inner puzzles and the CAT layer prepend `CREATE_COIN_ANNOUNCEMENT` with different prefixes to avoid forgeries.\n; Ring announcements use 0xcb, and inner puzzles are given 0xca\n;\n; In summary, I_k generates a coin_announcement Y_k (\"Y\" for \"yell\") as follows:\n;\n;  Y_k: hash of I_k (automatically), I_{k-1}, S_k\n;\n; Each coin creates an assert_coin_announcement to ensure that the next coin's announcement is as expected:\n;  Y_{k+1} : hash of I_{k+1}, I_k, S_{k+1}\n;\n; TLDR:\n;  I_k : coins\n;  A_k : amount coin k contributes\n;  O_k : amount coin k spend\n;  D_k : difference/delta that coin k incurs (A - O)\n;  S_k : subtotal of debts D_1 + D_2 ... + D_k\n;  Y_k : announcements created by coin k commiting to I_{k-1}, I_k, S_k\n;\n; All conditions go through a \"transformer\" that looks for CREATE_COIN conditions\n; generated by the inner solution, and wraps the puzzle hash ensuring the output is a cat.\n;\n; Three output conditions are prepended to the list of conditions for each I_k:\n;  (ASSERT_MY_ID I_k) to ensure that the passed in value for I_k is correct\n;  (CREATE_COIN_ANNOUNCEMENT I_{k-1} S_k) to create this coin's announcement\n;  (ASSERT_COIN_ANNOUNCEMENT hashed_announcement(Y_{k+1})) to ensure the next coin really is next and\n;     the relative values of S_k and S_{k+1} are correct\n;\n; This is all we need to do to ensure cats exactly balance in the inputs and outputs.\n;\n; Proof:\n;   Consider n, k, I_k values, O_k values, S_k and A_k as above.\n;   For the (CREATE_COIN_ANNOUNCEMENT Y_{k+1}) (created by the next coin)\n;   and (ASSERT_COIN_ANNOUNCEMENT hashed(Y_{k+1})) to match,\n;   we see that I_k can ensure that is has the correct value for S_{k+1}.\n;\n;   By induction, we see that S_{m+1} = sum(i, 1, m) [O_i - A_i] = sum(i, 1, m) O_i - sum(i, 1, m) A_i\n;   So S_{n+1} = sum(i, 1, n) O_i - sum(i, 1, n) A_i. But S_{n+1} is actually S_1 = 0,\n;   so thus sum(i, 1, n) O_i = sum (i, 1, n) A_i, ie. output total equals input total.\n\n;; GLOSSARY:\n;;  MOD_HASH: this code's sha256 tree hash\n;;  TAIL_PROGRAM_HASH: the program that determines if a coin can mint new cats, burn cats, and check if its lineage is valid if its parent is not a CAT\n;;  INNER_PUZZLE: an independent puzzle protecting the coins. Solutions to this puzzle are expected to generate `AGG_SIG` conditions and possibly `CREATE_COIN` conditions.\n;; ---- items above are curried into the puzzle hash ----\n;;  inner_puzzle_solution: the solution to the inner puzzle\n;;  prev_coin_id: the id for the previous coin\n;;  tail_program_reveal: reveal of TAIL_PROGRAM_HASH required to run the program if desired\n;;  tail_solution: optional solution passed into tail_program\n;;  lineage_proof: optional proof that our coin's parent is a CAT\n;;  this_coin_info: (parent_id puzzle_hash amount)\n;;  next_coin_proof: (parent_id inner_puzzle_hash amount)\n;;  prev_subtotal: the subtotal between prev-coin and this-coin\n;;  extra_delta: an amount that is added to our delta and checked by the TAIL program\n;;\n\n(mod (\n      MOD_HASH                 ;; curried into puzzle\n      TAIL_PROGRAM_HASH        ;; curried into puzzle\n      INNER_PUZZLE             ;; curried into puzzle\n      inner_puzzle_solution    ;; if invalid, INNER_PUZZLE will fail\n      lineage_proof            ;; This is the parent's coin info, used to check if the parent was a CAT. Optional if using tail_program.\n      prev_coin_id             ;; used in this coin's announcement, prev_coin ASSERT_COIN_ANNOUNCEMENT will fail if wrong\n      this_coin_info           ;; verified with ASSERT_MY_COIN_ID\n      next_coin_proof          ;; used to generate ASSERT_COIN_ANNOUNCEMENT\n      prev_subtotal            ;; included in announcement, prev_coin ASSERT_COIN_ANNOUNCEMENT will fail if wrong\n      extra_delta              ;; this is the \"legal discrepancy\" between your real delta and what you're announcing your delta is\n    )\n\n     ;;;;; start library code\n\n     (include condition_codes.clvm)\n     (include curry-and-treehash.clinc)\n     (include cat_truths.clib)\n     (include utility_macros.clib)\n\n     (defconstant RING_MORPH_BYTE 0xcb)\n\n\n    ; take two lists and merge them into one\n    (defun merge_list (list_a list_b)\n      (if list_a\n        (c (f list_a) (merge_list (r list_a) list_b))\n        list_b\n      )\n    )\n\n    ; cat_mod_struct = (MOD_HASH MOD_HASH_hash GENESIS_COIN_CHECKER GENESIS_COIN_CHECKER_hash)\n\n    (defun-inline mod_hash_from_cat_mod_struct (cat_mod_struct) (f cat_mod_struct))\n    (defun-inline mod_hash_hash_from_cat_mod_struct (cat_mod_struct) (f (r cat_mod_struct)))\n    (defun-inline tail_program_hash_from_cat_mod_struct (cat_mod_struct) (f (r (r cat_mod_struct))))\n\n     ;;;;; end library code\n\n     ;; return the puzzle hash for a cat with the given `GENESIS_COIN_CHECKER_hash` & `INNER_PUZZLE`\n     (defun-inline cat_puzzle_hash (cat_mod_struct inner_puzzle_hash)\n       (puzzle-hash-of-curried-function (mod_hash_from_cat_mod_struct cat_mod_struct)\n                                        inner_puzzle_hash\n                                        (sha256 ONE (tail_program_hash_from_cat_mod_struct cat_mod_struct))\n                                        (mod_hash_hash_from_cat_mod_struct cat_mod_struct)\n       )\n     )\n\n     ;; assert `CREATE_COIN_ANNOUNCEMENT` doesn't contain the RING_MORPH_BYTE bytes so it cannot be used to cheat the coin ring\n\n     (defun-inline morph_condition (condition cat_mod_struct)\n       (if (= (f condition) CREATE_COIN)\n         (c CREATE_COIN\n               (c (cat_puzzle_hash cat_mod_struct (f (r condition)))\n                    (r (r condition)))\n         )\n         (if (= (f condition) CREATE_COIN_ANNOUNCEMENT)\n           (assert (not (and\n                     (= 33 (strlen (f (r condition))))\n                     (= (substr (f (r condition)) 0 ONE) RING_MORPH_BYTE)  ; lazy eval\n                   ))\n             ; then\n             condition\n           )\n           condition\n         )\n       )\n     )\n\n     ;; given a coin's parent, inner_puzzle and amount, and the cat_mod_struct, calculate the id of the coin\n     (defun-inline coin_id_for_proof (coin cat_mod_struct)\n       (calculate_coin_id (f coin) (cat_puzzle_hash cat_mod_struct (f (r coin))) (f (r (r coin))))\n     )\n\n     ;; utility to fetch coin amount from coin\n     (defun-inline input_amount_for_coin (coin)\n       (f (r (r coin)))\n     )\n\n     ;; calculate the hash of an announcement\n     ;; we add 0xcb so ring announcements exist in a different namespace to announcements from inner_puzzles\n     (defun-inline calculate_annoucement_id (this_coin_id this_subtotal next_coin_id cat_mod_struct)\n       (sha256 next_coin_id RING_MORPH_BYTE (sha256tree (list this_coin_id this_subtotal)))\n     )\n\n     ;; create the `ASSERT_COIN_ANNOUNCEMENT` condition that ensures the next coin's announcement is correct\n     (defun-inline create_assert_next_announcement_condition (this_coin_id this_subtotal next_coin_id cat_mod_struct)\n       (list ASSERT_COIN_ANNOUNCEMENT\n             (calculate_annoucement_id this_coin_id\n                                            this_subtotal\n                                            next_coin_id\n                                            cat_mod_struct\n             )\n       )\n     )\n\n     ;; here we commit to I_{k-1} and S_k\n     ;; we add 0xcb so ring announcements exist in a different namespace to announcements from inner_puzzles\n     (defun-inline create_announcement_condition (prev_coin_id prev_subtotal)\n       (list CREATE_COIN_ANNOUNCEMENT\n             (concat RING_MORPH_BYTE (sha256tree (list prev_coin_id prev_subtotal)))\n       )\n      )\n\n     ;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n     ;; this function takes a condition and returns an integer indicating\n     ;; the value of all output coins created with CREATE_COIN. If it's not\n     ;; a CREATE_COIN condition, it returns 0.\n\n     (defun-inline output_value_for_condition (condition)\n       (if (= (f condition) CREATE_COIN)\n         (f (r (r condition)))\n         0\n       )\n     )\n\n     ;; add two conditions to the list of morphed conditions:\n     ;; CREATE_COIN_ANNOUNCEMENT for my announcement\n     ;; ASSERT_COIN_ANNOUNCEMENT for the next coin's announcement\n     (defun-inline generate_final_output_conditions\n       (\n         prev_subtotal\n         this_subtotal\n         morphed_conditions\n         prev_coin_id\n         this_coin_id\n         next_coin_id\n         cat_mod_struct\n       )\n         (c (create_announcement_condition prev_coin_id prev_subtotal)\n           (c (create_assert_next_announcement_condition this_coin_id this_subtotal next_coin_id cat_mod_struct)\n             morphed_conditions)\n         )\n      )\n\n\n      ;; This next section of code loops through all of the conditions to do three things:\n      ;;   1) Look for a \"magic\" value of -113 and, if one exists, filter it, and take note of the tail reveal and solution\n      ;;   2) Morph any CREATE_COIN or CREATE_COIN_ANNOUNCEMENT conditions\n      ;;   3) Sum the total output amount of all of the CREATE_COINs that are output by the inner puzzle\n      ;;\n      ;; After everything return a struct in the format (morphed_conditions . (output_sum . tail_reveal_and_solution))\n      ;; If multiple magic conditions are specified, the later one will take precedence\n\n      (defun-inline condition_tail_reveal (condition) (f (r (r (r condition)))))\n      (defun-inline condition_tail_solution (condition) (f (r (r (r (r condition))))))\n\n      (defun cons_onto_first_and_add_to_second (morphed_condition output_value struct)\n        (c (c morphed_condition (f struct)) (c (+ output_value (f (r struct))) (r (r struct))))\n      )\n\n      (defun find_and_strip_tail_info (inner_conditions cat_mod_struct tail_reveal_and_solution)\n        (if inner_conditions\n            (if (= (output_value_for_condition (f inner_conditions)) -113)  ; Checks this is a CREATE_COIN of value -113\n                (find_and_strip_tail_info\n                  (r inner_conditions)\n                  cat_mod_struct\n                  (c (condition_tail_reveal (f inner_conditions)) (condition_tail_solution (f inner_conditions)))\n                )\n                (cons_onto_first_and_add_to_second\n                  (morph_condition (f inner_conditions) cat_mod_struct)\n                  (output_value_for_condition (f inner_conditions))\n                  (find_and_strip_tail_info\n                    (r inner_conditions)\n                    cat_mod_struct\n                    tail_reveal_and_solution\n                  )\n                )\n            )\n            (c () (c 0 tail_reveal_and_solution))\n        )\n      )\n\n     ;;;;;;;;;;;;;;;;;;;;;;;;;;; lineage checking\n\n     ;; return true iff parent of `this_coin_info` is provably a cat\n     ;; A 'lineage proof' consists of (parent_parent_id parent_INNER_puzzle_hash parent_amount)\n     ;; We use this information to construct a coin who's puzzle has been wrapped in this MOD and verify that,\n     ;; once wrapped, it matches our parent coin's ID.\n     (defun-inline is_parent_cat (\n       cat_mod_struct\n       parent_id\n       lineage_proof\n     )\n       (= parent_id\n          (calculate_coin_id (f lineage_proof)\n                  (cat_puzzle_hash cat_mod_struct (f (r lineage_proof)))\n                  (f (r (r lineage_proof)))\n          )\n       )\n     )\n\n    (defun check_lineage_or_run_tail_program\n      (\n        this_coin_info\n        tail_reveal_and_solution\n        parent_is_cat  ; flag which says whether or not the parent CAT check ran and passed\n        lineage_proof\n        Truths\n        extra_delta\n        inner_conditions\n      )\n      (if tail_reveal_and_solution\n          (assert (= (sha256tree (f tail_reveal_and_solution)) (cat_tail_program_hash_truth Truths))\n            (merge_list\n              (a  (f tail_reveal_and_solution)\n                  (list\n                    Truths\n                    parent_is_cat\n                    lineage_proof ; Lineage proof is only guaranteed to be true if parent_is_cat\n                    extra_delta\n                    inner_conditions\n                    (r tail_reveal_and_solution)\n                  )\n              )\n              inner_conditions\n            )\n          )\n          (assert parent_is_cat (not extra_delta)\n            inner_conditions\n          )\n      )\n    )\n\n     ;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n     (defun stager_two (\n         Truths\n         (inner_conditions . (output_sum . tail_reveal_and_solution))\n         lineage_proof\n         prev_coin_id\n         this_coin_info\n         next_coin_id\n         prev_subtotal\n         extra_delta\n      )\n      (check_lineage_or_run_tail_program\n            this_coin_info\n            tail_reveal_and_solution\n            (if lineage_proof (is_parent_cat (cat_struct_truth Truths) (my_parent_cat_truth Truths) lineage_proof) ())\n            lineage_proof\n            Truths\n            extra_delta\n            (generate_final_output_conditions\n              prev_subtotal\n              ; the expression on the next line calculates `this_subtotal` by adding the delta to `prev_subtotal`\n              (+ prev_subtotal (- (input_amount_for_coin this_coin_info) output_sum) extra_delta)\n              inner_conditions\n              prev_coin_id\n              (my_id_cat_truth Truths)\n              next_coin_id\n              (cat_struct_truth Truths)\n            )\n        )\n    )\n\n    ; CAT TRUTHS struct is: ; CAT Truths is: ((Inner puzzle hash . (MOD hash . (MOD hash hash . TAIL hash))) . (my_id . (my_parent_info my_puzhash my_amount)))\n    ; create truths - this_coin_info verified true because we calculated my ID from it!\n    ; lineage proof is verified later by cat parent check or tail_program\n\n    (defun stager (\n        cat_mod_struct\n        inner_conditions\n        lineage_proof\n        inner_puzzle_hash\n        my_id\n        prev_coin_id\n        this_coin_info\n        next_coin_proof\n        prev_subtotal\n        extra_delta\n     )\n      (c (list ASSERT_MY_COIN_ID my_id) (stager_two\n        (cat_truth_data_to_truth_struct\n          inner_puzzle_hash\n          cat_mod_struct\n          my_id\n          this_coin_info\n        )\n        (find_and_strip_tail_info inner_conditions cat_mod_struct ())\n        lineage_proof\n        prev_coin_id\n        this_coin_info\n        (coin_id_for_proof next_coin_proof cat_mod_struct)\n        prev_subtotal\n        extra_delta\n      ))\n    )\n\n    (stager\n        ;; calculate cat_mod_struct, inner_puzzle_hash, coin_id\n        (list MOD_HASH (sha256 ONE MOD_HASH) TAIL_PROGRAM_HASH)\n        (a INNER_PUZZLE inner_puzzle_solution)\n        lineage_proof\n        (sha256tree INNER_PUZZLE)\n        (calculate_coin_id (f this_coin_info) (f (r this_coin_info)) (f (r (r this_coin_info))))\n        prev_coin_id    ; ID\n        this_coin_info  ; (parent_id puzzle_hash amount)\n        next_coin_proof ; (parent_id innerpuzhash amount)\n        prev_subtotal\n        extra_delta\n    )\n)\n"})})]}),"\n",(0,s.jsx)(n.p,{children:"Additionally, there are a few standard TAIL puzzles."}),"\n",(0,s.jsx)(n.h3,{id:"single",children:"Single-Issuance TAIL"}),"\n",(0,s.jsx)(n.p,{children:"The single-issuance TAIL prevents melting and requires the parent to be a specific coin. This is currently the default way to issue CATs, since it ensures the supply will never increase."}),"\n",(0,s.jsxs)(n.p,{children:["This is the source code, which can also be found in the chia-blockchain repository in the puzzle ",(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/fad414132e6950e79e805629427af76bf9ddcbc5/chia/wallet/puzzles/genesis_by_coin_id.clvm",children:(0,s.jsx)(n.code,{children:"genesis_by_coin_id.clvm"})}),":"]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Expand Genesis By Coin ID puzzle"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-chialisp",metastring:'title="genesis_by_coin_id.clvm"',children:"; This is a TAIL for use with cat.clvm.\n;\n; This checker allows new CATs to be created if they have a particular coin id as parent\n;\n; The genesis_id is curried in, making this lineage_check program unique and giving the CAT it's uniqueness\n(mod (\n      GENESIS_ID\n      Truths\n      parent_is_cat\n      lineage_proof\n      delta\n      inner_conditions\n      _\n    )\n\n    (include cat_truths.clib)\n\n    (if delta\n        (x)\n        (if (= (my_parent_cat_truth Truths) GENESIS_ID)\n          ()\n          (x)\n        )\n    )\n\n)\n"})})]}),"\n",(0,s.jsx)(n.h3,{id:"multi",children:"Multi-Issuance TAIL"}),"\n",(0,s.jsx)(n.p,{children:"The multi-issuance TAIL allows any action to be taken, providing the original issuance key is used. Each spend that makes supply changes must be signed separately using this same key."}),"\n",(0,s.jsxs)(n.p,{children:["This is the source code, which can also be found in the chia-blockchain repository in the puzzle ",(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/fad414132e6950e79e805629427af76bf9ddcbc5/chia/wallet/puzzles/everything_with_signature.clvm",children:(0,s.jsx)(n.code,{children:"everything_with_signature.clvm"})}),":"]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Expand Everything With Signature puzzle"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-chialisp",metastring:'title="everything_with_signature.clvm"',children:'; This is a "limitations_program" for use with cat.clvm.\n(mod (\n      PUBKEY\n      Truths\n      parent_is_cat\n      lineage_proof\n      delta\n      inner_conditions\n      _\n    )\n\n    (include condition_codes.clvm)\n\n    (list (list AGG_SIG_ME PUBKEY delta)) ; Careful with a delta of zero, the bytecode is 80 not 00\n)\n'})})]}),"\n",(0,s.jsx)(n.p,{children:"This TAIL provides a balance between security and flexibility. It's similar to the previous TAIL, but the signature can be reused for the puzzle it's signed with, allowing the TAIL to change over time. The creator can publish the signature, allowing any owner to run the TAIL on their CAT, but any permissions granted can never be revoked."}),"\n",(0,s.jsxs)(n.p,{children:["This is the source code, which can also be found in the chia-blockchain repository in the puzzle ",(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/fad414132e6950e79e805629427af76bf9ddcbc5/chia/wallet/puzzles/delegated_tail.clvm",children:(0,s.jsx)(n.code,{children:"delegated_tail.clvm"})}),":"]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Expand Delegated TAIL puzzle"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-chialisp",metastring:'title="delegated_tail.clvm"',children:'; This is a "limitations_program" for use with cat.clvm.\n(mod (\n      PUBKEY\n      Truths\n      parent_is_cat\n      lineage_proof\n      delta\n      inner_conditions\n      (\n        delegated_puzzle\n        delegated_solution\n      )\n    )\n\n    (include condition_codes.clvm)\n\n    (defun sha256tree1 (TREE)\n          (if (l TREE)\n              (sha256 2 (sha256tree1 (f TREE)) (sha256tree1 (r TREE)))\n              (sha256 1 TREE)))\n\n    (c (list AGG_SIG_UNSAFE PUBKEY (sha256tree1 delegated_puzzle))\n      (a delegated_puzzle (c Truths (c parent_is_cat (c lineage_proof (c delta (c inner_conditions delegated_solution))))))\n    )\n)\n'})})]}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(n.p,{children:"CATs are designed in a way that makes them unusable as regular XCH in spends. However, it is usually possible to melt them back into XCH later. Tokens are often used as a form of credits, such as casino chips or store credit."}),"\n",(0,s.jsx)(n.p,{children:"TAILs can be used to accommodate issuance requirements, such as:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Usage"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Stablecoins"}),(0,s.jsx)(n.td,{children:"Creator can issue new tokens which are backed by attested funds."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Limited Supply"}),(0,s.jsx)(n.td,{children:"Creator can run a one-time issuance, and no more can ever be issued."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Asset Redemption"}),(0,s.jsx)(n.td,{children:"Creator can allow owners to melt into XCH by following specific rules."})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"In all of these cases, the TAIL program is run when a coin is spent to check if the issuance is valid."}),"\n",(0,s.jsx)(n.h2,{id:"design-decisions",children:"Design Decisions"}),"\n",(0,s.jsx)(n.h4,{id:"wrapping",children:"Created coins become CATs with the same TAIL"}),"\n",(0,s.jsxs)(n.p,{children:["When the inner puzzle returns a ",(0,s.jsx)(n.code,{children:"CREATE_COIN"})," condition, it will wrap its puzzle hash with the CAT and curry in the same TAIL as before. This prevents the CAT from being implicitly melted and the value used for other things when spending it."]}),"\n",(0,s.jsx)(n.h4,{id:"accounting",children:"Unless TAIL is revealed, spends must net zero"}),"\n",(0,s.jsx)(n.p,{children:"In order to prevent issuing new CATs or melting existing CATs without the TAIL permitting it, any spend that doesn't reveal the TAIL program must output the same amount as the input coins."}),"\n",(0,s.jsx)(n.h4,{id:"lineage",children:"CATs must match their parent or use the TAIL"}),"\n",(0,s.jsxs)(n.p,{children:["Another way to prevent CATs from being issued without permission, is that they validate their lineage by asserting the parent is a CAT of the same TAIL. This is done by using the ",(0,s.jsx)(n.code,{children:"ASSERT_MY_ID"})," condition to verify the information passed in the spend."]}),"\n",(0,s.jsx)(n.h4,{id:"prefixes",children:"CATs enforce prefixes for coin announcements"}),"\n",(0,s.jsxs)(n.p,{children:["In order to ensure that the CATs can communicate with each other without interference from an inner puzzle, they must prepend a ",(0,s.jsx)(n.code,{children:"0xcb"})," prefix to coin announcements that are created within the CAT layer."]}),"\n",(0,s.jsx)(n.h4,{id:"truths",children:"TAILs are given a list of pre-calculated truths"}),"\n",(0,s.jsxs)(n.p,{children:["Many TAILs require information that has already been calculated in the CAT layer, so it is bundled together as a pre-validated collection of ",(0,s.jsx)(n.code,{children:"Truths"}),". These truths are then passed into the TAIL as the first non-curried parameter in the solution. For more info, see ",(0,s.jsx)(n.a,{href:"#truth-table",children:"the Truth Table"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"hinting",children:"CATs have the option to use hinting"}),"\n",(0,s.jsxs)(n.p,{children:["Hinting is a way to signal the CAT's type to a Chia wallet. The hint is typically an inner puzzle hash. For more info, see our ",(0,s.jsx)(n.a,{href:"https://docs.chia.net/faq#q-what-is-hinting",children:"explanation of hinting in the FAQ"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"accounting",children:"Spend Accounting"}),"\n",(0,s.jsxs)(n.p,{children:["Each CAT coin has a truthful calculation of the difference between its amount and its output amount, called its ",(0,s.jsx)(n.strong,{children:"delta"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The CAT coins also are given the sum of every other coin's deltas, which must be zero. In order to enforce this zero-delta rule, each CAT coin is assigned a next and previous neighbor, which ultimately forms a ring."}),"\n",(0,s.jsx)(n.p,{children:"The coins use coin announcements to communicate with their neighbors. For this use case, the announcements must contain two pieces of information:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The ID of the coin that created this coin. This is already implicitly contained in the coin announcement."}),"\n",(0,s.jsx)(n.li,{children:"The intended recipient's Coin ID. The announcement's message must contain this information in order to prevent attacks where coins can receive messages that weren't intended for them."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"To form the ring, every coin outputs the following conditions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-chialisp",children:"(\n    (CREATE_COIN_ANNOUNCEMENT (concat previous_coin_ID sum_of_deltas_before_me))\n    (ASSERT_COIN_ANNOUNCEMENT (sha256 next_coin_id my_coin_id sum_of_deltas_including_me))\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"The announcement assertions take the hash of the announcement creator's ID and message."}),"\n",(0,s.jsxs)(n.p,{children:["In order to create ",(0,s.jsx)(n.code,{children:"next_coin_id"}),", the next coin's inner puzzle is wrapped with the current coin's CAT information. This guarantees that ",(0,s.jsx)(n.code,{children:"next_coin_id"})," is a CAT of the same type as the current coin."]}),"\n",(0,s.jsx)(n.p,{children:"Because both coins follow the same CAT mod puzzle, they must comply with the same set of truths. This, in turn, guarantees that the whole ring is telling the truth. As long as the ring is connected, the total delta must be zero."}),"\n",(0,s.jsx)(n.h2,{id:"extra-delta",children:"Extra Delta"}),"\n",(0,s.jsx)(n.p,{children:"There are two exceptions to the aforementioned zero-delta rule:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Issuing coins (creating CATs from XCH)"}),"\n",(0,s.jsx)(n.li,{children:"Melting coins (turning CATs back into XCH)"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["To account for these cases, the TAIL program may approve a misreporting of a CAT coin's Delta by a specific amount, called the ",(0,s.jsx)(n.strong,{children:"extra delta"}),". This is one of the parameters passed to the TAIL program."]}),"\n",(0,s.jsx)(n.p,{children:"There are a few rules to ensure that extra coins are not issued or melted:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If the extra delta is anything other than ",(0,s.jsx)(n.code,{children:"0"}),", the TAIL program is forced to run. It must evaluate whether to permit the extra delta, or fail with an ",(0,s.jsx)(n.code,{children:"(x)"})," call."]}),"\n",(0,s.jsx)(n.li,{children:"If the extra delta value in the solution does not cause the TAIL program to fail, then it is automatically added to the reported delta, which is used in the announcement ring."}),"\n",(0,s.jsxs)(n.li,{children:["If the TAIL program is not revealed and the extra delta is not ",(0,s.jsx)(n.code,{children:"0"}),", then the spend will fail."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"tail",children:"TAIL Program"}),"\n",(0,s.jsx)(n.p,{children:"The TAIL program is powerful and flexible. It has control over, and access to, many things. This gives a programmer a lot of control, but also a great deal of responsibility."}),"\n",(0,s.jsx)(n.admonition,{type:"danger",children:(0,s.jsx)(n.p,{children:"If the TAIL is programmed incorrectly, the tokens may be issued by attackers, rendering the asset worthless."})}),"\n",(0,s.jsx)(n.p,{children:"A TAIL should follow all of the conventional rules of security that any Chialisp program responsible for locking up money should follow."}),"\n",(0,s.jsx)(n.p,{children:"Several parameters must be passed to a TAIL's solution:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Truths"}),(0,s.jsxs)(n.td,{children:["These are bundled together, as explained in the ",(0,s.jsx)(n.a,{href:"#truths",children:"truths section"}),"."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"parent_is_cat"}),(0,s.jsx)(n.td,{children:"Whether the parent CAT has been validated as the same type."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"lineage_proof (optional)"}),(0,s.jsx)(n.td,{children:"Proof that the parent is a CAT of the same type as this CAT."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"delta"}),(0,s.jsxs)(n.td,{children:["The extra delta value, as explained ",(0,s.jsx)(n.a,{href:"#extra-delta",children:"here"}),"."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"inner_conditions"}),(0,s.jsx)(n.td,{children:"The conditions returned by the inner puzzle (see below)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"tail_solution (optional)"}),(0,s.jsx)(n.td,{children:"A list of opaque parameters passed to the TAIL."})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Although the TAIL is powerful, it is ",(0,s.jsx)(n.em,{children:"not necessarily"})," run every time the coin is spent. The TAIL is run if a magic condition is created in the inner puzzle. This magic condition is required to prevent people who can spend the TAIL from intercepting the spend and changing it against the spender's will. The magic condition that triggers the TAIL to be run must look like this:"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"(51 0 -113 <TAIL puzzle> <TAIL solution>)"}),", where:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"51"})," is the condition code for ",(0,s.jsx)(n.code,{children:"CREATE_COIN"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"0"})," can be replaced with anything, but this is the smallest possible value. Although the ",(0,s.jsx)(n.code,{children:"CREATE_COIN"})," condition usually has a puzzle hash, it is ignored here."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"-113"})," is the magic amount, which signals to the CAT layer that the TAIL must be run. A negative number was chosen because negative coins are usually invalid, but otherwise it is an arbitrary amount."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The TAIL should check diligently for and authorize or reject the following things:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Is the extra delta issuing or melting any coins?"}),"\n",(0,s.jsx)(n.li,{children:"Is this coin's parent not a CAT of the same type?"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"tail-limitations",children:"Limitations of the TAIL"}),"\n",(0,s.jsx)(n.p,{children:"In Ethereum, a token's issuer might have the ability to freeze or confiscate funds without the owner's permission. This is not possible in Chia."}),"\n",(0,s.jsx)(n.p,{children:"In Chia, an issuer creates a TAIL, which lives inside all CATs of the same type, including those that have already been distributed. However, the issuer does not have the power to spend coins they do not own. A TAIL can only run as the last step in a CAT's spend, and the owner of the CAT (not the issuer) is responsible for providing its solution. This means that only the owner can run the TAIL. Therefore, the CAT's owner is the only one with the ability to complete the spend."}),"\n",(0,s.jsx)(n.p,{children:"This decision adds some decentralization for users. It also adds some complexity. The importance of creating a well-constructed TAIL cannot be emphasized enough. Once a CAT has been distributed, it is no longer possible to change the TAIL across the entire token supply. The TAIL is locked into the same set of rules forever. To change the TAIL would be tantamount to replacing physical cash in circulation. An exchange for new tokens would have to be offered, and the old token eventually deprecated, even if some people still carry it."}),"\n",(0,s.jsx)(n.p,{children:"It also means that if the set of rules is compromised, people may be able to issue or melt CATs maliciously. There\u2019s no easy way to patch the TAIL, other than through the process above, and therefore it is best avoided."}),"\n",(0,s.jsx)(n.h2,{id:"valuation",children:"Valuation"}),"\n",(0,s.jsx)(n.p,{children:"Some decisions regarding the granularity and denomination of CATs versus XCH:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Most Chia wallets choose to display their value in XCH. However, this is a purely cosmetic choice because Chia's blockchain only knows about mojos. One XCH is equal to one trillion (1,000,000,000,000) mojos."}),"\n",(0,s.jsx)(n.li,{children:"In a similar vein, Chia Network has made the design decision to map 1 CAT to 1,000 XCH mojos. This ratio will be the same for all CATs."}),"\n",(0,s.jsxs)(n.li,{children:["Theoretically, it would be possible to set the CAT",":mojo"," ratio to something other than 1:1000 for a specific CAT, but we strongly recommend against doing this. The official Chia wallet will not support CATs with a ratio other than 1:1000. Additionally, if you created your own wallet with support for different ratios, users of this wallet would almost certainly be confused and accidentally spend too much or too little money, by multiple orders of magnitude. Please don't attempt this."]}),"\n",(0,s.jsx)(n.li,{children:"The melt value of a single token is 1,000 mojos. This remains true regardless of the token's face value or its circulating supply."}),"\n",(0,s.jsx)(n.li,{children:"A token's face value is based on supply and demand, rather than being matched to the melt value."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By analogy, on multiple occasions the US Treasury has floated the idea of issuing a $1 trillion coin made from platinum. Leaving aside the practical implications of doing this, the magnitude of the difference between this hypothetical coin's face value and melt value would be similar to that of CATs and XCH. The coin would be worth $1 trillion dollars, but if someone melted it and sold the platinum, they'd only receive a minuscule fraction of that amount."}),"\n",(0,s.jsx)(n.p,{children:"On the other end of the spectrum, consider the US penny. Its base metals (97.5% zinc and 2.5% copper) are worth around two cents. So in theory, if you could melt a penny into zinc and copper while minimizing your costs, you could sell these metals for a sizable profit."}),"\n",(0,s.jsx)(n.h2,{id:"reasons-for-melting",children:"Reasons for Melting"}),"\n",(0,s.jsxs)(n.p,{children:["It's important to keep in mind that a CAT's TAIL (and nothing else) decides the rules for melting, ",(0,s.jsx)(n.em,{children:"if"})," it allows melting at all. For example, our ",(0,s.jsx)(n.a,{href:"#single",children:"single-issuance TAIL"})," only works with a specific coin, so it does not allow melting. CATs that use this TAIL can never be melted, no matter how small their face value."]}),"\n",(0,s.jsx)(n.p,{children:"Our delegated TAIL leaves it entirely up to the CAT's creator how and when melting can happen. There are many possible reasons you may want to melt a CAT, other than the obvious example of its face value being less than the melt value."}),"\n",(0,s.jsx)(n.p,{children:"Beyond our pre-packaged examples, TAILs with a wide range of functionality are also possible. To illustrate some of this functionality, let's consider three potential reasons for melting, along with who is permitted to melt the tokens."}),"\n",(0,s.jsx)(n.h3,{id:"removal-from-circulation",children:"Removal From Circulation"}),"\n",(0,s.jsx)(n.p,{children:"For certain categories of CATs, such as stablecoins and redemption tokens, melting will be allowed only by the creator, and only if they own the tokens. In the case of a stablecoin, the creator may need to remove some tokens from circulation if backing funds are reduced. For redemption tokens, the owner may exchange a token with the creator for something of value. The token no longer has any face value, so its creator will remove it from circulation."}),"\n",(0,s.jsx)(n.h3,{id:"value-exchange",children:"Value Exchange"}),"\n",(0,s.jsx)(n.p,{children:"Some CATs might allow their owners to melt tokens in order to gain something else of value, for example NFTs or other CATs. In fact, an entire marketplace could emerge from this concept."}),"\n",(0,s.jsx)(n.p,{children:"Here are some possible examples of this:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The creator of a set of NFTs also creates a small issuance of golden tickets that can be used to pick out any individual NFT before the set is made publicly available."}),"\n",(0,s.jsx)(n.li,{children:"A celebrity issues some tokens that can be exchanged for something of non-monetary value, such as a meeting with said celebrity."}),"\n",(0,s.jsx)(n.li,{children:"The holder of a CAT must submit a proof of melt in order to enter a contest."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"ephemeral-tokens",children:"Ephemeral Tokens"}),"\n",(0,s.jsxs)(n.p,{children:["A CAT could be created as a limited-time offer or as a game of musical chairs. In these cases, tokens would be melted ",(0,s.jsx)(n.em,{children:"against the owner's will"}),". This could be done either at random or as a deliberate type of slashing."]}),"\n",(0,s.jsx)(n.h2,{id:"truth-table",children:"Truth Table"}),"\n",(0,s.jsxs)(n.p,{children:["The following is a list of ",(0,s.jsx)(n.a,{href:"#truths",children:"truths"})," that are passed into the ",(0,s.jsx)(n.a,{href:"#tail",children:"TAIL"}),":"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Truth"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"My ID"}),(0,s.jsx)(n.td,{children:"The ID of the coin."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"My Parent's ID"}),(0,s.jsx)(n.td,{children:"The ID of the coin's parent."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"My Full Puzzle Hash"}),(0,s.jsx)(n.td,{children:"The puzzle hash contained inside the coin."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"My Amount"}),(0,s.jsx)(n.td,{children:"The amount of the coin in mojos."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"My Inner Puzzle Hash"}),(0,s.jsx)(n.td,{children:"The puzzle hash of the inner puzzle inside the CAT layer."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"My Lineage Proof (optional)"}),(0,s.jsx)(n.td,{children:"Proof that the CAT's parent has the same TAIL."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"My TAIL Solution (optional)"}),(0,s.jsx)(n.td,{children:"A list of parameters passed into the TAIL program."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"My Coin Info"}),(0,s.jsx)(n.td,{children:"The parent, puzzle hash, and amount."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CAT Mod Hash"}),(0,s.jsx)(n.td,{children:"The hash of the CAT before anything is curried."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CAT Mod Hash Hash"}),(0,s.jsx)(n.td,{children:"The hash of the CAT mod hash."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CAT TAIL Program Hash"}),(0,s.jsx)(n.td,{children:"The hash of the TAIL program that was curried into the CAT."})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"CATs are a great way to create tokens that represent divisible assets or currencies on top of the Chia blockchain. They can be used to represent stablecoins, tickets, store credit, and many other things."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(6540);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);