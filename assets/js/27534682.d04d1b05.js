"use strict";(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[802],{5470:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"attacks-and-countermeasures","title":"Attacks and Countermeasures","description":"Replay Attacks","source":"@site/docs/attacks-and-countermeasures.md","sourceDirName":".","slug":"/attacks-and-countermeasures","permalink":"/attacks-and-countermeasures","draft":false,"unlisted":false,"editUrl":"https://github.com/Chia-Network/chialisp-web/blob/main/docs/attacks-and-countermeasures.md","tags":[],"version":"current","frontMatter":{"id":"attacks-and-countermeasures","title":"Attacks and Countermeasures","slug":"/attacks-and-countermeasures"},"sidebar":"someSidebar","previous":{"title":"Common Issues","permalink":"/common_issues"},"next":{"title":"Debugging","permalink":"/debugging"}}');var i=t(4848),a=t(8453);const o={id:"attacks-and-countermeasures",title:"Attacks and Countermeasures",slug:"/attacks-and-countermeasures"},r=void 0,c={},d=[{value:"Replay Attacks",id:"replay-attacks",level:2},{value:"Vault Spends",id:"vault-spends",level:3},{value:"Fast Forward",id:"fast-forward",level:2},{value:"Edge Case",id:"edge-case",level:2},{value:"The Attack Scenario",id:"the-attack-scenario",level:3},{value:"Prevention Methods",id:"prevention-methods",level:3}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"replay-attacks",children:"Replay Attacks"}),"\n",(0,i.jsxs)(n.p,{children:["Fundamentally, the concern with a replay attack on a Chia transaction is that you could use the same signature as a previous coin spend to spend a new coin that it wasn't intended for. For example, if the ",(0,i.jsx)(n.a,{href:"/standard-transactions",children:"standard transaction"})," were to use ",(0,i.jsx)(n.a,{href:"/conditions#agg-sig-puzzle",children:(0,i.jsx)(n.code,{children:"AGG_SIG_PUZZLE"})})," instead of ",(0,i.jsx)(n.a,{href:"/conditions#agg-sig-me",children:(0,i.jsx)(n.code,{children:"AGG_SIG_ME"})}),", you would be able to use a signature to spend multiple coins with the same puzzle hash."]}),"\n",(0,i.jsxs)(n.p,{children:["However, what a replay attack doesn't allow you to do is change the delegated puzzle. The signature is verified against a message (the tree hash of the delegated puzzle) concatenated with the coin info (i.e. a coin id or puzzle hash) and often the genesis challenge. So, if you used ",(0,i.jsx)(n.a,{href:"/conditions#agg-sig-puzzle",children:(0,i.jsx)(n.code,{children:"AGG_SIG_PUZZLE"})}),", you'd be able to spend multiple coins with the same puzzle hash, but they would all have to output the same conditions."]}),"\n",(0,i.jsxs)(n.p,{children:["If the conditions of a spend aren't met, it will be rejected by consensus. This means that you could use other means to prevent replay attacks than simply requiring a specific coin id. For example, if you were to have an ",(0,i.jsx)(n.a,{href:"/conditions#agg-sig-puzzle",children:(0,i.jsx)(n.code,{children:"AGG_SIG_PUZZLE"})})," but the conditions included a ",(0,i.jsx)(n.a,{href:"/conditions#66-send_message",children:(0,i.jsx)(n.code,{children:"SEND_MESSAGE"})})," being sent to a specific coin id, that other coin would have to be spent for this message to be received. And since messages are 1:1, there's no way to spend multiple coins with this signature even if they were included in the same block."]}),"\n",(0,i.jsx)(n.h3,{id:"vault-spends",children:"Vault Spends"}),"\n",(0,i.jsx)(n.p,{children:"When you spend a vault, you're typically doing one of two things:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Changing the custody configuration"})," (i.e. modifying the custody signers or recovery signers)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:'Spending coins that are "owned by" the vault'})," (p2 coins)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"When you change the custody configuration, the puzzle hash of the vault inherently changes. This means that the signature that was used to perform the rekey is no longer valid to spend the coin, since it committed to a specific puzzle hash."}),"\n",(0,i.jsxs)(n.p,{children:["When you spend other p2 coins (including fee coins or other XCH, ",(0,i.jsx)(n.a,{href:"/cats",children:"CATs"}),", ",(0,i.jsx)(n.a,{href:"/nfts",children:"NFTs"}),", etc) that are owned by the vault, the vault's delegated puzzle will include a ",(0,i.jsx)(n.a,{href:"/conditions#66-send_message",children:(0,i.jsx)(n.code,{children:"SEND_MESSAGE"})})," condition send to each coin id. Similarly to the ",(0,i.jsx)(n.a,{href:"/conditions#agg-sig-puzzle",children:(0,i.jsx)(n.code,{children:"AGG_SIG_PUZZLE"})})," example, this message's presence prevents it from being replayed since the message will only be valid for a single spend."]}),"\n",(0,i.jsx)(n.h2,{id:"fast-forward",children:"Fast Forward"}),"\n",(0,i.jsxs)(n.p,{children:["The reason to use ",(0,i.jsx)(n.a,{href:"/conditions#agg-sig-puzzle",children:(0,i.jsx)(n.code,{children:"AGG_SIG_PUZZLE"})})," or ",(0,i.jsx)(n.a,{href:"/conditions#assert-my-puzzlehash",children:(0,i.jsx)(n.code,{children:"ASSERT_MY_PUZZLE_HASH"})})," instead of ",(0,i.jsx)(n.a,{href:"/conditions#agg-sig-me",children:(0,i.jsx)(n.code,{children:"AGG_SIG_ME"})})," or ",(0,i.jsx)(n.a,{href:"/conditions#assert-my-coin-id",children:(0,i.jsx)(n.code,{children:"ASSERT_MY_COIN_ID"})})," in a vault spend is that you don't want to restrict a spend to a specific coin id."]}),"\n",(0,i.jsx)(n.p,{children:"The most common scenarios are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You have a transaction pending in the mempool already but want to make another"}),"\n",(0,i.jsxs)(n.li,{children:["You want to create multiple ",(0,i.jsx)(n.a,{href:"/offers",children:"offer files"})," that spend the vault to spend different p2 coins"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["There's a feature called ",(0,i.jsx)(n.strong,{children:"singleton fast forward"})," (used by ",(0,i.jsx)(n.a,{href:"/singletons",children:"singletons"}),'), which allows the mempool to "rebase" transactions on top of each other if they spend the same coin. This is only possible if certain conditions are met, such as not relying on the coin id, not changing the puzzle hash or amount, etc.']}),"\n",(0,i.jsx)(n.p,{children:"So the idea is that you can assert the puzzle hash, but not the coin id, and instead use messages to specific coins to prevent replay attacks. This way multiple concurrent transactions can co-exist, including outstanding offer files, and they won't conflict in the mempool."}),"\n",(0,i.jsx)(n.h2,{id:"edge-case",children:"Edge Case"}),"\n",(0,i.jsx)(n.p,{children:"Almost all vault transactions, including rekeys and p2 coin spends, are safe from replay attacks. However, there is one rare scenario where a replay attack is possible and steps in the wallet must be taken to prevent this from happening. Note that this type of transaction (rekeying without recovery) is not currently possible in Cloud Wallet, so this attack is not possible at this time, and can be mitigated properly when it is supported later."}),"\n",(0,i.jsx)(n.h3,{id:"the-attack-scenario",children:"The Attack Scenario"}),"\n",(0,i.jsx)(n.p,{children:"If you start with custody config A, and complete a rekey to custody config B, you've changed the vault's puzzle hash. As described previously, the vault can't be spent using the old signature since the puzzle hash won't match. Additionally, if you included a fee spend, the message would also prevent this from happening."}),"\n",(0,i.jsx)(n.p,{children:"However, if the vault is ever rekeyed back into custody config A (i.e. it now has the old puzzle hash again), and there was no p2 coin spend to pay for fees in the original transaction (thus no message was sent), then it's possible for an attacker to spend the vault using the old signature. This would give any unauthorized third party the ability to re-perform the same rekey into custody config B."}),"\n",(0,i.jsx)(n.h3,{id:"prevention-methods",children:"Prevention Methods"}),"\n",(0,i.jsx)(n.p,{children:"The way to prevent this is to either:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Require a p2 coin spend when performing a rekey"})," - This ensures a message is sent, preventing replay"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Increment the nonce when you go back to an old custody config"})," - This prevents the puzzle hash from reverting to its original state"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Include other invalidating conditions"})," - Such as ",(0,i.jsx)(n.a,{href:"/conditions#assert-before-seconds-absolute",children:(0,i.jsx)(n.code,{children:"ASSERT_BEFORE_SECONDS_ABSOLUTE"})}),' (which would make the signature "expire" after some time has passed)']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Include an ",(0,i.jsx)(n.a,{href:"/conditions#assert-my-coin-id",children:(0,i.jsx)(n.code,{children:"ASSERT_MY_COIN_ID"})})," condition"]})," - Using the current coin id, since rekeys aren't fast forwardable anyways (nor should they be)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Perhaps the cleanest approach is to simply include an ",(0,i.jsx)(n.a,{href:"/conditions#assert-my-coin-id",children:(0,i.jsx)(n.code,{children:"ASSERT_MY_COIN_ID"})})," condition using the current coin id, since rekeys aren't fast forwardable anyways (nor should they be)."]})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(6540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);