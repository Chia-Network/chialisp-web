"use strict";(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[592],{4312:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var t=i(4848),r=i(8453);const a={title:"DIDs",slug:"/dids"},o=void 0,s={id:"primitives/dids",title:"DIDs",description:"DIDs are a decentralized way to represent an identity, be that an organization or a person. It is possible to recover a DID even if the key is lost, by having multiple parties send messages approving the inner puzzle change.",source:"@site/docs/primitives/dids.md",sourceDirName:"primitives",slug:"/dids",permalink:"/dids",draft:!1,unlisted:!1,editUrl:"https://github.com/Chia-Network/chialisp-web/blob/main/docs/primitives/dids.md",tags:[],version:"current",frontMatter:{title:"DIDs",slug:"/dids"},sidebar:"someSidebar",previous:{title:"NFTs",permalink:"/nfts"},next:{title:"Offers",permalink:"/offers"}},c={},d=[{value:"Code Examples",id:"code-examples",level:2},{value:"chia-blockchain",id:"chia-blockchain",level:3},{value:"chia-rs",id:"chia-rs",level:3},{value:"DID Code",id:"code",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"DIDs are a decentralized way to represent an identity, be that an organization or a person. It is possible to recover a DID even if the key is lost, by having multiple parties send messages approving the inner puzzle change."}),"\n",(0,t.jsx)(n.p,{children:"More functionality will be added to the DID standard in the future, allowing for easier identification and recovery methods."}),"\n",(0,t.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,t.jsx)(n.h3,{id:"chia-blockchain",children:"chia-blockchain"}),"\n",(0,t.jsx)(n.p,{children:"The official Chia wallet has a reference implementation for the following in Python:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/010cedf83718aa8e4d97da76f892fe69387a5d82/chia/wallet/did_wallet/did_wallet.py#L1217",children:"Mint new DID"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/010cedf83718aa8e4d97da76f892fe69387a5d82/chia/wallet/did_wallet/did_wallet.py#L534",children:"Create update DID spend"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"chia-rs",children:"chia-rs"}),"\n",(0,t.jsx)(n.p,{children:"Wallet code can use the following reference methods:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/Chia-Network/chia_rs/blob/wallet-dev/chia-primitives/src/primitives/did.rs",children:"Puzzle and solution types"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/Chia-Network/chia_rs/blob/2334c842f694444da317fa7432f308f159f62d70/chia-wallet/src/wallet.rs#L1148",children:"Spend DID"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"code",children:"DID Code"}),"\n",(0,t.jsxs)(n.p,{children:["This is the source code of the DID inner puzzle, which can also be found in the chia-blockchain repository in the puzzle ",(0,t.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/164fd158c8626893bc45ba00b87ae69d2ab5f8b7/chia/wallet/puzzles/did_innerpuz.clvm",children:(0,t.jsx)(n.code,{children:"did_innerpuz.clvm"})}),"."]}),"\n",(0,t.jsxs)(i,{children:[(0,t.jsx)("summary",{children:"Expand DID Inner Puzzle"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",metastring:'title="did_innerpuz.clvm"',children:"; The DID innerpuzzle is designed to sit inside the singleton layer and provide functionality related to being an identity.\n; At the moment the two pieces of functionality are recovery and message creation.\n; A DID's ID is it's Singleton ID\n; Recovery is based around having a list of known other DIDs which can send messages approving you change the innerpuzzle of your DID singleton\n\n(mod\n  (\n  INNER_PUZZLE  ; Standard P2 inner puzzle, used to record the ownership of the DID.\n  RECOVERY_DID_LIST_HASH  ; the list of DIDs that can send messages to you for recovery we store only the hash so that we don't have to reveal every time we make a message spend\n  NUM_VERIFICATIONS_REQUIRED  ; how many of the above list are required for a recovery\n  SINGLETON_STRUCT  ; my singleton_struct, formerly a Truth - ((SINGLETON_MOD_HASH, (LAUNCHER_ID, LAUNCHER_PUZZLE_HASH)))\n  METADATA ; Customized metadata, e.g KYC info\n  mode  ; this indicates which spend mode we want. 0. Recovery mode 1. Run INNER_PUZZLE with p2_solution\n  my_amount_or_inner_solution  ; In mode 0, we use this to recover our coin and assert it is our actual amount\n                             ; In mode 1 this is the solution of the inner P2 puzzle, only required in the create message mode and transfer mode.\n  new_inner_puzhash  ; In recovery mode, this will be the new wallet DID puzzle hash\n  parent_innerpuzhash_amounts_for_recovery_ids  ; during a recovery we need extra information about our recovery list coins\n  pubkey  ; this is the new pubkey used for a recovery\n  recovery_list_reveal  ; this is the reveal of the stored list of DIDs approved for recovery\n  my_id  ; my coin ID\n  )\n  ;message is the new puzzle in the recovery and standard spend cases\n\n  ;MOD_HASH, MY_PUBKEY, RECOVERY_DID_LIST_HASH are curried into the puzzle\n  ;EXAMPLE SOLUTION (0xcafef00d 0x12341234 0x923bf9a7856b19d335a65f12d68957d497e1f0c16c0e14baf6d120e60753a1ce 2 1 100 (q \"source code\") 0xdeadbeef 0xcafef00d ((0xdadadada 0xdad5dad5 200) () (0xfafafafa 0xfaf5faf5 200)) 0xfadeddab (0x22222222 0x33333333 0x44444444))\n\n  (include condition_codes.clvm)\n  (include curry-and-treehash.clinc)\n\n  ; takes a lisp tree and returns the hash of it\n  (defun sha256tree1 (TREE)\n      (if (l TREE)\n          (sha256 2 (sha256tree1 (f TREE)) (sha256tree1 (r TREE)))\n          (sha256 1 TREE)\n      )\n  )\n\n  ; recovery message module - gets values curried in to make the puzzle\n  (defun make_message_puzzle (recovering_coin newpuz pubkey)\n    (qq (q . (((unquote CREATE_COIN_ANNOUNCEMENT) (unquote recovering_coin)) ((unquote AGG_SIG_UNSAFE) (unquote pubkey) (unquote newpuz)))))\n  )\n\n  ; this function creates the assert announcement for each message coin approving a recovery\n  (defun-inline create_consume_message (coin_id my_id new_innerpuz pubkey)\n    (list ASSERT_COIN_ANNOUNCEMENT (sha256 (sha256 coin_id (sha256tree1 (make_message_puzzle my_id new_innerpuz pubkey))) my_id))\n  )\n\n  ; this function calculates a coin ID given the inner puzzle and singleton information\n  (defun create_coin_ID_for_recovery (SINGLETON_STRUCT launcher_id parent innerpuzhash amount)\n    (sha256 parent (calculate_full_puzzle_hash (c (f SINGLETON_STRUCT) (c launcher_id (r (r SINGLETON_STRUCT)))) innerpuzhash) amount)\n  )\n\n\n  ; return the full puzzlehash for a singleton with the innerpuzzle curried in\n  ; puzzle-hash-of-curried-function is imported from curry-and-treehash.clinc\n  (defun-inline calculate_full_puzzle_hash (SINGLETON_STRUCT inner_puzzle_hash)\n     (puzzle-hash-of-curried-function (f SINGLETON_STRUCT)\n                                      inner_puzzle_hash\n                                      (sha256tree1 SINGLETON_STRUCT)\n     )\n  )\n\n  ; this loops over our identities to check list, and checks if we have been given parent information for this identity\n  ; the reason for this is because we might only require 3/5 of the IDs give approval messages for a recovery\n  ; if we have the information for an identity then we create a consume message using that information\n\n  (defun check_messages_from_identities (SINGLETON_STRUCT num_verifications_required identities my_id  new_puz parent_innerpuzhash_amounts_for_recovery_ids pubkey num_verifications)\n    (if identities\n      (if (f parent_innerpuzhash_amounts_for_recovery_ids)\n        ; if we have parent information then we should create a consume coin condition\n        (c\n          (create_consume_message\n            ; create coin_id from DID\n            (create_coin_ID_for_recovery\n              SINGLETON_STRUCT\n              (f identities)\n              (f (f parent_innerpuzhash_amounts_for_recovery_ids))\n              (f (r (f parent_innerpuzhash_amounts_for_recovery_ids)))\n              (f (r (r (f parent_innerpuzhash_amounts_for_recovery_ids)))))\n            my_id\n            new_puz\n            pubkey\n          )\n          (check_messages_from_identities\n            SINGLETON_STRUCT\n            num_verifications_required\n            (r identities)\n            my_id\n            new_puz\n            (r parent_innerpuzhash_amounts_for_recovery_ids)\n            pubkey\n            (+ num_verifications 1)\n          )\n        )\n        ; if no parent information found for this identity, move on to next in list\n        (check_messages_from_identities\n          SINGLETON_STRUCT\n          (r identities)\n          my_id\n          new_puz\n          (r parent_innerpuzhash_amounts_for_recovery_ids)\n          pubkey\n          num_verifications\n        )\n      )\n      ;if we're out of identites to check for, check we have enough\n      (if (> num_verifications (- num_verifications_required 1))\n        (list (list AGG_SIG_UNSAFE pubkey new_puz) )\n        (x)\n      )\n    )\n  )\n\n  ;Spend modes:\n  ;0 = recovery\n  ;1 = run the INNER_PUZZLE\n\n  ;MAIN\n  (if mode\n    ; mode 1 - run INNER_PUZZLE\n    (a INNER_PUZZLE my_amount_or_inner_solution)\n\n    ; mode 0 - recovery\n    (if (all (= (sha256tree1 recovery_list_reveal) RECOVERY_DID_LIST_HASH) (> NUM_VERIFICATIONS_REQUIRED 0))\n      (c (list ASSERT_MY_AMOUNT my_amount_or_inner_solution)\n        (c (list CREATE_COIN new_inner_puzhash my_amount_or_inner_solution (list new_inner_puzhash))\n            (c (list ASSERT_MY_COIN_ID my_id)\n                (check_messages_from_identities SINGLETON_STRUCT NUM_VERIFICATIONS_REQUIRED recovery_list_reveal my_id new_inner_puzhash parent_innerpuzhash_amounts_for_recovery_ids pubkey 0)\n            )\n        )\n      )\n      (x)\n    )\n  )\n)\n"})})]}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"DIDs are the next generation of cryptographic identification technology. They can be used with NFTs to validate the source and prevent fakes. They can also be used as a more recoverable form of authorization than keys."})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>s});var t=i(6540);const r={},a=t.createContext(r);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);