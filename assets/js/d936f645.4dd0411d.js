"use strict";(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[16],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return p}});var i=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=i.createContext({}),l=function(e){var n=i.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=l(e.components);return i.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},h=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=l(t),p=r,f=h["".concat(c,".").concat(p)]||h[p]||d[p]||a;return t?i.createElement(f,o(o({ref:n},u),{},{components:t})):i.createElement(f,o({ref:n},u))}));function p(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,o=new Array(a);o[0]=h;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<a;l++)o[l]=t[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}h.displayName="MDXCreateElement"},5749:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return c},default:function(){return p},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return d}});var i=t(7462),r=t(3366),a=(t(7294),t(3905)),o=["components"],s={title:"DIDs",slug:"/dids"},c=void 0,l={unversionedId:"primitives/dids",id:"primitives/dids",title:"DIDs",description:"DIDs are a decentralized way to represent an identity, be that an organization or a person. It is possible to recover a DID even if the key is lost, by having multiple parties send messages approving the inner puzzle change.",source:"@site/docs/primitives/dids.md",sourceDirName:"primitives",slug:"/dids",permalink:"/dids",draft:!1,editUrl:"https://github.com/Chia-Network/{{ REPOSITORY_NAME }}/blob/main/docs/primitives/dids.md",tags:[],version:"current",frontMatter:{title:"DIDs",slug:"/dids"},sidebar:"someSidebar",previous:{title:"NFTs",permalink:"/nfts"},next:{title:"Offers",permalink:"/offers"}},u={},d=[{value:"Code Examples",id:"code-examples",level:2},{value:"chia-blockchain",id:"chia-blockchain",level:3},{value:"chia-rs",id:"chia-rs",level:3},{value:"DID Code",id:"code",level:2},{value:"Conclusion",id:"conclusion",level:2}],h={toc:d};function p(e){var n=e.components,t=(0,r.Z)(e,o);return(0,a.kt)("wrapper",(0,i.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"DIDs are a decentralized way to represent an identity, be that an organization or a person. It is possible to recover a DID even if the key is lost, by having multiple parties send messages approving the inner puzzle change."),(0,a.kt)("p",null,"More functionality will be added to the DID standard in the future, allowing for easier identification and recovery methods."),(0,a.kt)("h2",{id:"code-examples"},"Code Examples"),(0,a.kt)("h3",{id:"chia-blockchain"},"chia-blockchain"),(0,a.kt)("p",null,"The official Chia wallet has a reference implementation for the following in Python:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/Chia-Network/chia-blockchain/blob/010cedf83718aa8e4d97da76f892fe69387a5d82/chia/wallet/did_wallet/did_wallet.py#L1217"},"Mint new DID")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/Chia-Network/chia-blockchain/blob/010cedf83718aa8e4d97da76f892fe69387a5d82/chia/wallet/did_wallet/did_wallet.py#L534"},"Create update DID spend"))),(0,a.kt)("h3",{id:"chia-rs"},"chia-rs"),(0,a.kt)("p",null,"The wallet code used by the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Chia-Network/MonsterSprouts"},"MonsterSprouts example game")," has the following reference methods:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/Chia-Network/chia_rs/blob/wallet-dev/chia-primitives/src/primitives/did.rs"},"Puzzle and solution types")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/Chia-Network/chia_rs/blob/2334c842f694444da317fa7432f308f159f62d70/chia-wallet/src/wallet.rs#L1148"},"Spend DID"))),(0,a.kt)("h2",{id:"code"},"DID Code"),(0,a.kt)("p",null,"This is the source code of the DID inner puzzle, which can also be found in the chia-blockchain repository in the puzzle ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Chia-Network/chia-blockchain/blob/164fd158c8626893bc45ba00b87ae69d2ab5f8b7/chia/wallet/puzzles/did_innerpuz.clvm"},(0,a.kt)("inlineCode",{parentName:"a"},"did_innerpuz.clvm")),"."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Expand DID Inner Puzzle"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-chialisp",metastring:'title="did_innerpuz.clvm"',title:'"did_innerpuz.clvm"'},"; The DID innerpuzzle is designed to sit inside the singleton layer and provide functionality related to being an identity.\n; At the moment the two pieces of functionality are recovery and message creation.\n; A DID's ID is it's Singleton ID\n; Recovery is based around having a list of known other DIDs which can send messages approving you change the innerpuzzle of your DID singleton\n\n(mod\n  (\n  INNER_PUZZLE  ; Standard P2 inner puzzle, used to record the ownership of the DID.\n  RECOVERY_DID_LIST_HASH  ; the list of DIDs that can send messages to you for recovery we store only the hash so that we don't have to reveal every time we make a message spend\n  NUM_VERIFICATIONS_REQUIRED  ; how many of the above list are required for a recovery\n  SINGLETON_STRUCT  ; my singleton_struct, formerly a Truth - ((SINGLETON_MOD_HASH, (LAUNCHER_ID, LAUNCHER_PUZZLE_HASH)))\n  METADATA ; Customized metadata, e.g KYC info\n  mode  ; this indicates which spend mode we want. 0. Recovery mode 1. Run INNER_PUZZLE with p2_solution\n  my_amount_or_inner_solution  ; In mode 0, we use this to recover our coin and assert it is our actual amount\n                             ; In mode 1 this is the solution of the inner P2 puzzle, only required in the create message mode and transfer mode.\n  new_inner_puzhash  ; In recovery mode, this will be the new wallet DID puzzle hash\n  parent_innerpuzhash_amounts_for_recovery_ids  ; during a recovery we need extra information about our recovery list coins\n  pubkey  ; this is the new pubkey used for a recovery\n  recovery_list_reveal  ; this is the reveal of the stored list of DIDs approved for recovery\n  my_id  ; my coin ID\n  )\n  ;message is the new puzzle in the recovery and standard spend cases\n\n  ;MOD_HASH, MY_PUBKEY, RECOVERY_DID_LIST_HASH are curried into the puzzle\n  ;EXAMPLE SOLUTION (0xcafef00d 0x12341234 0x923bf9a7856b19d335a65f12d68957d497e1f0c16c0e14baf6d120e60753a1ce 2 1 100 (q \"source code\") 0xdeadbeef 0xcafef00d ((0xdadadada 0xdad5dad5 200) () (0xfafafafa 0xfaf5faf5 200)) 0xfadeddab (0x22222222 0x33333333 0x44444444))\n\n  (include condition_codes.clvm)\n  (include curry-and-treehash.clinc)\n\n  ; takes a lisp tree and returns the hash of it\n  (defun sha256tree1 (TREE)\n      (if (l TREE)\n          (sha256 2 (sha256tree1 (f TREE)) (sha256tree1 (r TREE)))\n          (sha256 1 TREE)\n      )\n  )\n\n  ; recovery message module - gets values curried in to make the puzzle\n  (defun make_message_puzzle (recovering_coin newpuz pubkey)\n    (qq (q . (((unquote CREATE_COIN_ANNOUNCEMENT) (unquote recovering_coin)) ((unquote AGG_SIG_UNSAFE) (unquote pubkey) (unquote newpuz)))))\n  )\n\n  ; this function creates the assert announcement for each message coin approving a recovery\n  (defun-inline create_consume_message (coin_id my_id new_innerpuz pubkey)\n    (list ASSERT_COIN_ANNOUNCEMENT (sha256 (sha256 coin_id (sha256tree1 (make_message_puzzle my_id new_innerpuz pubkey))) my_id))\n  )\n\n  ; this function calculates a coin ID given the inner puzzle and singleton information\n  (defun create_coin_ID_for_recovery (SINGLETON_STRUCT launcher_id parent innerpuzhash amount)\n    (sha256 parent (calculate_full_puzzle_hash (c (f SINGLETON_STRUCT) (c launcher_id (r (r SINGLETON_STRUCT)))) innerpuzhash) amount)\n  )\n\n\n  ; return the full puzzlehash for a singleton with the innerpuzzle curried in\n  ; puzzle-hash-of-curried-function is imported from curry-and-treehash.clinc\n  (defun-inline calculate_full_puzzle_hash (SINGLETON_STRUCT inner_puzzle_hash)\n     (puzzle-hash-of-curried-function (f SINGLETON_STRUCT)\n                                      inner_puzzle_hash\n                                      (sha256tree1 SINGLETON_STRUCT)\n     )\n  )\n\n  ; this loops over our identities to check list, and checks if we have been given parent information for this identity\n  ; the reason for this is because we might only require 3/5 of the IDs give approval messages for a recovery\n  ; if we have the information for an identity then we create a consume message using that information\n\n  (defun check_messages_from_identities (SINGLETON_STRUCT num_verifications_required identities my_id  new_puz parent_innerpuzhash_amounts_for_recovery_ids pubkey num_verifications)\n    (if identities\n      (if (f parent_innerpuzhash_amounts_for_recovery_ids)\n        ; if we have parent information then we should create a consume coin condition\n        (c\n          (create_consume_message\n            ; create coin_id from DID\n            (create_coin_ID_for_recovery\n              SINGLETON_STRUCT\n              (f identities)\n              (f (f parent_innerpuzhash_amounts_for_recovery_ids))\n              (f (r (f parent_innerpuzhash_amounts_for_recovery_ids)))\n              (f (r (r (f parent_innerpuzhash_amounts_for_recovery_ids)))))\n            my_id\n            new_puz\n            pubkey\n          )\n          (check_messages_from_identities\n            SINGLETON_STRUCT\n            num_verifications_required\n            (r identities)\n            my_id\n            new_puz\n            (r parent_innerpuzhash_amounts_for_recovery_ids)\n            pubkey\n            (+ num_verifications 1)\n          )\n        )\n        ; if no parent information found for this identity, move on to next in list\n        (check_messages_from_identities\n          SINGLETON_STRUCT\n          (r identities)\n          my_id\n          new_puz\n          (r parent_innerpuzhash_amounts_for_recovery_ids)\n          pubkey\n          num_verifications\n        )\n      )\n      ;if we're out of identites to check for, check we have enough\n      (if (> num_verifications (- num_verifications_required 1))\n        (list (list AGG_SIG_UNSAFE pubkey new_puz) )\n        (x)\n      )\n    )\n  )\n\n  ;Spend modes:\n  ;0 = recovery\n  ;1 = run the INNER_PUZZLE\n\n  ;MAIN\n  (if mode\n    ; mode 1 - run INNER_PUZZLE\n    (a INNER_PUZZLE my_amount_or_inner_solution)\n\n    ; mode 0 - recovery\n    (if (all (= (sha256tree1 recovery_list_reveal) RECOVERY_DID_LIST_HASH) (> NUM_VERIFICATIONS_REQUIRED 0))\n      (c (list ASSERT_MY_AMOUNT my_amount_or_inner_solution)\n        (c (list CREATE_COIN new_inner_puzhash my_amount_or_inner_solution (list new_inner_puzhash))\n            (c (list ASSERT_MY_COIN_ID my_id)\n                (check_messages_from_identities SINGLETON_STRUCT NUM_VERIFICATIONS_REQUIRED recovery_list_reveal my_id new_inner_puzhash parent_innerpuzhash_amounts_for_recovery_ids pubkey 0)\n            )\n        )\n      )\n      (x)\n    )\n  )\n)\n"))),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"DIDs are the next generation of cryptographic identification technology. They can be used with NFTs to validate the source and prevent fakes. They can also be used as a more recoverable form of authorization than keys."))}p.isMDXComponent=!0}}]);