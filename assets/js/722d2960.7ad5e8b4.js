"use strict";(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[204],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return u}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},_={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=c(t),u=i,p=h["".concat(l,".").concat(u)]||h[u]||_[u]||o;return t?a.createElement(p,r(r({ref:n},d),{},{components:t})):a.createElement(p,r({ref:n},d))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},3378:function(e,n,t){t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return _}});var a=t(7462),i=t(3366),o=(t(7294),t(3905)),r=["components"],s={title:"NFTs",slug:"/nfts"},l=void 0,c={unversionedId:"primitives/nfts",id:"primitives/nfts",title:"NFTs",description:"NFTs are non-fungible tokens that are minted on the Chia blockchain. The NFT puzzle ensures that there is only ever one copy of a given NFT, and it cannot be divided into multiple coins.",source:"@site/docs/primitives/nfts.md",sourceDirName:"primitives",slug:"/nfts",permalink:"/nfts",draft:!1,editUrl:"https://github.com/Chia-Network/chialisp-web/blob/main/docs/primitives/nfts.md",tags:[],version:"current",frontMatter:{title:"NFTs",slug:"/nfts"},sidebar:"someSidebar",previous:{title:"CATs",permalink:"/cats"},next:{title:"DIDs",permalink:"/dids"}},d={},_=[{value:"Code Examples",id:"code-examples",level:2},{value:"chia-blockchain",id:"chia-blockchain",level:3},{value:"chia-rs",id:"chia-rs",level:3},{value:"NFT Code",id:"code",level:2},{value:"Decision Decisions",id:"decision-decisions",level:2},{value:"Multiple separate forms of data",id:"data",level:4},{value:"Data must match an immutable hash",id:"hash",level:4},{value:"Extendable list of multiple URLs",id:"urls",level:4},{value:"Association with DID",id:"association-with-did",level:2},{value:"Conclusion",id:"conclusion",level:2}],h={toc:_};function u(e){var n=e.components,t=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"NFTs are non-fungible tokens that are minted on the Chia blockchain. The NFT puzzle ensures that there is only ever one copy of a given NFT, and it cannot be divided into multiple coins."),(0,o.kt)("p",null,"They can be used to prove digital ownership of files such as images or videos, as well as the metadata and license pertaining to the file."),(0,o.kt)("h2",{id:"code-examples"},"Code Examples"),(0,o.kt)("h3",{id:"chia-blockchain"},"chia-blockchain"),(0,o.kt)("p",null,"The official Chia wallet has a reference implementation for the following in Python:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/Chia-Network/chia-blockchain/blob/010cedf83718aa8e4d97da76f892fe69387a5d82/chia/wallet/nft_wallet/nft_wallet.py#L321"},"Mint NFT")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/Chia-Network/chia-blockchain/blob/010cedf83718aa8e4d97da76f892fe69387a5d82/chia/wallet/nft_wallet/nft_wallet.py#L1242"},"Bulk mint NFTs")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/Chia-Network/chia-blockchain/blob/010cedf83718aa8e4d97da76f892fe69387a5d82/chia/wallet/nft_wallet/nft_wallet.py#L606"},"Spend NFT"))),(0,o.kt)("h3",{id:"chia-rs"},"chia-rs"),(0,o.kt)("p",null,"The wallet code used by the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Chia-Network/MonsterSprouts"},"MonsterSprouts example game")," has the following reference methods:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/Chia-Network/chia_rs/blob/wallet-dev/chia-primitives/src/primitives/nft.rs"},"Puzzle and solution types")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/Chia-Network/chia_rs/blob/wallet-dev/chia-wallet/src/wallet.rs#L665"},"Bulk mint NFTs")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/Chia-Network/chia_rs/blob/2334c842f694444da317fa7432f308f159f62d70/chia-wallet/src/wallet.rs#L1053"},"Spend NFT"),".")),(0,o.kt)("h2",{id:"code"},"NFT Code"),(0,o.kt)("p",null,"This is the source code of the NFT state layer, which can also be found in the chia-blockchain repository in the puzzle ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Chia-Network/chia-blockchain/blob/164fd158c8626893bc45ba00b87ae69d2ab5f8b7/chia/wallet/puzzles/nft_state_layer.clvm"},(0,o.kt)("inlineCode",{parentName:"a"},"nft_state_layer.clvm")),"."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Expand NFT State Puzzle"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-chialisp",metastring:'title="nft_state_layer.clvm"',title:'"nft_state_layer.clvm"'},"(mod (\n    NFT_STATE_LAYER_MOD_HASH\n    METADATA\n    METADATA_UPDATER_PUZZLE_HASH\n    INNER_PUZZLE\n    inner_solution\n  )\n\n  (include condition_codes.clvm)\n  (include curry-and-treehash.clinc)\n  (include utility_macros.clib)\n\n  (defun-inline nft_state_layer_puzzle_hash (NFT_STATE_LAYER_MOD_HASH METADATA METADATA_UPDATER_PUZZLE_HASH inner_puzzle_hash)\n    (puzzle-hash-of-curried-function NFT_STATE_LAYER_MOD_HASH\n                                     inner_puzzle_hash\n                                     (sha256 ONE METADATA_UPDATER_PUZZLE_HASH)\n                                     (sha256tree METADATA)\n                                     (sha256 ONE NFT_STATE_LAYER_MOD_HASH)\n    )\n  )\n\n\n  ; this function does two things - it wraps the odd value create coins, and it also filters out all negative conditions\n  ; odd_coin_params is (puzhash amount ...)\n  ; new_metadata_info is ((METADATA METADATA_UPDATER_PUZZLE_HASH) conditions)\n  (defun wrap_odd_create_coins (NFT_STATE_LAYER_MOD_HASH conditions odd_coin_params new_metadata_info metadata_seen)\n    (if conditions\n      (if (= (f (f conditions)) CREATE_COIN)\n          (if (logand (f (r (r (f conditions)))) ONE)\n              (assert (not odd_coin_params)\n                (wrap_odd_create_coins NFT_STATE_LAYER_MOD_HASH (r conditions) (r (f conditions)) new_metadata_info metadata_seen)\n              )\n              (c (f conditions) (wrap_odd_create_coins NFT_STATE_LAYER_MOD_HASH (r conditions) odd_coin_params new_metadata_info metadata_seen))\n          )\n          (if (= (f (f conditions)) -24)\n              (wrap_odd_create_coins NFT_STATE_LAYER_MOD_HASH (r conditions) odd_coin_params\n                (assert (all\n                          (= (sha256tree (f (r (f conditions)))) (f (r (f new_metadata_info))))\n                          (not metadata_seen)\n                        )\n                    ; then\n                    (a (f (r (f conditions))) (list (f (f new_metadata_info)) (f (r (f new_metadata_info))) (f (r (r (f conditions))))))\n                )\n                ONE  ; the metadata update has been seen now\n              )\n              (c (f conditions) (wrap_odd_create_coins NFT_STATE_LAYER_MOD_HASH (r conditions) odd_coin_params new_metadata_info metadata_seen))\n          )\n      )\n      (c\n        (c CREATE_COIN\n            (c\n              (nft_state_layer_puzzle_hash\n                NFT_STATE_LAYER_MOD_HASH\n                (f (f new_metadata_info))\n                (f (r (f new_metadata_info)))\n                (f odd_coin_params)  ; metadata updater solution\n              )\n              (r odd_coin_params)\n            )\n        )\n        (f (r new_metadata_info))  ; metadata_updater conditions\n      )\n    )\n  )\n\n  ; main\n  (wrap_odd_create_coins\n    NFT_STATE_LAYER_MOD_HASH\n    (a INNER_PUZZLE inner_solution)\n    ()\n    (list (list METADATA METADATA_UPDATER_PUZZLE_HASH) 0)  ; if the magic condition is never seen, this is the information we us to recurry\n    ()\n  )\n)\n"))),(0,o.kt)("p",null,"This is the source code of the NFT ownership layer, which can also be found in the chia-blockchain repository in the puzzle ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Chia-Network/chia-blockchain/blob/164fd158c8626893bc45ba00b87ae69d2ab5f8b7/chia/wallet/puzzles/nft_ownership_layer.clvm"},(0,o.kt)("inlineCode",{parentName:"a"},"nft_ownership_layer.clvm")),"."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Expand NFT Ownership Puzzle"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-chialisp",metastring:'title="nft_ownership_layer.clvm"',title:'"nft_ownership_layer.clvm"'},'(mod (\n    NFT_OWNERSHIP_LAYER_MOD_HASH\n    CURRENT_OWNER\n    TRANSFER_PROGRAM\n    INNER_PUZZLE\n    inner_solution\n   )\n\n   (include condition_codes.clvm)\n   (include curry-and-treehash.clinc)\n   (include utility_macros.clib)\n\n   (defconstant NEW_OWNER_CONDITION -10)\n   (defconstant ANNOUNCEMENT_PREFIX 0xad4c)  ; first 2 bytes of (sha256 "Ownership Layer")\n\n   (defun-inline nft_ownership_layer_puzzle_hash (NFT_OWNERSHIP_LAYER_MOD_HASH new_owner TRANSFER_PROGRAM inner_puzzle_hash)\n      (puzzle-hash-of-curried-function NFT_OWNERSHIP_LAYER_MOD_HASH\n                                       inner_puzzle_hash\n                                       (sha256tree TRANSFER_PROGRAM)\n                                       (sha256 ONE new_owner)\n                                       (sha256 ONE NFT_OWNERSHIP_LAYER_MOD_HASH)\n      )\n   )\n\n   (defun construct_end_conditions (NFT_OWNERSHIP_LAYER_MOD_HASH TRANSFER_PROGRAM odd_args (new_owner new_tp conditions))\n     (c\n       (c\n         CREATE_COIN\n         (c\n           (nft_ownership_layer_puzzle_hash NFT_OWNERSHIP_LAYER_MOD_HASH new_owner (if new_tp new_tp TRANSFER_PROGRAM) (f odd_args))\n           (r odd_args)\n          )\n        )\n        conditions\n     )\n   )\n\n   (defun wrap_odd_create_coins (NFT_OWNERSHIP_LAYER_MOD_HASH TRANSFER_PROGRAM CURRENT_OWNER all_conditions conditions odd_args tp_output)\n     (if conditions\n       (if (= (f (f conditions)) CREATE_COIN)\n         (if (= (logand (f (r (r (f conditions))))) ONE)\n            (assert (not odd_args)\n              ; then\n              (wrap_odd_create_coins NFT_OWNERSHIP_LAYER_MOD_HASH TRANSFER_PROGRAM CURRENT_OWNER all_conditions (r conditions) (r (f conditions)) tp_output)\n            )\n            (c (f conditions) (wrap_odd_create_coins NFT_OWNERSHIP_LAYER_MOD_HASH TRANSFER_PROGRAM CURRENT_OWNER all_conditions (r conditions) odd_args tp_output))\n         )\n         (if (= (f (f conditions)) NEW_OWNER_CONDITION)\n            (assert (not tp_output)\n              (c\n                (list CREATE_PUZZLE_ANNOUNCEMENT (concat ANNOUNCEMENT_PREFIX (sha256tree (r (f conditions)))))\n                (wrap_odd_create_coins NFT_OWNERSHIP_LAYER_MOD_HASH TRANSFER_PROGRAM CURRENT_OWNER all_conditions (r conditions) odd_args (a TRANSFER_PROGRAM (list CURRENT_OWNER all_conditions (r (f conditions)))))\n              )\n            )\n            (if (= (f (f conditions)) CREATE_PUZZLE_ANNOUNCEMENT)\n                (assert (not (and\n                          (= 34 (strlen (f (r (f conditions)))))\n                          (= (substr (f (r (f conditions))) 0 2) ANNOUNCEMENT_PREFIX)  ; lazy eval\n                        ))\n                  ; then\n                  (c (f conditions) (wrap_odd_create_coins NFT_OWNERSHIP_LAYER_MOD_HASH TRANSFER_PROGRAM CURRENT_OWNER all_conditions (r conditions) odd_args tp_output))\n                )\n                (c (f conditions) (wrap_odd_create_coins NFT_OWNERSHIP_LAYER_MOD_HASH TRANSFER_PROGRAM CURRENT_OWNER all_conditions (r conditions) odd_args tp_output))\n            )\n         )\n       )\n       ; odd_args is guaranteed to not be nil or else we\'ll have a path into atom error\n       (construct_end_conditions NFT_OWNERSHIP_LAYER_MOD_HASH TRANSFER_PROGRAM odd_args\n          (if tp_output\n              tp_output\n              (a TRANSFER_PROGRAM (list CURRENT_OWNER all_conditions ()))\n          )\n       )\n     )\n   )\n\n  (defun main (\n      NFT_OWNERSHIP_LAYER_MOD_HASH\n      TRANSFER_PROGRAM\n      CURRENT_OWNER\n      conditions\n    )\n    (wrap_odd_create_coins\n      NFT_OWNERSHIP_LAYER_MOD_HASH\n      TRANSFER_PROGRAM\n      CURRENT_OWNER\n      conditions\n      conditions\n      () ()\n    )\n  )\n\n  ; main\n  (main\n    NFT_OWNERSHIP_LAYER_MOD_HASH\n    TRANSFER_PROGRAM\n    CURRENT_OWNER\n    (a INNER_PUZZLE inner_solution)\n  )\n)\n'))),(0,o.kt)("p",null,"This is the source code of the default NFT metadata updater, which can also be found in the chia-blockchain repository in the puzzle ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Chia-Network/chia-blockchain/blob/164fd158c8626893bc45ba00b87ae69d2ab5f8b7/chia/wallet/puzzles/nft_metadata_updater_default.clvm"},(0,o.kt)("inlineCode",{parentName:"a"},"nft_metadata_updater_default.clvm")),"."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Expand NFT Metadata Updater Puzzle"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-chialisp",metastring:'title="nft_metadata_updater_default.clvm"',title:'"nft_metadata_updater_default.clvm"'},'(mod (CURRENT_METADATA METADATA_UPDATER_PUZZLE_HASH (key . new_url))\n\n  ; METADATA and METADATA_UPDATER_PUZZLE_HASH are passed in as truths from the layer above\n  ; This program returns ((new_metadata new_metadata_updater_puzhash) conditions)\n\n  ; Add uri to a field\n  (defun add_url (METADATA key new_url)\n    (if METADATA\n      (if (= (f (f METADATA)) key)\n        (c (c key (c new_url (r (f METADATA)))) (r METADATA))\n        (c (f METADATA) (add_url (r METADATA) key new_url))\n      )\n      ()\n    )\n  )\n  ; main\n  ; returns ((new_metadata new_metadata_updater_puzhash) conditions)\n  (list\n    (list\n        (if (all key new_url)\n            (if (any (= key "mu") (= key "lu") (= key "u"))\n                (add_url CURRENT_METADATA key new_url)\n                CURRENT_METADATA\n            )\n            CURRENT_METADATA\n         )\n        METADATA_UPDATER_PUZZLE_HASH)\n    0\n  )\n)\n'))),(0,o.kt)("h2",{id:"decision-decisions"},"Decision Decisions"),(0,o.kt)("h4",{id:"data"},"Multiple separate forms of data"),(0,o.kt)("p",null,"There are three kinds of files that can be added to the NFT, one per type:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Data, for things such as images and videos"),(0,o.kt)("li",{parentName:"ul"},"Metadata, for information about the data or NFT"),(0,o.kt)("li",{parentName:"ul"},"License, detailing legal rights related to the NFT")),(0,o.kt)("h4",{id:"hash"},"Data must match an immutable hash"),(0,o.kt)("p",null,"Any data that the NFT points to must match a specific ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/SHA-2"},"sha256")," hash. The hash cannot be changed later, even by the creator of the NFT. This prevents it from being modified or tampered with later, and enforces permanence."),(0,o.kt)("h4",{id:"urls"},"Extendable list of multiple URLs"),(0,o.kt)("p",null,"Each type of data has a list of URLs that each resolve to the hash of the data. However, if a URL is no longer valid or has been compromised, it will no longer match, which means it won't be displayed in the wallet. To help uphold permanence, the owner can add a new URL that matches the original hash. It will be prepended to the beginning of the list so that it's checked first in the future."),(0,o.kt)("p",null,"It's recommended to start with multiple links, some on a decentralized platform such as ",(0,o.kt)("a",{parentName:"p",href:"https://www.ipfs.com"},"IPFS")," or ",(0,o.kt)("a",{parentName:"p",href:"https://www.arweave.org"},"Arweave"),", and others on a server you have control over. This way, even if one fails, the others can be used as a fallback."),(0,o.kt)("h2",{id:"association-with-did"},"Association with DID"),(0,o.kt)("p",null,"You can add a DID to the NFT when you mint it to show that it is a part of that identity. For example, you can always verify that a ",(0,o.kt)("a",{parentName:"p",href:"https://chiafriends.xyz"},"Chia Friend NFT")," is authentic by checking that the DID matches the DNS record on ",(0,o.kt)("a",{parentName:"p",href:"https://did.chia.net"},"did.chia.net")," and the collection id in the metadata matches the rest."),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"NFTs are a great way to represent indivisible assets on the Chia blockchain. You can attach royalties to them that get paid upon sale, and store files such as images in them, with attached metadata and license files."))}u.isMDXComponent=!0}}]);