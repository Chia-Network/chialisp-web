"use strict";(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[313],{3905:function(t,e,a){a.d(e,{Zo:function(){return m},kt:function(){return u}});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function o(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var p=n.createContext({}),d=function(t){var e=n.useContext(p),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},m=function(t){var e=d(t.components);return n.createElement(p.Provider,{value:e},t.children)},s={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},k=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,p=t.parentName,m=o(t,["components","mdxType","originalType","parentName"]),k=d(a),u=r,N=k["".concat(p,".").concat(u)]||k[u]||s[u]||l;return a?n.createElement(N,i(i({ref:e},m),{},{components:a})):n.createElement(N,i({ref:e},m))}));function u(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,i=new Array(l);i[0]=k;var o={};for(var p in e)hasOwnProperty.call(e,p)&&(o[p]=e[p]);o.originalType=t,o.mdxType="string"==typeof t?t:r,i[1]=o;for(var d=2;d<l;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},147:function(t,e,a){a.r(e),a.d(e,{assets:function(){return m},contentTitle:function(){return p},default:function(){return u},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return s}});var n=a(7462),r=a(3366),l=(a(7294),a(3905)),i=["components"],o={id:"operators",title:"Operators",slug:"/operators"},p=void 0,d={unversionedId:"operators",id:"operators",title:"Operators",description:"This is a basic description of each operator. If you want tangible examples for how to use them, check out the Examples page.",source:"@site/docs/operators.md",sourceDirName:".",slug:"/operators",permalink:"/operators",draft:!1,editUrl:"https://github.com/Chia-Network/{{ REPOSITORY_NAME }}/blob/main/docs/operators.md",tags:[],version:"current",frontMatter:{id:"operators",title:"Operators",slug:"/operators"},sidebar:"someSidebar",previous:{title:"Syntax",permalink:"/syntax"},next:{title:"Examples",permalink:"/examples"}},m={},s=[{value:"Chialisp Modules",id:"chialisp-modules",level:2},{value:"Arithmetic",id:"arithmetic",level:2},{value:"Negative Division",id:"negative-division",level:3},{value:"Comparison",id:"comparison",level:2},{value:"Control Flow",id:"control-flow",level:2},{value:"If Operator",id:"if-operator",level:3},{value:"Evaluation",id:"evaluation",level:2},{value:"Environment Operator",id:"environment-operator",level:3},{value:"Lists",id:"lists",level:2},{value:"Atoms",id:"atoms",level:2},{value:"BLS12-381",id:"bls12-381",level:2},{value:"Softfork",id:"softfork",level:2}],k={toc:s};function u(t){var e=t.components,a=(0,r.Z)(t,i);return(0,l.kt)("wrapper",(0,n.Z)({},k,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"This is a basic description of each operator. If you want tangible examples for how to use them, check out the ",(0,l.kt)("a",{parentName:"p",href:"/examples"},"Examples page"),"."),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The operators in the ",(0,l.kt)("a",{parentName:"p",href:"#modules"},"Modules section"),", as well as ",(0,l.kt)("inlineCode",{parentName:"p"},"if"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"qq"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"unquote")," are only part of Chialisp, not the compiled CLVM representation."),(0,l.kt)("p",{parentName:"admonition"},"Additionally, they do not have an intrinsic cost, since they are compiled to CLVM and not actually executed on their own.")),(0,l.kt)("h2",{id:"chialisp-modules"},"Chialisp Modules"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Statement"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mod"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(mod A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Compiles module with args A and body B.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"include"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(include A.clib)")),(0,l.kt)("td",{parentName:"tr",align:null},"Includes file A containing a list of statements.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defun"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(defun A B C)")),(0,l.kt)("td",{parentName:"tr",align:null},"Function named A with args B and body C.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defun-inline"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(defun-inline A B C)")),(0,l.kt)("td",{parentName:"tr",align:null},"Inline function named A with args B and body C.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lambda"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(lambda A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Lambda function with args A and body B.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defmacro"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(defmacro A B C)")),(0,l.kt)("td",{parentName:"tr",align:null},"Macro named A with args B and body C.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defconstant"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(defconstant A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Constant A with value B.")))),(0,l.kt)("h2",{id:"arithmetic"},"Arithmetic"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"+"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(+ A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Adds multiple atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(- A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Subtracts multiple atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"*"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(* A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Multiplies multiple atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"/"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(/ A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Divides two atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"divmod"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(divmod A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Calculates quotient and remainder in cons pair.")))),(0,l.kt)("h3",{id:"negative-division"},"Negative Division"),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"/")," operator cannot be used to divide negative numbers. Previously this worked, but used the wrong method of dividing negative integers. The operator was ",(0,l.kt)("a",{parentName:"p",href:"https://www.chia.net/2022/03/04/divided-we-fork.en.html"},"soft-forked at block height 2,300,000")," to prevent this."),(0,l.kt)("p",{parentName:"admonition"},"You should use ",(0,l.kt)("inlineCode",{parentName:"p"},"divmod")," instead in situations where you need to divide negative numbers."),(0,l.kt)("p",{parentName:"admonition"},"For example:"),(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre",className:"language-chialisp"},"(f (divmod -6 3)) ; -2\n"))),(0,l.kt)("h2",{id:"comparison"},"Comparison"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"="),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(= A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"True if both atoms are equal.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},">"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(> A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"True if the first atom is greater as a number.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},">s"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(>s A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"True if the first atom is greater as a string of bytes.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"not"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(not A)")),(0,l.kt)("td",{parentName:"tr",align:null},"True if the atom is false.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"all"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(all A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"True if all of the atoms are non-zero.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"any"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(any A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"True if any of the atoms are non-zero.")))),(0,l.kt)("h2",{id:"control-flow"},"Control Flow"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"if"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(if A B C)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Chialisp only")," - If A is true, then B, otherwise C. Lazy evaluated.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"i - ",(0,l.kt)("em",{parentName:"td"},"if")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(i A B C)")),(0,l.kt)("td",{parentName:"tr",align:null},"If A is true, then B, otherwise C.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"x - ",(0,l.kt)("em",{parentName:"td"},"exit")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(x ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Terminate the program with zero or more values.")))),(0,l.kt)("h3",{id:"if-operator"},"If Operator"),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," operator is lazy evaluated. This means that code paths are not evaluated unless they need to be."),(0,l.kt)("p",{parentName:"admonition"},"Usually this is the intended behavior, but if it isn't, you can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," operator instead."),(0,l.kt)("p",{parentName:"admonition"},"If you would like to replicate the lazy evaluation of the ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," operator in CLVM, you can wrap the ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," operator like this:"),(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre",className:"language-chialisp"},"(a (i A (q . B) (q . C)) 1)\n")),(0,l.kt)("p",{parentName:"admonition"},"Essentially, this runs the branch the condition matches as a program (with the current environment). Depending on how much code is executed in each branch, this may be more cost effective than executing both branches.")),(0,l.kt)("h2",{id:"evaluation"},"Evaluation"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qq - ",(0,l.kt)("em",{parentName:"td"},"quasi-quote")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(qq A)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Chialisp only")," - Quote an expression except for certain sections.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"unquote"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(unquote A)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Chialisp only")," - Unquote a section of an expression inside ",(0,l.kt)("inlineCode",{parentName:"td"},"qq"),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"q - ",(0,l.kt)("em",{parentName:"td"},"quote")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(q . A)")),(0,l.kt)("td",{parentName:"tr",align:null},"Treats A as a value rather than a program.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a - ",(0,l.kt)("em",{parentName:"td"},"apply")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(a A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Evaluate value A as a program with value B as its environment.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"@ - ",(0,l.kt)("em",{parentName:"td"},"environment")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(@ A)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Chialisp only")," - Access value A from the environment.")))),(0,l.kt)("h3",{id:"environment-operator"},"Environment Operator"),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"@")," operator acts in a similar fashion to unquoted atoms in CLVM. If ",(0,l.kt)("inlineCode",{parentName:"p"},"@")," is used plainly as a value, its value is the whole environment.")),(0,l.kt)("h2",{id:"lists"},"Lists"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"f - ",(0,l.kt)("em",{parentName:"td"},"first")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(f A)")),(0,l.kt)("td",{parentName:"tr",align:null},"First value in list A.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"r - ",(0,l.kt)("em",{parentName:"td"},"rest")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(r A)")),(0,l.kt)("td",{parentName:"tr",align:null},"Rest of the values in list A.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"c - ",(0,l.kt)("em",{parentName:"td"},"cons")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(c A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Cons pair of A and B, or prepend A to list B.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"l - ",(0,l.kt)("em",{parentName:"td"},"list predicate")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(l A)")),(0,l.kt)("td",{parentName:"tr",align:null},"True if A is a list, not nil. Can be used to check length.")))),(0,l.kt)("h2",{id:"atoms"},"Atoms"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sha256"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(sha256 A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Calculates the sha256 hash of the atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"concat"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(concat A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Concatenates the bytes of the atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"strlen"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(strlen A)")),(0,l.kt)("td",{parentName:"tr",align:null},"Returns the length of the atom.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"substr"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(substr A B C)")),(0,l.kt)("td",{parentName:"tr",align:null},"Slice of bytes A between B and C, exclusive.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"logand"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(logand A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Bitwise and of the atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"logior"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(logior A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Bitwise logical or of the atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"logxor"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(logxor A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Bitwise xor of the atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lognot"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(lognot A)")),(0,l.kt)("td",{parentName:"tr",align:null},"Bitwise not of A.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ash - ",(0,l.kt)("em",{parentName:"td"},"arithmetic shift")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(ash A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Arithmetic shift A by B bits.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lsh - ",(0,l.kt)("em",{parentName:"td"},"logical shift")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(lsh A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Logical shift A by B bits.")))),(0,l.kt)("h2",{id:"bls12-381"},"BLS12-381"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"point_add"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(point_add A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Adds G1 points (public keys) together.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pubkey_for_exp"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(pubkey_for_exp A)")),(0,l.kt)("td",{parentName:"tr",align:null},"Turns A (private key) into a G1 point (public key).")))),(0,l.kt)("h2",{id:"softfork"},"Softfork"),(0,l.kt)("p",null,"The softfork operator is defined as ",(0,l.kt)("inlineCode",{parentName:"p"},"(softfork cost A B ..)"),"."),(0,l.kt)("p",null,"At the moment, ",(0,l.kt)("inlineCode",{parentName:"p"},"softfork")," always returns ",(0,l.kt)("inlineCode",{parentName:"p"},"0")," (nil), and requires ",(0,l.kt)("inlineCode",{parentName:"p"},"cost")," amount of cost."),(0,l.kt)("p",null,"At first glance, it seems pretty useless since it doesn't do anything and just wastes cost doing it."),(0,l.kt)("p",null,"The idea is, after a soft fork, the meaning of the arguments may change. In fact, we can hide completely new dialects of CLVM inside here, that have new operators that calculate new things."),(0,l.kt)("p",null,"For example, suppose we want to add secp256k1 operators like ",(0,l.kt)("inlineCode",{parentName:"p"},"+s")," for adding two points on this ECDSA curve for bitcoin compatibility. We can't just do this in vanilla CLVM, because that would make the program ",(0,l.kt)("inlineCode",{parentName:"p"},"(+s A B)")," return different values before and after the soft fork. So instead, we can hide it under ",(0,l.kt)("inlineCode",{parentName:"p"},"softfork"),"."),(0,l.kt)("p",null,"Here is an example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-chialisp"},"(mod (cost p1 p2 p3 p4)\n    (softfork cost 1 (assert (= (+s p1 p2) (+s p3 p4))))\n)\n")),(0,l.kt)("p",null,"Pre-softfork, this always passes and returns ",(0,l.kt)("inlineCode",{parentName:"p"},"()")," at a cost of ",(0,l.kt)("inlineCode",{parentName:"p"},"cost")," (plus a bit of overhead)."),(0,l.kt)("p",null,"Post-softfork, this also returns ",(0,l.kt)("inlineCode",{parentName:"p"},"()")," at a cost of ",(0,l.kt)("inlineCode",{parentName:"p"},"cost"),", but may also fail if ",(0,l.kt)("inlineCode",{parentName:"p"},"p1 + p2 != p3 + p4"),". We can't export the sum outside the ",(0,l.kt)("inlineCode",{parentName:"p"},"softfork")," boundary, but we can calculate the sum and compare it to another thing inside."),(0,l.kt)("p",null,"We take the cost of running the program inside the ",(0,l.kt)("inlineCode",{parentName:"p"},"softfork")," boundary and ensure it exactly matches ",(0,l.kt)("inlineCode",{parentName:"p"},"COST"),", and raise an exception if it's wrong. That way, the program really does have the same cost pre and post-softfork (or it fails post-softfork)."),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"softfork")," operator is currently unused, as there has not been a soft fork that has required new CLVM operators since mainnet. It exists solely as a way to implement new functionality later on if needed.")))}u.isMDXComponent=!0}}]);