(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[313],{773:function(t,e,a){"use strict";a.d(e,{Z:function(){return b}});var n=a(7462),r=a(2949),l=a(171),i=a(3746),o=a(7410),p=a(7294),d=a(5154),m=a(460),s=a.n(m),u=a(9042),k=a.n(u),N=a(23),g=a.n(N);function c(t){return t instanceof Array||(0,p.isValidElement)(t)?p.Children.toArray(t).reduce((function(t,e){var a="";return a=(0,p.isValidElement)(e)&&f(e)?c(e.props.children):(0,p.isValidElement)(e)&&!f(e)?"":h(e),t.concat(a)}),""):h(t)}function h(t){return null==t||"boolean"==typeof t||"{}"===JSON.stringify(t)?"":t.toString()}function f(t){return(0,p.isValidElement)(t)&&Boolean(t.props.children)}function b(t){var e,a,n=t.children,m=t.flavor,s=t.input,u=t.tests,N=t.reporter,h=(0,r.I)().colorMode,f=(0,p.useMemo)((function(){return c(n).trim()}),[]),b=(0,p.useState)(f),C=b[0],v=b[1],w=(0,p.useState)(null!=(e=null!=s?s:null==(a=Object.keys(null!=u?u:{})[0])?void 0:a.trim())?e:""),A=w[0],x=w[1],B=(0,p.useState)(""),E=B[0],_=B[1],q=(0,p.useState)(0n),T=q[0],S=q[1],F=(0,p.useState)(null),M=F[0],D=F[1],O=function(t){return t.replace("Error: ","")},I=function(t,e){try{return t.run(e)}catch(a){return _("While evaluating: "+O(""+a)),null}},P=function(){var t=function(){try{return l.Program.fromSource(C)}catch(t){return _("While parsing: "+O(""+t)),null}}();if(t){var e="clvm"===m||t.isCons&&t.first.equals(l.Program.fromText("mod")),a=function(t){if(m&&"chialisp"!==m)return t;try{return t.compile().value}catch(e){return _("While compiling: "+O(""+e)),null}}(t);if(a){var n=A?l.Program.fromSource(A):l.Program.nil,r=e?I(a,n):{value:a,cost:0n};r&&(_(r.value.toSource()),S(r.cost));for(var i=!0,o=0,p=Object.entries(null!=u?u:{});o<p.length;o++){var d,s=p[o],k=s[0],g=s[1],c=l.Program.fromSource(k),h=e?null==(d=I(a,c))?void 0:d.value:a;if(!h||h.toSource()!==g){i=!1;break}}null==N||N(i),D(i)}}},L=M?d.l_A:d.aHS,V=p.useState(!1),z=V[0],G=V[1];return(0,p.useEffect)((function(){return G(!0)}),[]),p.createElement(i.ZP,{Prism:o.Z,theme:z&&("dark"===h?k():g()),code:C,language:"chialisp"},(function(t){var e=t.className,a=t.style;return p.createElement("pre",{className:e,style:Object.assign({},a,{position:"relative"})},A?p.createElement(p.Fragment,null,p.createElement(y,{code:A,setCode:x,language:"chialisp"}),p.createElement("hr",{style:{marginTop:"14px",marginBottom:"14px"}})):"",p.createElement(y,{code:C,setCode:v,language:"chialisp"}),p.createElement("div",{style:{position:"absolute",top:"16px",right:"16px"}},p.createElement("div",{style:{display:"flex",alignItems:"center",gap:"14px"}},p.createElement("span",{style:{marginRight:"8px"}},m&&"chialisp"!==m?"CLVM":"Chialisp"),!A&&p.createElement(d.A0H,{size:24,className:"icon-button",cursor:"pointer",onClick:function(){return x("()")}}),p.createElement(d.gmG,{size:24,className:"icon-button",cursor:"pointer",onClick:P}))),E?p.createElement(p.Fragment,null,p.createElement("hr",{style:{marginTop:"14px",marginBottom:"14px"}}),p.createElement("div",{style:{display:"inline-block"}},p.createElement(y,{code:E,language:"chialisp"})),E&&p.createElement(p.Fragment,null,p.createElement("div",{style:{display:"inline-block",position:"absolute",right:"60px"}},p.createElement(y,{code:"Cost: "+T,language:"chialisp"})),p.createElement(L,{size:24,color:M?"#77FF77":"#FF7777",style:{position:"absolute",bottom:"16px",right:"16px"}}))):"")}))}function y(t){var e=t.code,a=t.setCode,l=t.language,d=(0,r.I)().colorMode,m=p.useState(!1),u=m[0],N=m[1];return(0,p.useEffect)((function(){return N(!0)}),[]),p.createElement(p.Fragment,null,p.createElement(i.ZP,{Prism:o.Z,theme:u&&("dark"===d?k():g()),code:e,language:l},(function(t){var r=t.tokens,l=t.getLineProps,i=t.getTokenProps,o=r.map((function(t,e){return p.createElement("div",(0,n.Z)({key:e},l({line:t})),t.map((function(t,e){return p.createElement("span",(0,n.Z)({key:e},i({token:t})))})))}));return a?p.createElement(s(),{value:e,onValueChange:function(t){return a(t)},highlight:function(){return o},padding:0}):o})))}},9042:function(t){t.exports={plain:{color:"#F8F8F2",backgroundColor:"#282A36",fontWeight:"bold"},styles:[{types:["keyword"],style:{color:"rgb(189, 147, 249)"}},{types:["listop","class-name","quotes"],style:{color:"rgb(80, 250, 123)"}},{types:["builtin"],style:{color:"rgb(5, 227, 223)"}},{types:["number","hexadecimal","string","boolean"],style:{color:"rgb(255, 184, 108)",fontWeight:"normal"}},{types:["punctuation","symbol"],style:{color:"rgb(248, 248, 242)"}},{types:["variable"],style:{fontStyle:"italic"}},{types:["comment"],style:{color:"rgb(98, 114, 164)",fontWeight:"normal"}},{types:["function","car"],style:{color:"rgb(241, 250, 140)"}}]}},23:function(t){t.exports={plain:{color:"#383a42",backgroundColor:"#fafafa",fontWeight:"bold"},styles:[{types:["keyword"],style:{color:"#990096"}},{types:["listop","class-name","quotes"],style:{color:"#006100"}},{types:["builtin"],style:{color:"#127EAF"}},{types:["number","hexadecimal","string","boolean"],style:{color:"#B35C00",fontWeight:"normal"}},{types:["punctuation","symbol"],style:{color:"#383a42"}},{types:["variable"],style:{fontStyle:"italic"}},{types:["comment"],style:{color:"#73737D",fontWeight:"normal"}},{types:["function","car"],style:{color:"#0045DB"}}]}},147:function(t,e,a){"use strict";a.r(e),a.d(e,{assets:function(){return s},contentTitle:function(){return d},default:function(){return N},frontMatter:function(){return p},metadata:function(){return m},toc:function(){return u}});var n=a(7462),r=a(3366),l=(a(7294),a(3905)),i=a(773),o=["components"],p={id:"operators",title:"Operators",slug:"/operators"},d=void 0,m={unversionedId:"operators",id:"operators",title:"Operators",description:"This is a basic description of each operator. If you want tangible examples for how to use them, check out the Examples page.",source:"@site/docs/operators.md",sourceDirName:".",slug:"/operators",permalink:"/operators",draft:!1,editUrl:"https://github.com/Chia-Network/chialisp-web/blob/main/docs/operators.md",tags:[],version:"current",frontMatter:{id:"operators",title:"Operators",slug:"/operators"},sidebar:"someSidebar",previous:{title:"Syntax",permalink:"/syntax"},next:{title:"Examples",permalink:"/examples"}},s={},u=[{value:"Chialisp Modules",id:"chialisp-modules",level:2},{value:"Arithmetic",id:"arithmetic",level:2},{value:"Negative Division",id:"negative-division",level:3},{value:"Comparison",id:"comparison",level:2},{value:"Control Flow",id:"control-flow",level:2},{value:"If Operator",id:"if-operator",level:3},{value:"Evaluation",id:"evaluation",level:2},{value:"Environment Operator",id:"environment-operator",level:3},{value:"Lists",id:"lists",level:2},{value:"Atoms",id:"atoms",level:2},{value:"BLS12-381",id:"bls12-381",level:2},{value:"Softfork",id:"softfork",level:2},{value:"CHIP-0011 Operators",id:"chip-0011-operators",level:2}],k={toc:u};function N(t){var e=t.components,a=(0,r.Z)(t,o);return(0,l.kt)("wrapper",(0,n.Z)({},k,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"This is a basic description of each operator. If you want tangible examples for how to use them, check out the ",(0,l.kt)("a",{parentName:"p",href:"/examples"},"Examples page"),"."),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The operators in the ",(0,l.kt)("a",{parentName:"p",href:"#modules"},"Modules section"),", as well as ",(0,l.kt)("inlineCode",{parentName:"p"},"if"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"qq"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"unquote")," are only part of Chialisp, not the compiled CLVM representation."),(0,l.kt)("p",{parentName:"admonition"},"Additionally, they do not have an intrinsic cost, since they are compiled to CLVM and not actually executed on their own.")),(0,l.kt)("h2",{id:"chialisp-modules"},"Chialisp Modules"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Statement"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mod"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(mod A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Compiles module with args A and body B.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"include"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(include A.clib)")),(0,l.kt)("td",{parentName:"tr",align:null},"Includes file A containing a list of statements.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defun"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(defun A B C)")),(0,l.kt)("td",{parentName:"tr",align:null},"Function named A with args B and body C.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defun-inline"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(defun-inline A B C)")),(0,l.kt)("td",{parentName:"tr",align:null},"Inline function named A with args B and body C.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lambda"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(lambda A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Lambda function with args A and body B.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defmacro"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(defmacro A B C)")),(0,l.kt)("td",{parentName:"tr",align:null},"Macro named A with args B and body C.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defconstant"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(defconstant A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Constant A with value B.")))),(0,l.kt)("h2",{id:"arithmetic"},"Arithmetic"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"+"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(+ A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Adds multiple atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(- A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Subtracts multiple atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"*"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(* A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Multiplies multiple atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"/"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(/ A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Divides two atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"divmod"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(divmod A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Calculates quotient and remainder in cons pair.")))),(0,l.kt)("h3",{id:"negative-division"},"Negative Division"),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"/")," operator cannot be used to divide negative numbers. Previously this worked, but used the wrong method of dividing negative integers. The operator was ",(0,l.kt)("a",{parentName:"p",href:"https://www.chia.net/2022/03/04/divided-we-fork.en.html"},"soft-forked at block height 2,300,000")," to prevent this."),(0,l.kt)("p",{parentName:"admonition"},"You should use ",(0,l.kt)("inlineCode",{parentName:"p"},"divmod")," instead in situations where you need to divide negative numbers."),(0,l.kt)("p",{parentName:"admonition"},"For example:"),(0,l.kt)(i.Z,{flavor:"chialisp",mdxType:"Runnable"},(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre",className:"language-chialisp"},"(f (divmod -6 3))\n")))),(0,l.kt)("h2",{id:"comparison"},"Comparison"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"="),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(= A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"True if both atoms are equal.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},">"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(> A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"True if the first atom is greater as a number.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},">s"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(>s A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"True if the first atom is greater as a string of bytes.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"not"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(not A)")),(0,l.kt)("td",{parentName:"tr",align:null},"True if the atom is false.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"all"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(all A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"True if all of the atoms are non-zero.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"any"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(any A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"True if any of the atoms are non-zero.")))),(0,l.kt)("h2",{id:"control-flow"},"Control Flow"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"if"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(if A B C)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Chialisp only")," - If A is true, then B, otherwise C. Lazy evaluated.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"i - ",(0,l.kt)("em",{parentName:"td"},"if")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(i A B C)")),(0,l.kt)("td",{parentName:"tr",align:null},"If A is true, then B, otherwise C.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"x - ",(0,l.kt)("em",{parentName:"td"},"exit")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(x ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Terminate the program with zero or more values.")))),(0,l.kt)("h3",{id:"if-operator"},"If Operator"),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," operator is lazy evaluated. This means that code paths are not evaluated unless they need to be."),(0,l.kt)("p",{parentName:"admonition"},"Usually this is the intended behavior, but if it isn't, you can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," operator instead."),(0,l.kt)("p",{parentName:"admonition"},"If you would like to replicate the lazy evaluation of the ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," operator in CLVM, you can wrap the ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," operator like this:"),(0,l.kt)(i.Z,{flavor:"clvm",mdxType:"Runnable"},(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre",className:"language-chialisp"},"(a (i (q . 1) (q q . 'abc') (q q . 'xyz')) 1)\n"))),(0,l.kt)("p",{parentName:"admonition"},"Essentially, this runs the branch the condition matches as a program (with the current environment). Depending on how much code is executed in each branch, this may be more cost effective than executing both branches.")),(0,l.kt)("h2",{id:"evaluation"},"Evaluation"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qq - ",(0,l.kt)("em",{parentName:"td"},"quasi-quote")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(qq A)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Chialisp only")," - Quote an expression except for anything inside ",(0,l.kt)("inlineCode",{parentName:"td"},"unquote"),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"unquote"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(unquote A)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Chialisp only")," - Unquote an expression nested within ",(0,l.kt)("inlineCode",{parentName:"td"},"qq"),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"q - ",(0,l.kt)("em",{parentName:"td"},"quote")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(q . A)")),(0,l.kt)("td",{parentName:"tr",align:null},"Treats A as a value rather than a program.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a - ",(0,l.kt)("em",{parentName:"td"},"apply")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(a A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Evaluate value A as a program with value B as its environment.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"@ - ",(0,l.kt)("em",{parentName:"td"},"environment")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(@ A)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Chialisp only")," - Access value A from the environment.")))),(0,l.kt)("h3",{id:"environment-operator"},"Environment Operator"),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"@")," operator acts in a similar fashion to unquoted atoms in CLVM. If ",(0,l.kt)("inlineCode",{parentName:"p"},"@")," is used plainly as a value, its value is the whole environment.")),(0,l.kt)("h2",{id:"lists"},"Lists"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"f - ",(0,l.kt)("em",{parentName:"td"},"first")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(f A)")),(0,l.kt)("td",{parentName:"tr",align:null},"First value in list A.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"r - ",(0,l.kt)("em",{parentName:"td"},"rest")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(r A)")),(0,l.kt)("td",{parentName:"tr",align:null},"Rest of the values in list A.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"c - ",(0,l.kt)("em",{parentName:"td"},"cons")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(c A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Cons pair of A and B, or prepend A to list B.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"l - ",(0,l.kt)("em",{parentName:"td"},"list predicate")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(l A)")),(0,l.kt)("td",{parentName:"tr",align:null},"True if A is a list, not nil. Can be used to check length.")))),(0,l.kt)("h2",{id:"atoms"},"Atoms"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sha256"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(sha256 A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Calculates the sha256 hash of the atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"concat"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(concat A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Concatenates the bytes of the atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"strlen"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(strlen A)")),(0,l.kt)("td",{parentName:"tr",align:null},"Returns the length of the atom.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"substr"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(substr A B C)")),(0,l.kt)("td",{parentName:"tr",align:null},"Slice of bytes A between B and C, exclusive.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"logand"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(logand A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Bitwise and of the atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"logior"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(logior A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Bitwise logical or of the atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"logxor"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(logxor A B ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Bitwise xor of the atoms.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lognot"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(lognot A)")),(0,l.kt)("td",{parentName:"tr",align:null},"Bitwise not of A.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ash - ",(0,l.kt)("em",{parentName:"td"},"arithmetic shift")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(ash A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Arithmetic shift A by B bits.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lsh - ",(0,l.kt)("em",{parentName:"td"},"logical shift")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(lsh A B)")),(0,l.kt)("td",{parentName:"tr",align:null},"Logical shift A by B bits.")))),(0,l.kt)("h2",{id:"bls12-381"},"BLS12-381"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"point_add"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(point_add p1 p2 ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Adds two or more G1 points (public keys) together. Renamed to g1_add in ",(0,l.kt)("a",{parentName:"td",href:"#chip-0011-operators"},"CHIP-0111"),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pubkey_for_exp"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(pubkey_for_exp A)")),(0,l.kt)("td",{parentName:"tr",align:null},"Maps an exponent (secret key) to a G1 point (public key).")))),(0,l.kt)("h2",{id:"softfork"},"Softfork"),(0,l.kt)("p",null,"The purpose of the ",(0,l.kt)("inlineCode",{parentName:"p"},"softfork")," operator is to enable the ability to define new CLVM operators without creating a hard fork. For example, suppose we want to add secp256k1 operators like ",(0,l.kt)("inlineCode",{parentName:"p"},"+s")," for adding two points on this ECDSA curve for bitcoin compatibility. We can't just do this in vanilla CLVM, because that would make the program ",(0,l.kt)("inlineCode",{parentName:"p"},"(+s A B)")," return different values before and after the soft fork. So instead, we can hide it under ",(0,l.kt)("inlineCode",{parentName:"p"},"softfork"),"."),(0,l.kt)("p",null,"The syntax is defined as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-chialisp"},"(softfork cost extension program arguments)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"cost")," must equal the cost of executing the program with the specified arguments, otherwise an exception is raised. The minimum cost of the operator is 140."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"extension")," is an unsigned (up to 32-bit in size) integer indicating the set of extensions available in the softfork guard."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"program")," is executed with the specified ",(0,l.kt)("inlineCode",{parentName:"li"},"arguments"),". The output is always either null or termination of the program if it failed.")),(0,l.kt)("p",null,"Here is a CLVM example using the ",(0,l.kt)("inlineCode",{parentName:"p"},"coinid")," operator described in the ",(0,l.kt)("a",{parentName:"p",href:"#chip-0011-operators"},"CHIP-0011 Operators")," section:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-chialisp"},"(softfork\n  (q . 1265)  ; expected cost (including cost of softfork itself)\n  (q . 0)     ; extension 0\n  (q a        ; defer execution of if-branches\n    (i\n      (=\n        (coinid\n          (q . 0x1234500000000000000000000000000000000000000000000000000000000000)\n          (q . 0x6789abcdef000000000000000000000000000000000000000000000000000000)\n          (q . 123456789)\n        )\n        (q . 0x69bfe81b052bfc6bd7f3fb9167fec61793175b897c16a35827f947d5cc98e4bc)\n      )\n      (q . 0) ; if coin ID matches, return 0\n      (q x)   ; if coin ID mismatches, raise\n    )\n    (q . ())) ; environment to apply\n  (q . ())    ; environment to softfork\n)\n")),(0,l.kt)("p",null,"Pre-softfork, this always passes and returns ",(0,l.kt)("inlineCode",{parentName:"p"},"()")," at a cost of ",(0,l.kt)("inlineCode",{parentName:"p"},"cost")," (or 140, whichever is higher)."),(0,l.kt)("p",null,"Post-softfork, this also returns ",(0,l.kt)("inlineCode",{parentName:"p"},"()")," at a cost of ",(0,l.kt)("inlineCode",{parentName:"p"},"cost"),", but may also fail if the coin id doesn't match. We can't export the result outside the ",(0,l.kt)("inlineCode",{parentName:"p"},"softfork")," boundary, but we can compare it to something inside and raise if it doesn't match."),(0,l.kt)("p",null,"We take the cost of running the program inside the ",(0,l.kt)("inlineCode",{parentName:"p"},"softfork")," boundary and ensure it exactly matches ",(0,l.kt)("inlineCode",{parentName:"p"},"cost"),", and raise an exception if it's wrong. That way, the program really does have the same cost pre-softfork and post-softfork (or it fails post-softfork)."),(0,l.kt)("h2",{id:"chip-0011-operators"},(0,l.kt)("a",{parentName:"h2",href:"https://github.com/Chia-Network/chips/blob/main/CHIPs/chip-0011.md"},"CHIP-0011")," Operators"),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"These operators will be usable within the ",(0,l.kt)("inlineCode",{parentName:"p"},"softfork")," operator starting at block height 4,510,000."),(0,l.kt)("p",{parentName:"admonition"},"At block height 5,496,000, the operators can be used directly as well.")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Format"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"g1_add"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(g1_add p1 p2 ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Adds two or more G1 points (public keys) together.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"g1_subtract"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(g1_subtract p1 p2 ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Subtracts one or more G1 points (public keys) from a base G1 point.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"g1_multiply"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(g1_multiply p1 p2)")),(0,l.kt)("td",{parentName:"tr",align:null},"Multiplies a G1 point (public key) by a scalar value.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"g1_negate"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(g1_negate point)")),(0,l.kt)("td",{parentName:"tr",align:null},"Negates a G1 point (public key).")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"g2_add"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(g2_add p1 p2 ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Adds two or more G2 points (signatures) together.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"g2_subtract"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(g2_subtract p1 p2 ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Subtracts one or more G2 points (signatures) from a base G2 point.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"g2_multiply"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(g2_multiply p1 p2)")),(0,l.kt)("td",{parentName:"tr",align:null},"Multiplies a G2 point (signature) by a scalar value.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"g2_negate"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(g2_negate point)")),(0,l.kt)("td",{parentName:"tr",align:null},"Negates a G2 point (signature).")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"g1_map"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(g1_map data dst)")),(0,l.kt)("td",{parentName:"tr",align:null},"Hashes the data to a G1 point with sha256 and ExpandMsgXmd. DST is optional.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"g2_map"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(g2_map data dst)")),(0,l.kt)("td",{parentName:"tr",align:null},"Hashes the data to a G2 point with sha256 and ExpandMsgXmd. DST is optional.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bls_pairing_identity"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(bls_pairing_identity g1 g2 ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Returns nil if the pairing of all pairs is the identity, otherwise raises an exception.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bls_verify"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(bls_verify g2 g1 msg ...)")),(0,l.kt)("td",{parentName:"tr",align:null},"Nil if signature g2 is valid with public key g1 and message, otherwise raises an exception.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"coinid"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(coinid parent_id puzzle_hash amount)")),(0,l.kt)("td",{parentName:"tr",align:null},"Validates inputs and calculates the coin id with a parent coin id, puzzle hash, and amount.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"modpow"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(modpow base exponent modulus)")),(0,l.kt)("td",{parentName:"tr",align:null},"Computes ",(0,l.kt)("inlineCode",{parentName:"td"},"(base ^ exponent) % modulus"),". Base may be negative, exponent must not be, modulus must not be 0.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"%"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(% numerator denominator)")),(0,l.kt)("td",{parentName:"tr",align:null},"Computes the remainder of the numerator divided by the denominator.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"secp256k1_verify"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(secp256k1_verify pubkey msg_hash signature)")),(0,l.kt)("td",{parentName:"tr",align:null},"Verifies a signature that uses the secp256k1 curve.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"secp256r1_verify"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(secp256r1_verify pubkey msg_hash signature)")),(0,l.kt)("td",{parentName:"tr",align:null},"Verifies a signature that uses the secp256r1 curve.")))))}N.isMDXComponent=!0}}]);