"use strict";(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[649],{4849:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>c,frontMatter:()=>l,metadata:()=>t,toc:()=>r});const t=JSON.parse('{"id":"primitives/standard-transactions","title":"Standard Transactions","description":"The standard transaction is a puzzle used by the Chia wallet to generate its addresses and spend coins within them. It is also used for CATs and NFTs, which simply wrap the standard transaction inside to enforce ownership by the wallet.","source":"@site/docs/primitives/standard-transactions.md","sourceDirName":"primitives","slug":"/standard-transactions","permalink":"/standard-transactions","draft":false,"unlisted":false,"editUrl":"https://github.com/Chia-Network/chialisp-web/blob/main/docs/primitives/standard-transactions.md","tags":[],"version":"current","frontMatter":{"title":"Standard Transactions","slug":"/standard-transactions"},"sidebar":"someSidebar","previous":{"title":"Debugging","permalink":"/debugging"},"next":{"title":"Singletons","permalink":"/singletons"}}');var s=i(4848),a=i(8453);const l={title:"Standard Transactions",slug:"/standard-transactions"},d=void 0,o={},r=[{value:"Code Examples",id:"code-examples",level:2},{value:"chia-blockchain",id:"chia-blockchain",level:3},{value:"chia-rs",id:"chia-rs",level:3},{value:"chia-wallet-lib",id:"chia-wallet-lib",level:3},{value:"Terminology",id:"terminology",level:2},{value:"Standard Transaction Code",id:"code",level:2},{value:"Delegated Puzzle",id:"delegated-puzzle",level:2},{value:"Hidden Puzzle",id:"hidden-puzzle",level:2},{value:"Default Hidden Puzzle",id:"default-hidden-puzzle",level:3},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"The standard transaction is a puzzle used by the Chia wallet to generate its addresses and spend coins within them. It is also used for CATs and NFTs, which simply wrap the standard transaction inside to enforce ownership by the wallet."}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["Before you read this page, it may be worth checking out this ",(0,s.jsx)(n.a,{href:"https://www.chia.net/2021/05/27/Agrgregated-Sigs-Taproot-Graftroot.html",children:"Agg Sigs, Taproot, and Graftroot blog post"})," by Bram Cohen on why the standard transaction is the way it is."]})}),"\n",(0,s.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,s.jsx)(n.h3,{id:"chia-blockchain",children:"chia-blockchain"}),"\n",(0,s.jsx)(n.p,{children:"The official Chia wallet has a reference implementation for the following in Python:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/e07f9196ffd8fcb6d6e7e9dc9079f2bb9bcfe464/chia/wallet/wallet.py#L421",children:"Spend standard transaction"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"chia-rs",children:"chia-rs"}),"\n",(0,s.jsx)(n.p,{children:"Wallet code can use the following reference methods:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/chia_rs/blob/wallet-dev/chia-primitives/src/primitives/standard_puzzle.rs",children:"Puzzle and solution types"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/chia_rs/blob/2334c842f694444da317fa7432f308f159f62d70/chia-wallet/src/wallet.rs#L1166",children:"Spend standard transaction"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"chia-wallet-lib",children:"chia-wallet-lib"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/node-chia-wallet-lib",children:"Chia wallet library NPM package"})," has the following reference implementation:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/node-chia-wallet-lib/blob/6c8d564538be121079596e492fa0da497c9dd39c/src/types/puzzles/StandardTransaction.ts#L27",children:"Spend standard transaction"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Hidden Puzzle"})," -\nA puzzle that is initially hidden and can be revealed and used as an alternate way to unlock the underlying funds."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Original Public Key"})," - A public key, where knowledge of the corresponding private key represents ownership of the coin."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Synthetic Key Offset"})," - A private key cryptographically generated using the hidden puzzle and ",(0,s.jsx)(n.code,{children:"original_public_key"})," as inputs."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Synthetic Public Key"})," - The public key (curried in) that is the sum of ",(0,s.jsx)(n.code,{children:"original_public_key"})," and the public key corresponding to ",(0,s.jsx)(n.code,{children:"synthetic_key_offset"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Delegated Puzzle"})," - A graftroot puzzle which should return the desired conditions for the spend when executed with its solution."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"})," - The solution to the delegated or hidden puzzle."]}),"\n",(0,s.jsx)(n.h2,{id:"code",children:"Standard Transaction Code"}),"\n",(0,s.jsxs)(n.p,{children:["This is the source code of the standard transaction, which can also be found in the ",(0,s.jsx)(n.code,{children:"chia-blockchain"})," repository in the puzzle ",(0,s.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/fad414132e6950e79e805629427af76bf9ddcbc5/chia/wallet/puzzles/p2_delegated_puzzle_or_hidden_puzzle.clvm",children:(0,s.jsx)(n.code,{children:"p2_delegated_puzzle_or_hidden_puzzle.clvm"})}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-chialisp",metastring:'title="p2_delegated_puzzle_or_hidden_puzzle.clvm"',children:'(mod\n    ; A puzzle should commit to `SYNTHETIC_PUBLIC_KEY`\n    ;\n    ; The solution should pass in 0 for `original_public_key` if it wants to use\n    ; an arbitrary `delegated_puzzle` (and `solution`) signed by the\n    ; `SYNTHETIC_PUBLIC_KEY` (whose corresponding private key can be calculated\n    ; if you know the private key for `original_public_key`)\n    ;\n    ; Or you can solve the hidden puzzle by revealing the `original_public_key`,\n    ; the hidden puzzle in `delegated_puzzle`, and a solution to the hidden puzzle.\n\n    (SYNTHETIC_PUBLIC_KEY original_public_key delegated_puzzle solution)\n\n    ; "assert" is a macro that wraps repeated instances of "if"\n    ; usage: (assert A0 A1 ... An R)\n    ; all of A0, A1, ... An must evaluate to non-null, or an exception is raised\n    ; return the value of R (if we get that far)\n\n    (defmacro assert items\n        (if (r items)\n            (list if (f items) (c assert (r items)) (q . (x)))\n            (f items)\n        )\n    )\n\n    (include condition_codes.clvm)\n\n    ;; hash a tree\n    ;; This is used to calculate a puzzle hash given a puzzle program.\n    (defun sha256tree1\n           (TREE)\n           (if (l TREE)\n               (sha256 2 (sha256tree1 (f TREE)) (sha256tree1 (r TREE)))\n               (sha256 1 TREE)\n           )\n    )\n\n    ; "is_hidden_puzzle_correct" returns true iff the hidden puzzle is correctly encoded\n\n    (defun-inline is_hidden_puzzle_correct (SYNTHETIC_PUBLIC_KEY original_public_key delegated_puzzle)\n      (=\n          SYNTHETIC_PUBLIC_KEY\n          (point_add\n              original_public_key\n              (pubkey_for_exp (sha256 original_public_key (sha256tree1 delegated_puzzle)))\n          )\n      )\n    )\n\n    ; "possibly_prepend_aggsig" is the main entry point\n\n    (defun-inline possibly_prepend_aggsig (SYNTHETIC_PUBLIC_KEY original_public_key delegated_puzzle conditions)\n      (if original_public_key\n          (assert\n              (is_hidden_puzzle_correct SYNTHETIC_PUBLIC_KEY original_public_key delegated_puzzle)\n              conditions\n          )\n          (c (list AGG_SIG_ME SYNTHETIC_PUBLIC_KEY (sha256tree1 delegated_puzzle)) conditions)\n      )\n    )\n\n    ; main entry point\n\n    (possibly_prepend_aggsig\n        SYNTHETIC_PUBLIC_KEY original_public_key delegated_puzzle\n        (a delegated_puzzle solution))\n)\n'})}),"\n",(0,s.jsx)(n.p,{children:"That's probably a lot to digest so let's break it down piece by piece.\nFirst, let's talk about the arguments:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-chialisp",children:"(SYNTHETIC_PUBLIC_KEY original_public_key delegated_puzzle solution)\n"})}),"\n",(0,s.jsx)(n.p,{children:"All of these terms are defined above.\nWhen we solve this puzzle:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SYNTHETIC_PUBLIC_KEY"})," is curried in"]}),"\n",(0,s.jsxs)(n.li,{children:["We pass in ",(0,s.jsx)(n.code,{children:"original_public_key"})," if it's the hidden spend or ",(0,s.jsx)(n.code,{children:"()"})," if it's the delegated spend"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"delegated_puzzle"})," is the hidden puzzle if it's the hidden spend, or the delegated puzzle if it's the delegated spend"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"solution"})," is the solution to whatever is passed into ",(0,s.jsx)(n.code,{children:"delegated_puzzle"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"As with most Chialisp programs, we'll start looking at the implementation from the bottom:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-chialisp",children:"(possibly_prepend_aggsig\n    SYNTHETIC_PUBLIC_KEY original_public_key delegated_puzzle\n    (a delegated_puzzle solution))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["There's nothing much going on here, we're mostly just passing arguments to ",(0,s.jsx)(n.code,{children:"possibly_prepend_aggsig"})," to start the program.\nThe only thing to note is that we're evaluating the delegated puzzle with the solution before passing it in.\nThis will result in a list of conditions that we will output as long as the rest of the puzzle checks out."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-chialisp",children:"(defun-inline possibly_prepend_aggsig (SYNTHETIC_PUBLIC_KEY original_public_key delegated_puzzle conditions)\n  (if original_public_key\n      (assert\n          (is_hidden_puzzle_correct SYNTHETIC_PUBLIC_KEY original_public_key delegated_puzzle) ; hidden case\n          conditions\n      )\n      (c (list AGG_SIG_ME SYNTHETIC_PUBLIC_KEY (sha256tree delegated_puzzle)) conditions) ; delegated case\n  )\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:['This function is the main control flow logic that determines whether we\'re doing the "hidden" or "delegated" spend.\nThe first line just checks if an ',(0,s.jsx)(n.code,{children:"original_public_key"})," was passed in.\nIn the delegated spend, we pass ",(0,s.jsx)(n.code,{children:"()"})," for that argument, and since that evaluates to false, it works great as a switch to determine what we're doing."]}),"\n",(0,s.jsxs)(n.p,{children:["If the spend is the hidden spend, we pass most of our parameters to ",(0,s.jsx)(n.code,{children:"is_hidden_puzzle_correct"})," and, as long as it doesn't fail, we just return whatever conditions are given to us.\nIf the spend is the delegated spend, we prepend a signature requirement from the curried in public key on the hash of the delegated puzzle."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-chialisp",children:"(defun-inline is_hidden_puzzle_correct (SYNTHETIC_PUBLIC_KEY original_public_key delegated_puzzle)\n  (=\n      SYNTHETIC_PUBLIC_KEY\n      (point_add\n          original_public_key\n          (pubkey_for_exp (sha256 original_public_key (sha256tree delegated_puzzle)))\n      )\n  )\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is the Chialisp representation of what was explained in the section above.\nA private key is any 32 bytes so we're going to use ",(0,s.jsx)(n.code,{children:"sha256"})," (whose output is 32 bytes) to make sure our private key is derived from the ",(0,s.jsx)(n.code,{children:"original_public_key"})," and the hash of the hidden puzzle.\nWe pass the resulting hash to ",(0,s.jsx)(n.code,{children:"pubkey_for_exp"})," which turns our private key into a public key.\nThen, we ",(0,s.jsx)(n.code,{children:"point_add"})," this generated public key to our original pubkey to get our synthetic public key.\nIf it equals the curried in one, this function passes, otherwise it returns ",(0,s.jsx)(n.code,{children:"()"})," and the ",(0,s.jsx)(n.code,{children:"assert"})," from the previous function raises."]}),"\n",(0,s.jsx)(n.h2,{id:"delegated-puzzle",children:"Delegated Puzzle"}),"\n",(0,s.jsx)(n.p,{children:"A delegated puzzle is pretty simple. It allows the solver to specify the puzzle and solution they would like to run when the coin is spent, rather than when the coin is created. This creates the most flexibility, but additional measures need to be taken to make it secure. In the case of the standard transaction, a signature is required to spend the coin."}),"\n",(0,s.jsx)(n.p,{children:"The output of the delegated puzzle may include things such as creating a coin, adding announcements to interact with other spends, and reserving fees."}),"\n",(0,s.jsx)(n.h2,{id:"hidden-puzzle",children:"Hidden Puzzle"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"The hidden puzzle functionality is not used by the official wallet. It is there to allow for future functionality as needed."})}),"\n",(0,s.jsx)(n.p,{children:"We also want the ability to pre-commit to a puzzle without revealing it, and let anybody with the knowledge of that hidden puzzle spend it."}),"\n",(0,s.jsx)(n.p,{children:"If this hidden puzzle were to be curried it in, any spend (even the delegated spend case) would reveal the full puzzle including the hidden puzzle. This would defeat the purpose, as it would no longer be hidden. Because of this, we wouldn't be able to lock up a coin with the same puzzle anymore, or people would be able to tell that the puzzle hash is the same and spend it without our consent. Additionally, our delegated spend might not even make it to the network. A malicious node could just deny our transaction after seeing it, then publish the hidden spend case on their own."}),"\n",(0,s.jsx)(n.p,{children:"We can attempt to solve this problem by hashing the hidden puzzle. However, this has a similar problem in that if you spend the hidden case even once, people could see any identical puzzle hashes later and spend them without your consent. Furthermore, people may try to use the same hidden puzzle. If anyone reveals it, all coins locked up with that same puzzle can also be identified and spent."}),"\n",(0,s.jsx)(n.p,{children:"We need the puzzle to be hidden, but also have some entropy that keeps it unique to us."}),"\n",(0,s.jsx)(n.p,{children:"The solution that the standard transaction uses is to derive a new private key from the hidden puzzle and the public key that can sign for the delegated spend case."}),"\n",(0,s.jsxs)(n.p,{children:["This is known as the ",(0,s.jsx)(n.code,{children:"synthetic_offset"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"synthetic_offset = sha256(original_public_key + hidden_puzzle_hash);\n"})}),"\n",(0,s.jsx)(n.p,{children:"We then calculate the public key of this new private key, and add it to our existing original public key."}),"\n",(0,s.jsxs)(n.p,{children:["This is known as the ",(0,s.jsx)(n.code,{children:"synthetic_public_key"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"synthetic_public_key = original_public_key + synthetic_offset_pubkey\n"})}),"\n",(0,s.jsx)(n.p,{children:"If the solver can correctly reveal both the hidden puzzle and the original public key, then our puzzle can derive the synthetic public key and make sure that it matches the one that is curried in."}),"\n",(0,s.jsx)(n.p,{children:"You may wonder why we add the public key from our derived private key to the original public key when it's already part of the derivation. This is because we use the synthetic public key to verify the signature of our delegated spends as well."}),"\n",(0,s.jsx)(n.p,{children:"When you add two public keys, the sum of their private keys gives the private key for the resulting public key.\nIf we didn't add the original public key then anyone who knew the hidden puzzle could derive the synthetic private key and could then perform delegated spends! Adding the original public key ensures that there is still a secret component of the synthetic private key, even though half of it can be known."}),"\n",(0,s.jsx)(n.p,{children:"This secret component is the private key for the original public key."}),"\n",(0,s.jsx)(n.p,{children:"This technique is also neat because it allows us to hide the hidden puzzle in a piece of information that was already necessary for the delegated spend. It's impossible to guess what the hidden puzzle is, even if it's a standard hidden puzzle. It's even hard to tell if there's a hidden puzzle at all. All of this can contribute to the overall privacy."}),"\n",(0,s.jsxs)(n.p,{children:["For example, if two parties agree to lock up some coins with a hidden puzzle together, you can share pubkeys and verify that information on the blockchain without revealing anything to the network. Then, if you both agree that the coins ",(0,s.jsx)(n.em,{children:"can"})," be spent with the hidden puzzle if either party is dishonest, you can trustlessly delegated spend the coins to the correct destinations and it's impossible to tell that they are not just normal everyday spends."]}),"\n",(0,s.jsx)(n.h3,{id:"default-hidden-puzzle",children:"Default Hidden Puzzle"}),"\n",(0,s.jsx)(n.p,{children:"This is the default hidden puzzle, used when calculating the synthetic public key for normal addresses:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-chialisp",children:"(=)\n"})}),"\n",(0,s.jsx)(n.p,{children:"This program will always terminate, which effectively means the delegated spend is the only way to spend standard coins created by the wallet."}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(n.p,{children:["Almost every coin on the Chia blockchain uses this primitive (or as an inner puzzle). When you use the official Chia wallet software, it is crawling the blockchain looking for coins locked up with this specific format. The ",(0,s.jsx)(n.code,{children:"SYNTHETIC_PUBLIC_KEY"})," it is looking for is actually using a hidden puzzle of ",(0,s.jsx)(n.code,{children:"(=)"})," which is obviously invalid and fails immediately. This is because most users of Chia don't need the hidden puzzle functionality for vanilla transactions. But by having the capabilities built in, it enables much cooler functionality later on. This puzzle also makes for a fantastic inner puzzle of any smart coins you may write."]})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>d});var t=i(6540);const s={},a=t.createContext(s);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);