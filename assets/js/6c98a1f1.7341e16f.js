"use strict";(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[124],{8039:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"primitives/singletons","title":"Singletons","description":"Singletons allow you to keep track of the state of something on the blockchain, with the ability to verify and check any part of its history using a unique id. It proves that the puzzle is unique and cannot be duplicated. Singletons can use any arbitrary inner puzzle, and is used to make NFTs, DIDs, the pooling puzzle, and many other things possible.","source":"@site/docs/primitives/singletons.md","sourceDirName":"primitives","slug":"/singletons","permalink":"/singletons","draft":false,"unlisted":false,"editUrl":"https://github.com/Chia-Network/chialisp-web/blob/main/docs/primitives/singletons.md","tags":[],"version":"current","frontMatter":{"title":"Singletons","slug":"/singletons"},"sidebar":"someSidebar","previous":{"title":"Standard Transactions","permalink":"/standard-transactions"},"next":{"title":"CATs","permalink":"/cats"}}');var o=t(4848),s=t(8453);const a={title:"Singletons",slug:"/singletons"},l=void 0,h={},r=[{value:"Code Examples",id:"code-examples",level:2},{value:"chia-blockchain",id:"chia-blockchain",level:3},{value:"chia-rs",id:"chia-rs",level:3},{value:"Singleton Code",id:"code",level:2},{value:"Design Decisions",id:"design-decisions",level:2},{value:"Singleton amount is odd",id:"odd",level:4},{value:"Odd child is wrapped",id:"wrapped",level:4},{value:"Melt condition determines wrapping",id:"melt",level:4},{value:"Launcher",id:"launcher",level:2},{value:"Pay to Singleton",id:"pay-to-singleton",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Singletons allow you to keep track of the state of something on the blockchain, with the ability to verify and check any part of its history using a unique id. It proves that the puzzle is unique and cannot be duplicated. Singletons can use any arbitrary inner puzzle, and is used to make NFTs, DIDs, the pooling puzzle, and many other things possible."}),"\n",(0,o.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,o.jsx)(n.h3,{id:"chia-blockchain",children:"chia-blockchain"}),"\n",(0,o.jsx)(n.p,{children:"The official Chia wallet has a reference implementation for the following in Python:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/e07f9196ffd8fcb6d6e7e9dc9079f2bb9bcfe464/chia/wallet/nft_wallet/nft_wallet.py#L777",children:"Create singleton solution"})}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"chia-rs",children:"chia-rs"}),"\n",(0,o.jsx)(n.p,{children:"Wallet code can use the following reference methods:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://github.com/Chia-Network/chia_rs/blob/wallet-dev/chia-primitives/src/primitives/singleton.rs",children:"Puzzle and solution types"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://github.com/Chia-Network/chia_rs/blob/2334c842f694444da317fa7432f308f159f62d70/chia-wallet/src/wallet.rs#L1130",children:"Create singleton solution"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"code",children:"Singleton Code"}),"\n",(0,o.jsxs)(n.p,{children:["This is the source code of the singleton, which can also be found in the chia-blockchain repository in the puzzle ",(0,o.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/8b70466a70388d0fff437d138192ba38faf92be8/chia/wallet/puzzles/singleton_top_layer_v1_1.clvm",children:(0,o.jsx)(n.code,{children:"singleton_top_layer_v1_1.clvm"})}),"."]}),"\n",(0,o.jsx)(n.p,{children:"An explanation is provided within the dropdown:"}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Expand Singleton Puzzle"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-chialisp",metastring:'title="singleton_top_layer_v1_1.clvm"',children:"(mod (SINGLETON_STRUCT INNER_PUZZLE lineage_proof my_amount inner_solution)\n\n;; SINGLETON_STRUCT = (MOD_HASH . (LAUNCHER_ID . LAUNCHER_PUZZLE_HASH))\n\n; SINGLETON_STRUCT, INNER_PUZZLE are curried in by the wallet\n\n; EXAMPLE SOLUTION '(0xfadeddab 0xdeadbeef 1 (0xdeadbeef 200) 50 ((51 0xfadeddab 100) (60 \"trash\") (51 deadbeef 0)))'\n\n\n; This puzzle is a wrapper around an inner smart puzzle which guarantees uniqueness.\n; It takes its singleton identity from a coin with a launcher puzzle which guarantees that it is unique.\n\n  (include condition_codes.clvm)\n  (include curry-and-treehash.clinc)  ; also imports the constant ONE == 1\n  (include singleton_truths.clib)\n  (include utility_macros.clib)\n\n  (defun-inline mod_hash_for_singleton_struct (SINGLETON_STRUCT) (f SINGLETON_STRUCT))\n  (defun-inline launcher_id_for_singleton_struct (SINGLETON_STRUCT) (f (r SINGLETON_STRUCT)))\n  (defun-inline launcher_puzzle_hash_for_singleton_struct (SINGLETON_STRUCT) (r (r SINGLETON_STRUCT)))\n\n  ;; return the full puzzlehash for a singleton with the innerpuzzle curried in\n  ; puzzle-hash-of-curried-function is imported from curry-and-treehash.clinc\n  (defun-inline calculate_full_puzzle_hash (SINGLETON_STRUCT inner_puzzle_hash)\n     (puzzle-hash-of-curried-function (mod_hash_for_singleton_struct SINGLETON_STRUCT)\n                                      inner_puzzle_hash\n                                      (sha256tree SINGLETON_STRUCT)\n     )\n  )\n\n  (defun-inline morph_condition (condition SINGLETON_STRUCT)\n    (c (f condition) (c (calculate_full_puzzle_hash SINGLETON_STRUCT (f (r condition))) (r (r condition))))\n  )\n\n  (defun is_odd_create_coin (condition)\n    (and (= (f condition) CREATE_COIN) (logand (f (r (r condition))) 1))\n  )\n\n  ; Assert exactly one output with odd value exists - ignore it if value is -113\n\n  ;; this function iterates over the output conditions from the inner puzzle & solution\n  ;; and both checks that exactly one unique singleton child is created (with odd valued output),\n  ;; and wraps the inner puzzle with this same singleton wrapper puzzle\n  ;;\n  ;; The special case where the output value is -113 means a child singleton is intentionally\n  ;; *NOT* being created, thus forever ending this singleton's existence\n\n  (defun check_and_morph_conditions_for_singleton (SINGLETON_STRUCT conditions has_odd_output_been_found)\n    (if conditions\n        ; check if it's an odd create coin\n        (if (is_odd_create_coin (f conditions))\n            ; check that we haven't already found one\n            (assert (not has_odd_output_been_found)\n              ; then\n              (if (= (f (r (r (f conditions)))) -113)\n                  ; If it's the melt condition we don't bother prepending this condition\n                  (check_and_morph_conditions_for_singleton SINGLETON_STRUCT (r conditions) ONE)\n                  ; If it isn't the melt condition, we morph it and prepend it\n                  (c (morph_condition (f conditions) SINGLETON_STRUCT) (check_and_morph_conditions_for_singleton SINGLETON_STRUCT (r conditions) ONE))\n              )\n            )\n            (c (f conditions) (check_and_morph_conditions_for_singleton SINGLETON_STRUCT (r conditions) has_odd_output_been_found))\n        )\n        (assert has_odd_output_been_found ())\n    )\n   )\n\n ; assert that either the lineage proof is for a parent singleton, or, if it's for the launcher, verify it matched our launcher ID\n ; then return a condition asserting it actually is our parent ID\n (defun verify_lineage_proof (SINGLETON_STRUCT parent_id is_not_launcher)\n    (assert (any is_not_launcher (= parent_id (launcher_id_for_singleton_struct SINGLETON_STRUCT)))\n      ; then\n      (list ASSERT_MY_PARENT_ID parent_id)\n    )\n )\n\n  ; main\n\n  ; if our value is not an odd amount then we are invalid\n  (assert (logand my_amount ONE)\n    ; then\n    (c\n      (list ASSERT_MY_AMOUNT my_amount)\n      (c\n        ; Verify the lineage proof by asserting our parent's ID\n        (verify_lineage_proof\n          SINGLETON_STRUCT\n          ; calculate our parent's ID\n          (calculate_coin_id\n            (parent_info_for_lineage_proof lineage_proof)\n            (if (is_not_eve_proof lineage_proof)  ; The PH calculation changes based on the lineage proof\n              (calculate_full_puzzle_hash SINGLETON_STRUCT (puzzle_hash_for_lineage_proof lineage_proof))  ; wrap the innerpuz in a singleton\n              (launcher_puzzle_hash_for_singleton_struct SINGLETON_STRUCT) ; Use the static launcher puzzle hash\n            )\n            (if (is_not_eve_proof lineage_proof)  ; The position of \"amount\" changes based on the type on lineage proof\n              (amount_for_lineage_proof lineage_proof)\n              (amount_for_eve_proof lineage_proof)\n            )\n          )\n          (is_not_eve_proof lineage_proof)\n        )\n        ; finally check all of the conditions for a single odd output to wrap\n        (check_and_morph_conditions_for_singleton SINGLETON_STRUCT (a INNER_PUZZLE inner_solution) 0)\n      )\n    )\n  )\n)\n"})}),(0,o.jsx)(n.p,{children:"Quite a bit isn't it? Let's start with the arguments:"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-chialisp",children:"(\n  SINGLETON_STRUCT\n  INNER_PUZZLE\n  lineage_proof\n  my_amount\n  inner_solution\n)\n"})}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"SINGLETON_STRUCT"})," is a collection of three things:"]}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The tree hash of this module"}),"\n",(0,o.jsx)(n.li,{children:"The launcher coin id (this acts as the unique id for the singleton)"}),"\n",(0,o.jsx)(n.li,{children:"The launcher puzzle hash"}),"\n"]}),(0,o.jsx)(n.p,{children:"The reason they are grouped into a single structure is because they are passed through almost every function. It increases readability and optimization if they are passed through as a single variable until it is time to deconstruct them."}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"INNER_PUZZLE"})," is the inner puzzle to this wrapper puzzle."]}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"lineage_proof"})," takes one of two formats:"]}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"(parent_parent_coin_info parent_inner_puzzle_hash parent_amount)"})}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"(parent_parent_coin_info parent_amount)"}),"\nYou may wonder, given the similarity, why not just use the first format? We use the separate formats because we use the length of the structure to tip us off to whether or not this is the ",(0,o.jsx)(n.strong,{children:"eve spend"}),".\nThe eve spend is the first spend of a singleton after its creation.\nWe use this lineage proof to verify that our parent was a singleton.\nHowever, in the first spend, the parent is not a singleton and we actually execute a different path where we verify that our parent was a singleton launcher instead."]}),"\n"]}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"my_amount"})," is the amount of the coin being spent and will be asserted implicitly through ASSERT_MY_COIN_ID."]}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"inner_solution"})," is the solution the to inner puzzle."]}),(0,o.jsx)(n.p,{children:"Next, let's look at our main entry point:"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-chialisp",children:"(if (logand my_amount 1)\n  (stager_one SINGLETON_STRUCT lineage_proof (sha256tree INNER_PUZZLE) my_amount INNER_PUZZLE inner_solution)\n  (x)\n)\n"})}),(0,o.jsx)(n.p,{children:"The control flow here is very simple.\nIf we're not odd, we raise, if we are, we pass everything through to the next stage (with the additional hash of the inner puzzle).\nOne small thing to note is that a singleton can actually be even, but it will never be able to be spent.\nEither the person will pass in the true amount and the puzzle will raise, or they will pass in a phony amount and the ASSERT_MY_ID will fail. If an attacker were to launch an even singleton or create one as one the even children of the singleton, it would succeed, but be stuck forever."}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-chialisp",children:"(defun stager_one (SINGLETON_STRUCT lineage_proof my_innerpuzhash my_amount INNER_PUZZLE inner_solution)\n  (stager_two SINGLETON_STRUCT lineage_proof (calculate_full_puzzle_hash SINGLETON_STRUCT my_innerpuzhash) my_innerpuzhash my_amount INNER_PUZZLE inner_solution)\n)\n"})}),(0,o.jsx)(n.p,{children:'We now move on to the first of a few "stagers". The purpose of these functions is to calculate values that are used multiple times only once.\nIn the next stage we use our full puzzle hash three times so it\'s best to calculate it once and pass it to the next function instead.'}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-chialisp",children:"(defun stager_two (SINGLETON_STRUCT lineage_proof full_puzhash innerpuzhash my_amount INNER_PUZZLE inner_solution)\n  (stager_three\n    SINGLETON_STRUCT\n    lineage_proof\n    (if (is_not_eve_proof lineage_proof)\n        (create_my_ID\n          SINGLETON_STRUCT\n          full_puzhash\n          (parent_info_for_lineage_proof lineage_proof)\n          (puzzle_hash_for_lineage_proof lineage_proof)\n          (amount_for_lineage_proof lineage_proof)\n          my_amount\n        )\n        (if (=\n              (launcher_id_for_singleton_struct SINGLETON_STRUCT)\n              (sha256 (parent_info_for_eve_proof lineage_proof) (launcher_puzzle_hash_for_singleton_struct SINGLETON_STRUCT) (amount_for_eve_proof lineage_proof))\n            )\n            (sha256 (launcher_id_for_singleton_struct SINGLETON_STRUCT) full_puzhash my_amount)\n            (x)\n        )\n    )\n    full_puzhash\n    innerpuzhash\n    my_amount\n    INNER_PUZZLE\n    inner_solution\n  )\n)\n"})}),(0,o.jsxs)(n.p,{children:["This stage looks like a lot, but really all it's doing is calculating the current coin id for the next function to use.\nNote before we start looking at it that the lineage proof is frequently being passed to functions that are not part of this file.\nThese are part of the ",(0,o.jsx)(n.code,{children:"singleton_truths.clib"})," library which we will discuss in the next stage.\nFor now, just know that it is accessing the correct values from the lineage proof and is a lot cleaner than writing things like ",(0,o.jsx)(n.code,{children:"(f (r lineage_proof)) (f (r (r lineage_proof)))"})," with no indication of what they mean."]}),(0,o.jsxs)(n.p,{children:["The first if statement checks if ",(0,o.jsx)(n.code,{children:"lineage_proof"})," indicates that this is not the eve spend (three proof elements instead of two).\nIf it is not the eve spend, it calculates our id using the information in the ",(0,o.jsx)(n.code,{children:"lineage_proof"})," to generate our parent id."]}),(0,o.jsxs)(n.p,{children:["If it ",(0,o.jsx)(n.em,{children:"is"})," the eve spend, there is an extra check which verifies that the launcher id and launcher puzzle hash we have (both inside the ",(0,o.jsx)(n.code,{children:"SINGLETON_STRUCT"}),') are correct. We do so by calculating the launcher id from information in our lineage proof and the launcher puzzle hash.\nWe then assert that it is equal to the curried in value.\nThis is an extremely important step because it ensures that every singleton after this singleton can trust the launcher id and puzzle hash since it will be forcefully curried in from this "eve" singleton and every child singleton knows that the eve singleton checked it.']}),(0,o.jsxs)(n.p,{children:["After the eve singleton has verified the launcher info, it can now trust the launcher id as its parent id and create its own id by hashing in the ",(0,o.jsx)(n.code,{children:"full_puzhash"})," from the last stage and ",(0,o.jsx)(n.code,{children:"my_amount"}),'.\nLet\'s talk about the final "stager":']}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-chialisp",children:"(defun stager_three (SINGLETON_STRUCT lineage_proof my_id full_puzhash innerpuzhash my_amount INNER_PUZZLE inner_solution)\n  (c (list ASSERT_MY_COIN_ID my_id) (check_and_morph_conditions_for_singleton SINGLETON_STRUCT (a INNER_PUZZLE (c (truth_data_to_truth_struct my_id full_puzhash innerpuzhash my_amount lineage_proof SINGLETON_STRUCT) inner_solution)) 0))\n)\n"})}),(0,o.jsxs)(n.p,{children:["This stage is where the conditions will end up coming out of.\nFirst, it prepends an ",(0,o.jsx)(n.code,{children:"ASSERT_MY_COIN_ID"})," so that all of the solution values we have been assuming to be true up until this point are implicitly asserted by the network.\nWe prepend this condition to the output of ",(0,o.jsx)(n.code,{children:"check_and_morph_conditions_for_singleton"})," which will take the output from the inner puzzle and check for singleton specific things (only one odd output, wrap the child singleton, etc.)"]}),(0,o.jsxs)(n.p,{children:["Notice that we are prepending something to the solution before we use it to solve the inner puzzle.\nWe are using a function from ",(0,o.jsx)(n.code,{children:"singleton_truths.clib"})," that takes all of the listed information and combines it into a single structure to pass to the inner puzzle.\nThis allows the inner puzzle to use information that the singleton has already calculated and verified in its own puzzle at almost no additional cost!"]}),(0,o.jsxs)(n.p,{children:["Keep in mind that this means an inner puzzle needs to know that it is going inside a singleton or else all of its solution arguments will be shifted to the right.\nAn existing inner puzzle can be very easily adapted, however, to fit inside a singleton using a shallow outer layer of: ",(0,o.jsx)(n.code,{children:"(a (q . INNER_PUZZLE) (r 1))"})," which strips off the first value of the solution before solving the inner puzzle."]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-chialisp",children:"(defun check_and_morph_conditions_for_singleton (SINGLETON_STRUCT conditions has_odd_output_been_found)\n  (if conditions\n    (morph_next_condition SINGLETON_STRUCT conditions has_odd_output_been_found (odd_cons_m113 (created_coin_value_or_0 (f conditions))))\n    (if has_odd_output_been_found\n        0\n        (x)  ;; no odd output found\n    )\n  )\n)\n\n(defun morph_next_condition (SINGLETON_STRUCT conditions has_odd_output_been_found (is_output_odd . is_output_m113))\n   (assert\n      (not (all is_output_odd has_odd_output_been_found))\n      (strip_first_condition_if\n         is_output_m113\n         (c (if is_output_odd\n                (morph_condition (f conditions) SINGLETON_STRUCT)\n                (f conditions)\n            )\n            (check_and_morph_conditions_for_singleton SINGLETON_STRUCT (r conditions) (any is_output_odd has_odd_output_been_found))\n         )\n      )\n  )\n)\n"})}),(0,o.jsxs)(n.p,{children:["This section is a bit unique in that it recurses by handing values back and forth to each other.\nOur main entry point is through the first block: ",(0,o.jsx)(n.code,{children:"check_and_morph_conditions_for_singleton"})," which checks first if we still have conditions.\nIf we don't, we check to see if the ",(0,o.jsx)(n.code,{children:"has_odd_output_been_found"})," flag has been set and raise if it hasn't been."]}),(0,o.jsxs)(n.p,{children:["If we do have remaining conditions, we pass them to the next function along with the results of checking the first condition to see if it is a ",(0,o.jsx)(n.code,{children:"CREATE_COIN"})," whose output is odd or the melt value."]}),(0,o.jsxs)(n.p,{children:["In ",(0,o.jsx)(n.code,{children:"morph_next_condition"})," we first assert that we have not found a second odd output.\nIf we have, we raise.\nIf we have not already run into an odd output, we head to a rather confusing section of the control flow.\nThe outermost function call essentially waits for the final recursive output and strips out the melt condition if it was found.\nThat recursive output is generated by taking the first condition, wrapping it in a singleton outer puzzle if it's odd, and then passing the rest of the conditions back to ",(0,o.jsx)(n.code,{children:"check_and_morph_conditions_for_singleton"})," with the ",(0,o.jsx)(n.code,{children:"has_odd_output_been_found"})," flag set if relevant."]})]}),"\n",(0,o.jsx)(n.h2,{id:"design-decisions",children:"Design Decisions"}),"\n",(0,o.jsx)(n.h4,{id:"odd",children:"Singleton amount is odd"}),"\n",(0,o.jsx)(n.p,{children:"In order to assure that a singleton does not duplicate itself, it needs some way to verify that its children do not consist of more than one new singleton. It does this by verifying that only one of its children is odd. It can either be the new singleton coin or the value to be melted. It's odd so that you can output other non-singleton coins that are multiples of 10, such as a full XCH."}),"\n",(0,o.jsx)(n.h4,{id:"wrapped",children:"Odd child is wrapped"}),"\n",(0,o.jsx)(n.p,{children:"This abstracts some of the singleton functionality away from the inner puzzles. If an inner puzzle creates an odd coin, it doesn't have to worry about making it a singleton. It also prevents an inner puzzle from accidentally melting the singleton by forgetting to wrap its output."}),"\n",(0,o.jsx)(n.h4,{id:"melt",children:"Melt condition determines wrapping"}),"\n",(0,o.jsxs)(n.p,{children:["If you would like to melt a singleton and use its amount to create a new coin, you need to output a ",(0,o.jsx)(n.code,{children:"CREATE_COIN"})," condition that uses the amount ",(0,o.jsx)(n.code,{children:"-113"}),". When the singleton outer puzzle sees that condition, it filters it out."]}),"\n",(0,o.jsx)(n.h2,{id:"launcher",children:"Launcher"}),"\n",(0,o.jsx)(n.p,{children:"The singleton launcher is used to ensure only one is created with the same id, since usually any coin could create the singleton, or multiple thereof. It does exactly one thing, which is creating a single singleton."}),"\n",(0,o.jsx)(n.p,{children:"Additionally, the singleton's id is used for referencing it, as well as any metadata associated with it that is stored and can't be changed later."}),"\n",(0,o.jsxs)(n.p,{children:["This is the source code, which can also be found in the chia-blockchain repository in the puzzle ",(0,o.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/fad414132e6950e79e805629427af76bf9ddcbc5/chia/wallet/puzzles/singleton_launcher.clvm",children:(0,o.jsx)(n.code,{children:"singleton_launcher.clvm"})}),"."]}),"\n",(0,o.jsx)(n.p,{children:"An explanation is provided within the dropdown:"}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Singleton Launcher"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-chialisp",metastring:'title="singleton_launcher.clvm"',children:"(mod (singleton_full_puzzle_hash amount key_value_list)\n\n(include condition_codes.clvm)\n\n; takes a lisp tree and returns the hash of it\n(defun sha256tree1 (TREE)\n(if (l TREE)\n(sha256 2 (sha256tree1 (f TREE)) (sha256tree1 (r TREE)))\n(sha256 1 TREE)\n)\n)\n\n; main\n(list (list CREATE_COIN singleton_full_puzzle_hash amount)\n(list CREATE_COIN_ANNOUNCEMENT (sha256tree1 (list singleton_full_puzzle_hash amount key_value_list))))\n)\n\n"})}),(0,o.jsx)(n.p,{children:"Essentially two lines, so not too bad right? One of the first things you may notice is that we don't curry anything in.\nWe actually cannot curry anything in because we want this puzzle hash to be constant among all singletons.\nThat way, even if someone isn't familiar with us, they know that if we came from this specific launcher puzzle hash, we can be trusted to be a unique singleton."}),(0,o.jsxs)(n.p,{children:["For the most part, you simply put in ",(0,o.jsx)(n.code,{children:"CREATE_COIN"})," parameters and the puzzle creates the singleton for you.\nThe tricky part is the announcement creation.\nSince these parameters are not curried in, we somehow need them to be immune from the manipulations of malicious full nodes.\nWe cannot curry in a pubkey to sign them, or else our puzzle hash is no longer static. Our solution to this conundrum is to create an announcement from this puzzle that its parent asserts in the same block.\nUsually, the parent is going to be a standard coin. In the standard coin, we sign the puzzle that makes the conditions.\nIf we create an ",(0,o.jsx)(n.code,{children:"ASSERT_COIN_ANNOUNCEMENT"})," condition, we implicitly sign that too. That means we can implicitly sign all of the launcher solution values through asserting this announcement.\nIf any of those values are changed, the coin that creates the launcher will fail and thus the launcher will never be created!"]}),(0,o.jsxs)(n.p,{children:["The last thing to note is the seemingly useless ",(0,o.jsx)(n.code,{children:"key_value_list"})," that is passed in as an argument and announced.\nThe purpose for this is to communicate information to blockchain observers.\nSometimes you want to be able to know information about a puzzle before it is revealed.\nThe only way we can get this information on chain is from the parent's puzzle reveal so sometimes it is useful to have useless parameters be part of the solution in order to make it easier to follow the puzzle's on chain state.\nRemember that you pay cost for every byte though so keep it concise."]})]}),"\n",(0,o.jsx)(n.p,{children:"This launcher puzzle hash (which is the same for all singletons) is curried into the singleton, which then asserts that it came from a parent whose puzzle hash matches the launcher. This prevents it from being falsified, and can be verified without crawling back up to the original coin."}),"\n",(0,o.jsx)(n.p,{children:"In addition to creating the singleton, the launcher announces the tree hash of its solution, effectively ensuring that they are signed and cannot be tampered with by malicious full nodes. The reason this works is that the parent (which has a signature) asserts as being valid in the same block. If any of the values change, the parent of the launcher coin will fail, and thus it will never create the singleton."}),"\n",(0,o.jsx)(n.h2,{id:"pay-to-singleton",children:"Pay to Singleton"}),"\n",(0,o.jsx)(n.p,{children:"Now that you understand how a singleton functions, we can now look at an example of paying to a singleton (locking up a coin in such a way that only the owner of a specific singleton can unlock it)."}),"\n",(0,o.jsx)(n.p,{children:"The idea is that you curry in the necessary information to calculate the singleton's puzzle hash and then assert an announcement from the singleton that says that it is time to claim the funds locked up in the puzzle. Since the puzzle hash will be unique to that singleton (due to the launcher id being curried in), only that singleton will be able to create the appropriate announcement."}),"\n",(0,o.jsxs)(n.p,{children:["This is the source code, which can also be found in the chia-blockchain repository in the puzzle ",(0,o.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/fad414132e6950e79e805629427af76bf9ddcbc5/chia/wallet/puzzles/p2_singleton.clvm",children:(0,o.jsx)(n.code,{children:"p2_singleton"})}),"."]}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Pay to Singleton"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-chialisp",metastring:'title="p2_singleton.clvm"',children:"(mod (\n       SINGLETON_MOD_HASH\n       LAUNCHER_ID\n       LAUNCHER_PUZZLE_HASH\n       singleton_inner_puzzle_hash\n       my_id\n     )\n\n  ; SINGLETON_MOD_HASH is the mod-hash for the singleton_top_layer puzzle\n  ; LAUNCHER_ID is the ID of the singleton we are commited to paying to\n  ; LAUNCHER_PUZZLE_HASH is the puzzle hash of the launcher\n  ; singleton_inner_puzzle_hash is the innerpuzzlehash for our singleton at the current time\n  ; my_id is the coin_id of the coin that this puzzle is locked into\n\n  (include condition_codes.clvm)\n  (include curry-and-treehash.clinc)\n\n  ; takes a lisp tree and returns the hash of it\n  (defun sha256tree (TREE)\n      (if (l TREE)\n          (sha256 2 (sha256tree (f TREE)) (sha256tree (r TREE)))\n          (sha256 1 TREE)\n      )\n  )\n\n  ;; return the full puzzlehash for a singleton with the innerpuzzle curried in\n  ; puzzle-hash-of-curried-function is imported from curry-and-treehash.clinc\n  (defun-inline calculate_full_puzzle_hash (SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH inner_puzzle_hash)\n     (puzzle-hash-of-curried-function SINGLETON_MOD_HASH\n                                      inner_puzzle_hash\n                                      (sha256tree (c SINGLETON_MOD_HASH (c LAUNCHER_ID LAUNCHER_PUZZLE_HASH)))\n     )\n  )\n\n  (defun-inline claim_rewards (SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH singleton_inner_puzzle_hash my_id)\n    (list\n        (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 (calculate_full_puzzle_hash SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH singleton_inner_puzzle_hash) my_id))\n        (list CREATE_COIN_ANNOUNCEMENT '$')\n        (list ASSERT_MY_COIN_ID my_id))\n  )\n\n  ; main\n  (claim_rewards SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH singleton_inner_puzzle_hash my_id)\n)\n"})}),(0,o.jsxs)(n.p,{children:["Most of this puzzle should be self explanatory especially if you've gone through the puzzles above.\nLet focus on just the conditions we are creating from the ",(0,o.jsx)(n.code,{children:"claim_rewards"})," function:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-chialisp",children:"(list\n    (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 (calculate_full_puzzle_hash SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH singleton_inner_puzzle_hash) my_id))\n    (list CREATE_COIN_ANNOUNCEMENT '$')\n    (list ASSERT_MY_COIN_ID my_id)\n)\n"})}),(0,o.jsx)(n.p,{children:"We are both asserting an announcement from the singleton and creating one for it.\nThe assertion is fundamental to the fact that we only want to be claimed by a very specific singleton.\nDue to the launcher id being curried into the singleton's puzzle hash, it will be unique to every singleton and can thereby only be claimed by the singleton whose launcher id we specify.\nWe cannot use the singleton's coin id, because if we curried that in, the singleton could spend and then this puzzle becomes unsolvable!"}),(0,o.jsxs)(n.p,{children:["The announcement that we create is simply for the singleton to assert that we are also being spent.\nThis is necessary due to the fact that ",(0,o.jsx)(n.a,{href:"https://docs.chia.net/coin-set-security#replay",children:"nodes may try and exclude this spend"})," causing the singleton to spend without claiming these rewards.\nSince this coin cannot be signed, we must ensure somehow that if it is excluded, the whole spend bundle fails.\nWe use ",(0,o.jsx)(n.code,{children:"'$'"})," because it's one byte and somewhat relevant."]}),(0,o.jsx)(n.p,{children:"The coin id assertion is simply to ensure that we are being told the truth about our id. Otherwise, we could piggy back on another claim by using that coin's id and asserting the announcement that the singleton creates for it."})]}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"The singleton is a very useful primitive that is used to power higher level things such as NFTs and DIDs. It can be used to emulate state using a linear chain of coins. This is a less centralized version of a typical smart contract."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const o={},s=i.createContext(o);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);