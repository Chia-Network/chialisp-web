"use strict";(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[83],{7286:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"primitives/pooling","title":"Pooling","description":"The way that Chia Network does pooling is unlike many blockchains that have come before it. Pool operators actually rely on an on-chain smart coin to verify that they will be able to directly claim any potential pool rewards that farmers create.","source":"@site/docs/primitives/pooling.md","sourceDirName":"primitives","slug":"/pooling","permalink":"/pooling","draft":false,"unlisted":false,"editUrl":"https://github.com/Chia-Network/chialisp-web/blob/main/docs/primitives/pooling.md","tags":[],"version":"current","frontMatter":{"title":"Pooling","slug":"/pooling"},"sidebar":"someSidebar","previous":{"title":"Offers","permalink":"/offers"},"next":{"title":"CLVM","permalink":"/clvm"}}');var i=n(4848),a=n(8453);const s={title:"Pooling",slug:"/pooling"},l=void 0,r={},h=[{value:"Design Requirements",id:"design-requirements",level:2},{value:"The Pool Member",id:"the-pool-member",level:2},{value:"The Waiting Room",id:"the-waiting-room",level:2}];function c(e){const t={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"The way that Chia Network does pooling is unlike many blockchains that have come before it. Pool operators actually rely on an on-chain smart coin to verify that they will be able to directly claim any potential pool rewards that farmers create.\nThis allows pools to trust farmers enough to pay them out, while still keeping the power of making the blocks in the hands of the farmer.\nThis means that the decentralization of the network remains the same, even as the rewards get concentrated to the pool!"}),"\n",(0,i.jsxs)(t.p,{children:["In this section, we're going to break down how all of this works in Chialisp.\nThis section assumes you have already read the section about ",(0,i.jsx)(t.a,{href:"/singletons",children:"singletons"})," (or at least understand how they work) as that is the outer puzzle that wraps the pooling puzzles."]}),"\n",(0,i.jsx)(t.h2,{id:"design-requirements",children:"Design Requirements"}),"\n",(0,i.jsx)(t.p,{children:"There are a few requirements that were set for how the pooling protocol would work on the Chia Network. Let's go over them now:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"The farmer farms the blocks, not the pool."})," This is incredibly important for network decentralization. If this is not true, then the bigger a pool gets, the closer it is to gaining 51% of the network resources.\nWe still want the farmers to create the blocks, but we need some way to assure the pool that the farmer will give them the reward when they do.\nWe do this by creating plots that farm directly to a specific puzzle hash, and ensuring that puzzle hash is something that the pool can claim."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"The farmer must be able to change pools."}),' Initially, this seems to conflict with the first requirement.\nPlots can be made to send rewards directly to a puzzle hash, but you cannot change that puzzle hash once they are plotted.\nIf you want to switch pools, you\'ll have to remake all of your plots! We solve this by having our plots create payments that a specific singleton (also called a "plot nft") can claim.\nThen, we can lend partial control of that singleton to a pool, but still retain the ability to reclaim our singleton and lend it instead to a different pool.\nOur plots will remain effective as long as we retain control of the singleton.']}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"The farmer cannot leave the pool immediately."})," This requirement prevents attacks common to other blockchains where a miner will send partials to a pool until they win a block, then leave the pool immediately and claim that block for themselves.\nTo prevent this, we have implemented something called a ",(0,i.jsx)(t.strong,{children:"waiting room"})," puzzle which is nearly the same as the puzzle for farming to a pool, except that the farmer can reclaim their singleton after a specified amount of time (in blocks)."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"the-pool-member",children:"The Pool Member"}),"\n",(0,i.jsxs)(t.p,{children:["We call the standard puzzle that we use to lend away partial control of our singleton the ",(0,i.jsx)(t.strong,{children:"pool member"})," inner puzzle.\nOur goal here is threefold:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Allow the pool to claim ",(0,i.jsx)(t.a,{href:"/singletons#pay-to-singleton",children:"pay-to-singleton coins"})]}),"\n",(0,i.jsx)(t.li,{children:"Disallow the farmer from claiming any coins"}),"\n",(0,i.jsx)(t.li,{children:"Allow the farmer to begin the process of reclaiming full control of the singleton"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Let's take a look at the full source now:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-chialisp",children:"(mod (\n       POOL_PUZZLE_HASH\n       P2_SINGLETON_PUZZLE_HASH\n       OWNER_PUBKEY\n       POOL_REWARD_PREFIX\n       WAITINGROOM_PUZHASH\n       Truths\n       p1\n       pool_reward_height\n     )\n\n\n  ; POOL_PUZZLE_HASH is commitment to the pool's puzzle hash\n  ; P2_SINGLETON_PUZZLE_HASH is the puzzle hash for your pay to singleton puzzle\n  ; OWNER_PUBKEY is the farmer pubkey which authorises a travel\n  ; POOL_REWARD_PREFIX is network-specific data (mainnet vs testnet) that helps determine if a coin is a pool reward\n  ; WAITINGROOM_PUZHASH is the puzzle_hash you'll go to when you iniate the leaving process\n\n  ; Absorbing money if pool_reward_height is an atom\n  ; Escaping if pool_reward_height is ()\n\n  ; p1 is pool_reward_amount if absorbing money\n  ; p1 is key_value_list if escaping\n\n  ; pool_reward_amount is the value of the coin reward - this is passed in so that this puzzle will still work after halvenings\n  ; pool_reward_height is the block height that the reward was generated at. This is used to calculate the coin ID.\n  ; key_value_list is signed extra data that the wallet may want to publicly announce for syncing purposes\n\n  (include condition_codes.clib)\n  (include singleton_truths.clib)\n\n  ; takes a lisp tree and returns the hash of it\n  (defun sha256tree (TREE)\n      (if (l TREE)\n          (sha256 2 (sha256tree (f TREE)) (sha256tree (r TREE)))\n          (sha256 1 TREE)\n      )\n  )\n\n  (defun-inline calculate_pool_reward (pool_reward_height P2_SINGLETON_PUZZLE_HASH POOL_REWARD_PREFIX pool_reward_amount)\n    (sha256 (logior POOL_REWARD_PREFIX (logand (- (lsh (q . 1) (q . 128)) (q . 1)) pool_reward_height)) P2_SINGLETON_PUZZLE_HASH pool_reward_amount)\n  )\n\n  (defun absorb_pool_reward (POOL_PUZZLE_HASH my_inner_puzzle_hash my_amount pool_reward_amount pool_reward_id)\n    (list\n        (list CREATE_COIN my_inner_puzzle_hash my_amount)\n        (list CREATE_COIN POOL_PUZZLE_HASH pool_reward_amount)\n        (list CREATE_PUZZLE_ANNOUNCEMENT pool_reward_id)\n        (list ASSERT_COIN_ANNOUNCEMENT (sha256 pool_reward_id '$'))\n    )\n  )\n\n  (defun-inline travel_to_waitingroom (OWNER_PUBKEY WAITINGROOM_PUZHASH my_amount extra_data)\n    (list (list AGG_SIG_ME OWNER_PUBKEY (sha256tree extra_data))\n          (list CREATE_COIN WAITINGROOM_PUZHASH my_amount)\n    )\n  )\n\n  ; main\n\n  (if pool_reward_height\n    (absorb_pool_reward POOL_PUZZLE_HASH\n                        (my_inner_puzzle_hash_truth Truths)\n                        (my_amount_truth Truths)\n                        p1\n                        (calculate_pool_reward pool_reward_height P2_SINGLETON_PUZZLE_HASH POOL_REWARD_PREFIX p1)\n    )\n    (travel_to_waitingroom OWNER_PUBKEY WAITINGROOM_PUZHASH (my_amount_truth Truths) p1)\n  )\n)\n"})}),"\n",(0,i.jsx)(t.p,{children:"As always, let's begin with the arguments:"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"POOL_PUZZLE_HASH"})," is the address to which we want to pay the pool when we win a block reward.\nThe pool uses this to verify that the singleton has been lent to them."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"P2_SINGLETON_PUZZLE_HASH"})," is the puzzle hash that payments to this singleton will have.\nThis is the hash that farmers make their plots to."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"OWNER_PUBKEY"})," is the public key that will sign the decision to leave the pool.\nThis is likely owned by the farmer."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"POOL_REWARD_PREFIX"})," is a bit of a unique argument.\nOn the chia mainnet, this will always be ",(0,i.jsx)(t.code,{children:"ccd5bb71183532bff220ba46c268991a00000000000000000000000000000000"}),".\nIt is the beginning of the ",(0,i.jsx)(t.code,{children:"parent_coin_id"})," of pool reward coins. Because those coins do not have a parent, their ID is derived from a combination of the network ID in the left half of the ID, and an incrementing identifier in the right.\nThat first half is followed by 32 zeroes to make it the length of a standard hash.\nWe'll talk more about why this is needed when we go over the segment of code that uses it."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"WAITINGROOM_PUZHASH"})," is the puzzle hash of the waiting room puzzle that we will go to when we attempt to leave the pool.\nWe will go over that puzzle later, but what's important to know is that we commit to the puzzle we leave to before we join the pool.\nThis is so the pool can have certain assurances about how long it will take you to leave."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"Truths"})," is the data structure that is forcefully added to this puzzle as part of the singleton top layer.\nIt contains some data we will use in the puzzle which we will access by using some functions from the ",(0,i.jsx)(t.code,{children:"singleton_truths.clib"})," library."]}),"\n",(0,i.jsxs)(t.p,{children:["There are two spend cases for this puzzle.\nThe ",(0,i.jsx)(t.strong,{children:"absorb case"})," will most likely be triggered by the pool and is how they claim the rewards that the farmers receive.\nThe ",(0,i.jsx)(t.strong,{children:"escape case"})," will be initiated by the farmer to begin the process of leaving the pool by heading to the waiting room.\nThe following two arguments change depending on the case we are executing:"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"p1"})," is named the way it is because it is going to be different depending on the spend type we are using.\nIt is either:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The amount of the pool reward that is being claimed (1750000000000 during the first three years)"}),"\n",(0,i.jsxs)(t.li,{children:["A list of key value pairs that is used to reveal important information to the blockchain for wallets to use (similar to the ",(0,i.jsx)(t.a,{href:"/singletons#launcher",children:"singleton launcher"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"pool_reward_height"})," is also different depending on the spend case, but in the escape case it is just ",(0,i.jsx)(t.code,{children:"()"})," so we leave it named the way it is.\nIn the absorb case, it is the height of the pool reward that is being absorbed.\nThis is used along with ",(0,i.jsx)(t.code,{children:"POOL_REWARD_PREFIX"})," to calculate the ",(0,i.jsx)(t.code,{children:"parent_coin_id"})," of the reward coin so that we can calculate its ID."]}),"\n",(0,i.jsx)(t.p,{children:"Let's talk about our main entry point:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-chialisp",children:"(if pool_reward_height\n  (absorb_pool_reward POOL_PUZZLE_HASH\n                      (my_inner_puzzle_hash_truth Truths)\n                      (my_amount_truth Truths)\n                      p1\n                      (calculate_pool_reward pool_reward_height P2_SINGLETON_PUZZLE_HASH POOL_REWARD_PREFIX p1)\n  )\n  (travel_to_waitingroom OWNER_PUBKEY WAITINGROOM_PUZHASH (my_amount_truth Truths) p1)\n)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The main control flow here is whether or not the height is passed in as ",(0,i.jsx)(t.code,{children:"()"}),". This is how we determine the spend type to execute. After that we just head to the appropriate function that generates the conditions we will need for the type of spend we are executing. You'll notice that we are extracting the relevant data from the ",(0,i.jsx)(t.code,{children:"Truths"})," object before we pass them to the inner functions."]}),"\n",(0,i.jsx)(t.p,{children:"We are also calculating one additional piece of information.\nLet's look at it now:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-chialisp",children:"(defun-inline calculate_pool_reward (pool_reward_height P2_SINGLETON_PUZZLE_HASH POOL_REWARD_PREFIX pool_reward_amount)\n  (sha256 (logior POOL_REWARD_PREFIX (logand (- (lsh (q . 1) (q . 128)) (q . 1)) pool_reward_height)) P2_SINGLETON_PUZZLE_HASH pool_reward_amount)\n)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This line may look complex, but it's doing something fairly simplistic.\nIt is calculating the coin ID of the reward coin it is claiming by manually calculating the parent id from the ",(0,i.jsx)(t.code,{children:"POOL_REWARD_PREFIX"})," and ",(0,i.jsx)(t.code,{children:"pool_reward_height"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Why do we have to do this? The manual calculation is due to the fact that this singleton may have other payments made to it.\nRight now, since we are lending our singleton to the pool, we don't want the singleton to be able to claim those rewards. We specifically only want the pool to be able to claim pool rewards that are generated from farming.\nSince we know these rewards have a ",(0,i.jsx)(t.code,{children:"parent_coin_id"})," that is a special format, we can manually calculate it to ensure that the pool can't lie to us and pass in the ID of a non-reward coin."]}),"\n",(0,i.jsx)(t.p,{children:"Let's take a look at this section here:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-chialisp",children:"(logior POOL_REWARD_PREFIX (logand (- (lsh (q . 1) (q . 128)) (q . 1)) pool_reward_height))\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"(- (lsh (q . 1) (q . 128)) (q . 1))"})," is simply a way of generating a sequence of 32 ",(0,i.jsx)(t.code,{children:"f"}),"s. We then use ",(0,i.jsx)(t.code,{children:"logand"})," on that with the pool reward height, which in an honest scenario should leave it unchanged.\nFinally, we use ",(0,i.jsx)(t.code,{children:"logior"})," to combine the two values into one string.\nLet's say we have a height of ",(0,i.jsx)(t.code,{children:"abcdef"}),".\nOur final product will be ",(0,i.jsx)(t.code,{children:"ccd5bb71183532bff220ba46c268991a00000000000000000000000000abcdef"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Why do we need this extra ",(0,i.jsx)(t.code,{children:"logand"})," with the string of ",(0,i.jsx)(t.code,{children:"f"}),"s? It's to prevent a relatively obscure, but possible attack.\nRemember that an attacker can pass whatever they want in through the solution.\nFor example, a 32 byte hex string.\nIf they passed through the right hex string, they could completely control the output of our calculation ",(0,i.jsx)(t.em,{children:"except"})," for the bits that happen to be set to 1 in the genesis challenge half of the ",(0,i.jsx)(t.code,{children:"POOL_REWARD_PREFIX"}),' (62/128 of them).\nThe idea is that a pool could grind out a coin whose parent ID has all of those bits set, create the coin, and then use the singleton to claim it.\nWhy claim a coin that you already had control of? This will become more apparent in the waiting room puzzle, but they could hypothetically "freeze" the singleton in their pool if they were able to reset the puzzle.\nIt\'s not as important in the pool member puzzle, but it is still probably best to prevent the pool from spending the singleton in an unintended way.\nThe ',(0,i.jsx)(t.code,{children:"logand"})," ensures that only bits on the right can change, every bit on left gets set to 0 before it is evaluated with the ",(0,i.jsx)(t.code,{children:"logior"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Okay let's move onto the conditions for the absorb spend case:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-chialisp",children:"(defun absorb_pool_reward (POOL_PUZZLE_HASH my_inner_puzzle_hash my_amount pool_reward_amount pool_reward_id)\n  (list\n      (list CREATE_COIN my_inner_puzzle_hash my_amount)\n      (list CREATE_COIN POOL_PUZZLE_HASH pool_reward_amount)\n      (list CREATE_PUZZLE_ANNOUNCEMENT pool_reward_id)\n      (list ASSERT_COIN_ANNOUNCEMENT (sha256 pool_reward_id '$'))\n  )\n)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The first ",(0,i.jsx)(t.code,{children:"CREATE_COIN"})," condition ensures that our singleton is recreated exactly as it is. Remember that we get ",(0,i.jsx)(t.code,{children:"my_inner_puzzle_hash"})," and ",(0,i.jsx)(t.code,{children:"my_amount"})," from our singleton outer puzzle, so we don't need to assert them."]}),"\n",(0,i.jsxs)(t.p,{children:["The next ",(0,i.jsx)(t.code,{children:"CREATE_COIN"})," condition creates the coin that uses the excess value from spending the pay-to-singleton coin to pay the pool.\nKeep in mind that this puzzle hash is curried into the puzzle and cannot change.\nThis is because there is no signature required from the pool to spend the coin.\nIf we didn't pre-commit to the puzzle hash, anyone could solve with their own puzzle hash and spend the rewards to themselves."]}),"\n",(0,i.jsxs)(t.p,{children:["The announcement conditions are the other side of the ",(0,i.jsx)(t.a,{href:"/singletons#pay-to-singleton",children:"pay-to-singleton announcements"}),'. The announcement creation allows the pay-to-singleton to assert that it has received the instruction to pay out.\nThe announcement assertion ensures that the pay-to-singleton is actually spent (otherwise we run into the singleton "freezing" problem from above again).']}),"\n",(0,i.jsx)(t.p,{children:"Finally, let's look at the escape conditions:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-chialisp",children:"(defun-inline travel_to_waitingroom (OWNER_PUBKEY WAITINGROOM_PUZHASH my_amount extra_data)\n  (list (list AGG_SIG_ME OWNER_PUBKEY (sha256tree extra_data))\n        (list CREATE_COIN WAITINGROOM_PUZHASH my_amount)\n  )\n)\n"})}),"\n",(0,i.jsx)(t.p,{children:"Simple enough. We first require a signature on the key/value list that is being passed in through the solution to secure it and to signal that this spend is indeed triggered by the owner of the singleton. The only other thing we do is send ourselves to the waiting room."}),"\n",(0,i.jsx)(t.p,{children:"Let's talk about that puzzle now."}),"\n",(0,i.jsx)(t.h2,{id:"the-waiting-room",children:"The Waiting Room"}),"\n",(0,i.jsx)(t.p,{children:"Before we start talking about this puzzle, let's examine the full source as usual:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-chialisp",children:"(mod (\n        POOL_PUZZLE_HASH\n        P2_SINGLETON_PUZZLE_HASH\n        OWNER_PUBKEY\n        POOL_REWARD_PREFIX\n        RELATIVE_LOCK_HEIGHT\n        Truths\n        spend_type\n        p1\n        p2\n      )\n\n  ; POOL_PUZZLE_HASH is commitment to the pool's puzzle hash\n  ; P2_SINGLETON_PUZZLE_HASH is the puzzlehash for your pay_to_singleton puzzle\n  ; OWNER_PUBKEY is the farmer pubkey which signs the exit puzzle_hash\n  ; POOL_REWARD_PREFIX is network-specific data (mainnet vs testnet) that helps determine if a coin is a pool reward\n  ; RELATIVE_LOCK_HEIGHT is how long it takes to leave\n\n  ; spend_type is: 0 for absorbing money, 1 to escape\n  ; if spend_type is 0\n    ; p1 is pool_reward_amount - the value of the coin reward - this is passed in so that this puzzle will still work after halvenings\n    ; p2 is pool_reward_height - the block height that the reward was generated at. This is used to calculate the coin ID.\n  ; if spend_type is 1\n    ; p1 is key_value_list - signed extra data that the wallet may want to publicly announce for syncing purposes\n    ; p2 is destination_puzhash - the location that the escape spend wants to create itself to\n\n  (include condition_codes.clvm)\n  (include singleton_truths.clib)\n\n  ; takes a lisp tree and returns the hash of it\n  (defun sha256tree (TREE)\n      (if (l TREE)\n          (sha256 2 (sha256tree (f TREE)) (sha256tree (r TREE)))\n          (sha256 1 TREE)\n      )\n  )\n\n  (defun-inline calculate_pool_reward (pool_reward_height P2_SINGLETON_PUZZLE_HASH POOL_REWARD_PREFIX pool_reward_amount)\n    (sha256 (logior POOL_REWARD_PREFIX (logand (- (lsh (q . 1) (q . 128)) (q . 1)) pool_reward_height)) P2_SINGLETON_PUZZLE_HASH pool_reward_amount)\n  )\n\n  (defun absorb_pool_reward (POOL_PUZZLE_HASH my_inner_puzzle_hash my_amount pool_reward_amount pool_reward_id)\n    (list\n        (list CREATE_COIN my_inner_puzzle_hash my_amount)\n        (list CREATE_COIN POOL_PUZZLE_HASH pool_reward_amount)\n        (list CREATE_PUZZLE_ANNOUNCEMENT pool_reward_id)\n        (list ASSERT_COIN_ANNOUNCEMENT (sha256 pool_reward_id '$'))\n    )\n  )\n\n  (defun-inline travel_spend (RELATIVE_LOCK_HEIGHT new_puzzle_hash my_amount extra_data)\n    (list (list ASSERT_HEIGHT_RELATIVE RELATIVE_LOCK_HEIGHT)\n          (list CREATE_COIN new_puzzle_hash my_amount)\n          (list AGG_SIG_ME OWNER_PUBKEY (sha256tree (list new_puzzle_hash extra_data)))\n    )\n  )\n\n  ; main\n\n  (if spend_type\n    (travel_spend RELATIVE_LOCK_HEIGHT p2 (my_amount_truth Truths) p1)\n    (absorb_pool_reward POOL_PUZZLE_HASH\n                        (my_inner_puzzle_hash_truth Truths)\n                        (my_amount_truth Truths)\n                        p1\n                        (calculate_pool_reward p2 P2_SINGLETON_PUZZLE_HASH POOL_REWARD_PREFIX p1)\n    )\n  )\n)\n"})}),"\n",(0,i.jsx)(t.p,{children:"You may notice that is looks nearly identical to the one above.\nInstead of breaking this down piece by piece, we're just going to focus on the differences.\nFirst, the parameters:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-chialisp",children:"(\n  POOL_PUZZLE_HASH\n  P2_SINGLETON_PUZZLE_HASH\n  OWNER_PUBKEY\n  POOL_REWARD_PREFIX\n  RELATIVE_LOCK_HEIGHT\n  Truths\n  spend_type\n  p1\n  p2\n)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We still have ",(0,i.jsx)(t.code,{children:"POOL_PUZZLE_HASH"}),", ",(0,i.jsx)(t.code,{children:"P2_SINGLETON_PUZZLE_HASH"}),", ",(0,i.jsx)(t.code,{children:"OWNER_PUBKEY"}),", and ",(0,i.jsx)(t.code,{children:"POOL_REWARD_PREFIX"}),".\nHowever, now we also have a new curried in parameter called ",(0,i.jsx)(t.code,{children:"RELATIVE_LOCK_HEIGHT"}),". This indicates the amount of time after entering this waiting room that we have to wait before we can spend away to something else."]}),"\n",(0,i.jsx)(t.p,{children:'Note that relative lock heights are calculated from the time of the coin\'s creation.\nIf the coin is spent as part of an absorb, this lock height resets.\nTheoretically, with a large enough lock height and a big enough farmer who wins frequently, this singleton can be "frozen" until the farmer is lucky enough not to win a block within the specified timeframe.'}),"\n",(0,i.jsxs)(t.p,{children:["We still have ",(0,i.jsx)(t.code,{children:"Truths"}),", since this is still a singleton inner puzzle.\nHowever, the final three arguments are almost completely different."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"spend_type"})," is now necessary because we can no longer choose which spend case we are executing based on the last argument."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"p1"})," is different based on the spend type:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"If we're doing the absorb spend, it's the amount of the pool reward coin."}),"\n",(0,i.jsx)(t.li,{children:"If we're traveling to a new puzzle, it's the key/value list that we use to record data in the blockchain."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"p2"})," is also different based on the spend type:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"If we're doing the absorb spend, it's the height at which the pool reward coin was created."}),"\n",(0,i.jsx)(t.li,{children:"If we're traveling to a new puzzle, it's the puzzle hash of that puzzle"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"After the argument differences, the only other major change is in the travel function:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-chialisp",children:"(defun-inline travel_spend (RELATIVE_LOCK_HEIGHT new_puzzle_hash my_amount extra_data)\n  (list (list ASSERT_HEIGHT_RELATIVE RELATIVE_LOCK_HEIGHT)\n        (list CREATE_COIN new_puzzle_hash my_amount)\n        (list AGG_SIG_ME OWNER_PUBKEY (sha256tree (list new_puzzle_hash extra_data)))\n  )\n)\n"})}),"\n",(0,i.jsx)(t.p,{children:"First, we assert that the required amount of time has passed (this is for the pool's safety).\nThen, we create the new specified coin.\nNote that we don't get to choose the amount and, therefore, must escape to a new singleton."}),"\n",(0,i.jsxs)(t.p,{children:["Finally, we sign the extra data, just like before, but this time we include the ",(0,i.jsx)(t.code,{children:"destination_puzhash"})," so that someone malicious cannot steal our singleton by substituting in a value."]}),"\n",(0,i.jsx)(t.p,{children:"Those are the only changes!"}),"\n",(0,i.jsx)(t.p,{children:"It may seem pretty irregular to have these as separate but similar puzzles.\nThere's a lot of code duplication which is usually bad practice.\nIt's very possible that there is a way to combine these two puzzles into a single puzzle, but the cost would increase dramatically.\nAt the end of the day, it's better to have duplicated code than to bog down the blockchain with needlessly expensive transactions."}),"\n",(0,i.jsx)(t.p,{children:'Interestingly enough, we actually want to be in the waiting room state with a lock height of zero when we are pooling by ourselves.\nThe reasoning is that since we are "lending" the singleton to ourselves, we don\'t really need the insurance that we leave early, which is the entire point of the waiting room.\nThis cuts down on unnecessary spends, and saves us even more cost in the long run.'})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var o=n(6540);const i={},a=o.createContext(i);function s(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);