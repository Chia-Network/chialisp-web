"use strict";(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[155],{1246:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var t=a(4848),i=a(8453);const s={id:"modern-chialisp",title:"Modern Chialisp",slug:"/modern-chialisp"},l="Modern chialisp",r={id:"modern-chialisp",title:"Modern Chialisp",description:"Chialisp can evolve over time and still serve its role in preserving the",source:"@site/docs/modern-chialisp.md",sourceDirName:".",slug:"/modern-chialisp",permalink:"/modern-chialisp",draft:!1,unlisted:!1,editUrl:"https://github.com/Chia-Network/chialisp-web/blob/main/docs/modern-chialisp.md",tags:[],version:"current",frontMatter:{id:"modern-chialisp",title:"Modern Chialisp",slug:"/modern-chialisp"},sidebar:"someSidebar",previous:{title:"Syntax",permalink:"/syntax"},next:{title:"Operators",permalink:"/operators"}},o={},d=[{value:"Description of the new language",id:"description-of-the-new-language",level:2},{value:"An example of modern chialisp exercising many of the new features:",id:"an-example-of-modern-chialisp-exercising-many-of-the-new-features",level:3},{value:"Complete list of new features",id:"complete-list-of-new-features",level:2},{value:"defconst constants",id:"defconst-constants",level:3},{value:"<code>let</code>, <code>let*</code> and <code>assign</code> forms",id:"let-let-and-assign-forms",level:3},{value:"at capture",id:"at-capture",level:3},{value:"Function closures",id:"function-closures",level:3},{value:"lambda forms",id:"lambda-forms",level:3},{value:"embed and compile include forms",id:"embed-and-compile-include-forms",level:3},{value:"trace output via cldb",id:"trace-output-via-cldb",level:3},{value:"defmac and full preprocessing",id:"defmac-and-full-preprocessing",level:3},{value:"Example: &#39;and&#39; macro",id:"example-and-macro",level:4},{value:"&#39;if&#39; and &#39;list&#39; macros",id:"if-and-list-macros",level:4},{value:"Complete example: ABC problem",id:"complete-example-abc-problem",level:2},{value:"Complete example: Babbage problem",id:"complete-example-babbage-problem",level:2},{value:"Complete Example: AVL Tree",id:"complete-example-avl-tree",level:2},{value:"Complete Example: Hash Array Mapped Trie (HAMT)",id:"complete-example-hash-array-mapped-trie-hamt",level:2}];function c(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"modern-chialisp",children:"Modern chialisp"})}),"\n",(0,t.jsxs)(n.p,{children:["Chialisp can evolve over time and still serve its role in preserving the\nrepresentation of older programs in previous iterations of the language by using\na sigil to indicate what tooling version the program was finalized in. The\ncurrent sigil is ",(0,t.jsx)(n.code,{children:"*standard-cl-23*"}),". Use an 'include' form to set the\ntooling version. Chialisp has a lot of new features which make programs easier\nto understand, read and write. The speed of its optimizer has been improved to\nallow faster iteration and several features make chialisp safer. Undefined\nvariables are no longer treated as values, and return diagnostics instead. Let\nbindings and related assign forms allow programs to be structured more logically\nand preprocessing is now a separate pass that can be inspected on its own."]}),"\n",(0,t.jsx)(n.h2,{id:"description-of-the-new-language",children:"Description of the new language"}),"\n",(0,t.jsx)(n.h3,{id:"an-example-of-modern-chialisp-exercising-many-of-the-new-features",children:"An example of modern chialisp exercising many of the new features:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"(mod (X)\n\n  ;; Specify that this program is compiled with *standard-cl-23*.\n  ;; After release, the chialisp compiler guarantees that programs\n  ;; with a specific sigil (including no sigil) compile to the\n  ;; same representation forever (it is a bug that must be fixed\n  ;; if a program changes representation in a future compiler\n  ;; release).  In this way, program source code can also provide\n  ;; enough information to re-produce a puzzle hash from source\n  ;; code.\n  (include *standard-cl-23*)\n\n  ;; Normal functions are now allowed to be called from macros.\n  ;; When run in macro space, they can used special forms to detect\n  ;; what language level tokens are given (to differentiate identifiers\n  ;; and constants and the like).  Functions can be used both by the\n  ;; deployed program and macros or just either.\n  (defun n-additions-inner (n value idx)\n    (if (> idx n)\n      ()\n     (qq (c (+ (unquote idx) (unquote value)) (unquote (n-additions-inner n value (+ 1 idx)))))\n     )\n   )\n\n  ;; The new 'defmac' keyword defines a modern macro.  They're like\n  ;; the prior macro system but can't rely on their own definition\n  ;; or anything lexically after themselves (like in the C preprocessor).\n  ;; You can view the preprocessor expansion of a program before it's\n  ;; handed to the compiler proper using the -E switch.\n  (defmac n-additions (n value) (n-additions-inner n value 1))\n\n  (defun F (X) (n-additions 3 X))\n      \n  (defun odd (X) (logand X 1))\n      \n  ;; Usual higher order functions work like you might hope.\n  ;; This filter function takes a predicate, \"pred\", which\n  ;; returns a truthy value to include the result or nil.\n  ;; (@ lst (first . rest)) is similar to a similar \n  ;; destructuring form in haskell.\n  ;; (@ lst (first . rest))\n  ;; generates the same bindings as simultaneously having\n  ;; (pred lst)\n  ;; and\n  ;; (pred (first . rest))\n  ;; as an argument list.\n  (defun filter (pred (@ lst (first . rest)))\n    (if lst\n      (if (a pred (list first))\n        (c first (filter pred rest))\n        (filter pred rest)\n        )\n      ()\n      )\n    )\n      \n  ;; @ destructuring here takes the place of the\n  ;; whole argument list.\n  (defun sum (@ the-list (first . rest))\n    (if the-list\n      (+ first (a sum rest))\n      0\n      )\n    )\n    \n  (assign\n    ;; We can destructure the result based on its shape.\n    ;; Assign reorders and groups assignments based on their dependencies.\n    (A B C) result-list\n        \n    ;; The bindings can be in any order, like the let forms in elm, haskell\n    ;; and others.\n    result-list (F X)\n\n    summed (a sum result-list)\n    \n    ;; We can name 'sum' as a predicate.\n    odds (filter odd result-list)\n\n    ;; Result of this form.\n    (list summed odds)\n    )\n  )\n"})}),"\n",(0,t.jsx)(n.h2,{id:"complete-list-of-new-features",children:"Complete list of new features"}),"\n",(0,t.jsx)(n.h3,{id:"defconst-constants",children:"defconst constants"}),"\n",(0,t.jsx)(n.p,{children:"The new defconst form has access to the program surrounding it at compile time.\nThe value that results is computed at compile time (and causes an error if that\nisn't possible for some reason, such as it depends on its own constant, causes\na clvm exception or some other problem) and the compiler chooses the smaller\nrepresentation of inlining it or placing it in the environment."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:'(mod (Z)\n\n  (include *standard-cl-23*)\n\n  ; takes a lisp tree and returns the hash of it\n  (defun sha256tree1 (TREE)\n    (if (l TREE)\n      (sha256 2 (sha256tree1 (f TREE)) (sha256tree1 (r TREE)))\n      (sha256 1 TREE)\n      )\n    )\n\n  (defconst HELLO_HASH (sha256tree1 (c "hello" "world")))\n    \n  (sha256 HELLO_HASH Z)\n  )\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ brun defconsthash.clvm '(3)'\n0xf60efb25b9e6e3587acd9cf01c332707bb771801bdb5e4f50ea957a29c8dde89\n$ opc -H '(hello . world)'\n9d1890eef772e63013f481b4313eeaae7de4b0601268f380124ad1d74d694d15\n$ brun '(sha256 (q . 0x9d1890eef772e63013f481b4313eeaae7de4b0601268f380124ad1d74d694d15) (q . 3))'\n0xf60efb25b9e6e3587acd9cf01c332707bb771801bdb5e4f50ea957a29c8dde89\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"let-let-and-assign-forms",children:[(0,t.jsx)(n.code,{children:"let"}),", ",(0,t.jsx)(n.code,{children:"let*"})," and ",(0,t.jsx)(n.code,{children:"assign"})," forms"]}),"\n",(0,t.jsxs)(n.p,{children:["Chialisp now has local bindings that allow code to be more organized, to use the\nsame computation more than once without having to explicitly write and call a\nseparate function to capture the value into a CLVM environment that can be\nextracted via variable reference. The bound variables can be referenced in the\nbody. let and let* forms are classic lisp and scheme, and allow just a name to\nbe bound from an expression. ",(0,t.jsx)(n.code,{children:"let"})," performs all bindings at the same time\n(they don't have access to each other) and the other form of let allows each\none to access the values bound before it.  ",(0,t.jsx)(n.code,{children:"assign"})," can handle any arrangement\nof bindings as long as they don't form a cycle."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"(mod (Z)\n  \n  (include *standard-cl-23*)\n  \n  (let ((X (+ Z 1))\n        (Y (- Z 1)))\n    (* X Y)\n    )\n  )\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ brun simple-let.clvm '(5)'\n24\n"})}),"\n",(0,t.jsx)(n.h3,{id:"at-capture",children:"at capture"}),"\n",(0,t.jsx)(n.p,{children:"Chialisp supports overlapping variable bindings in which one gives a name to a\ncollection of further destructuring."}),"\n",(0,t.jsx)(n.p,{children:"In haskell, it's possible to bind both a container and its contents:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:"data Pt = Pt Int Int deriving Show\nf p@(Pt x y) = if x == 0 then p else Pt (x - 1) y\n"})}),"\n",(0,t.jsx)(n.p,{children:"Scheme and lisp argument destructuring can stand in for destructuring objects.\nIn the above case, we can refer to the object's fields separately and the object\nitself if we just want to pass it on whole or return it."}),"\n",(0,t.jsx)(n.p,{children:"You can also use this to simulate Maybe or Options type in a convenient way."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:"> f p = fromMaybe 0 $ (\\(Pt x y) -> x + y) <$> p\n> f (Just (Pt 3 5))\n8\n> f Nothing\n0\n"})}),"\n",(0,t.jsx)(n.p,{children:"In chialisp:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"(mod (p) \n  (include *standard-cl-23*) \n      \n  (defun F ((@ p (x y))) (if p (+ x y) 0)) \n      \n  (F p)\n  )\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ brun maybe.clvm '((3 5))'\n8\n$ brun maybe.clvm '(())'\n0\n"})}),"\n",(0,t.jsx)(n.p,{children:"You can also do this with a higher order functions similarly.  In this\nimplementation, maybe is always a list so that (Just 0) is distinct from\nNothing.  This is longer but more general.  If used to construct fully\ngeneric algorithms, it might be needed."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"(mod (p)\n    \n  (include *standard-cl-23*)\n    \n  (defun fromMaybe (v (@ m (content))) (if m content v))\n  (defun mapMaybe (f (@ m (content))) (if m (list (a f (list content))) ()))\n    \n  (fromMaybe 0 (mapMaybe (lambda ((@ pt (x y))) (+ x y)) p))\n  )\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ brun maybe.clvm '(((3 5)))' # Note: ((3 5)) is like (Some (Pt 3 5))\n8\n$ brun maybe.clvm '(())'\n()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"function-closures",children:"Function closures"}),"\n",(0,t.jsx)(n.p,{children:"Chialisp allows function names to be treated as closures when used as values.\nThe resulting function is callable with the 'a' operator in the way other\nforeign code would be when passed into your program or as a result of a lambda\nexpression."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"(mod (Z)\n   \n  (include *standard-cl-23*)\n    \n  (defun add-one (X) (+ X 1))\n    \n  (defun map (F L)\n    (if L\n      (c (a F (list (f L))) (map F (r L)))\n      ()\n      )\n    )\n    \n  (map add-one Z)\n  )\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ brun map.clvm '((1 2 3))'\n(a 3 4)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"lambda-forms",children:"lambda forms"}),"\n",(0,t.jsx)(n.p,{children:"Chialisp supports 'lambda' in a similar way to scheme.  The resulting value is\ncallable with the 'a' operator, has access to the program's functions and constants\nand is in general safe to use for higher-order functions."}),"\n",(0,t.jsx)(n.p,{children:"The above program could be re-stated as:"}),"\n",(0,t.jsx)(n.p,{children:"(mod (Z)"}),"\n",(0,t.jsxs)(n.p,{children:["(include ",(0,t.jsx)(n.em,{children:"standard-cl-23"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"(defun map (F L)\n(if L\n(c (a F (list (f L))) (map F (r L)))\n()\n)\n)"}),"\n",(0,t.jsx)(n.p,{children:"(map (lambda (Y) (+ Y 1)) Z)\n)"}),"\n",(0,t.jsx)(n.h3,{id:"embed-and-compile-include-forms",children:"embed and compile include forms"}),"\n",(0,t.jsx)(n.p,{children:"Chialisp programs often need to know the hashes or contents of other programs\nand other data and it can be inconvenient to translate it into chialisp source\ncode (especially if, during development it changes)."}),"\n",(0,t.jsx)(n.p,{children:"Chialisp now gives the ability to embed foreign data, including compiling\nprograms and embedding their compiled representation.  Since chialisp programs\ncontain identification about how they should be compiled, it's possible to\ninclude programs from different versions of the language accurately."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:'(mod (Z)\n    \n  (include *standard-cl-23*)\n    \n  (embed-file hello-data bin "hello.txt")\n    \n  (sha256 hello-data Z)\n  )\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ xxd hello.txt\n00000000: 6865 6c6c 6f0a                           hello.\n$ ./target/debug/brun embedhello.clvm '(world)'\n0x26c60a61d01db5836ca70fefd44a6a016620413c8ef5f259a6c5612d4f79d3b8\n$ ./target/debug/brun '(sha256 (q . 0x68656c6c6f0a) (q . world))'\n0x26c60a61d01db5836ca70fefd44a6a016620413c8ef5f259a6c5612d4f79d3b8\n"})}),"\n",(0,t.jsx)(n.h3,{id:"trace-output-via-cldb",children:"trace output via cldb"}),"\n",(0,t.jsx)(n.p,{children:"The cldb debugger now recognizes a specific clvm expression as indicating a\ndesire for diagnostic output.  One way to generate it is with a function like"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:'  (defun print (l x) (i (all "$print$" l x) x x))\n'})}),"\n",(0,t.jsx)(n.p,{children:"You can use this in your programs to determine what values have been computed\nwithout stopping execution while the program runs:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:'(mod (X)\n  (include *standard-cl-23*)\n  \n  (defun print (l x) (i (all "$print$" l x) x x))\n\n  (defun C (N X) (if (> 2 (print (list "collatz" N) X)) N (let ((NP1 (+ N 1))) (if (logand 1 X) (C NP1 (+ 1 (* 3 X))) (C NP1 (/ X 2))))))\n  \n  (C 0 X)\n  )\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:'$ ./target/debug/cldb -p c.clsp \'(3)\'\n---\n- Print: ((collatz ()) 3)\n- Print: ((collatz 1) 10)\n- Print: ((collatz 2) 5)\n- Print: ((collatz 3) 16)\n- Print: ((collatz 4) 8)\n- Print: ((collatz 5) 4)\n- Print: ((collatz 6) 2)\n- Print: ((collatz 7) 1)\n- Final: "7"\n  Final-Location: "c.clsp(6):50"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"defmac-and-full-preprocessing",children:"defmac and full preprocessing"}),"\n",(0,t.jsx)(n.p,{children:'Preprocessing takes place separately from compilation in modern chialisp.  This\nallows easier debugging of macros, allowing the user to view the preprocessor\noutput and check that generated code is correct, but also separating preprocessing\nfrom CLVM and allowing a greater range of value distinction.  The preprocessor\nis running code from the chialisp language, but it operates on values that include\nprogrammer relevant distinctions such as "symbol", "string" and "number" as in\nscheme.  The preprocessor can therefore both act differently based on what\nsyntactic inputs its presented with and it can also preserve and pass on those\ndistinctions.  It\'s necessary to move the preprocessor out of a pure CLVM to be\nable to surface errors about misspelled and unbound identifiers.'}),"\n",(0,t.jsx)(n.p,{children:"Chialisp can do a lot with macros.  Just two are builtin because they're useful\nfor building other macros, 'if' and 'list'.  I'll discuss these later in context\nbecause they require knowing a bit about CLVM."}),"\n",(0,t.jsx)(n.h4,{id:"example-and-macro",children:"Example: 'and' macro"}),"\n",(0,t.jsx)(n.p,{children:"We can start with an example of a short-circuiting 'and' operator.  In other\nversions of lisp and scheme, this operator lets you line up conditions that\ndepend on each other to keep from having runtime errors."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"(mod (X)\n\n  (include *standard-cl-23*)\n\n  (defun and_ (CLAUSES)\n    (if (r CLAUSES)\n      (qq (if (unquote (f CLAUSES)) (unquote (and_ (r CLAUSES))) ()))\n      (f CLAUSES)\n      )\n    )\n\n  (defmac and CLAUSES (if CLAUSES (and_ CLAUSES) 1))\n\n  (and X (r X) (f (r X)))\n  )\n"})}),"\n",(0,t.jsx)(n.p,{children:"This works nicely:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ run strict-and.clsp > strict-and.clvm\n$ brun strict-and.clvm '((1))'\n()\n$ brun strict-and.clvm '((1 2 3))'\n2\n"})}),"\n",(0,t.jsx)(n.p,{children:"We can check what this macro unrolls to:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ run -E strict-and.clsp\n(mod (X) (include *standard-cl-23*) (a (i X (com (a (i (r X) (com (f (r X))) (com ())) @)) (com ())) @))\n"})}),"\n",(0,t.jsx)(n.p,{children:"We can format it nicely:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"(mod (X)\n  (include *standard-cl-23*)\n\n  (a (i X\n    (com\n      (a (i (r X)\n        (com (f (r X)))\n        (com ())\n        ) @)\n      )\n    (com ())\n    ) @)\n  )\n"})}),"\n",(0,t.jsx)(n.p,{children:"Below I'll discuss what happened to 'if' (it's a macro itself in this language).\nFor now, you can think of (a (i X (com Y) (com Z)) @) as a weird way of saying\n'(if X Y Z)'."}),"\n",(0,t.jsx)(n.p,{children:"But what we can see here is:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["First the check of X","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Then in the true case, a check of (r X)","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Then in the true case, return (f (r X))"}),"\n",(0,t.jsx)(n.li,{children:"Else ()"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Else ()"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Which is just what we want for short-circuiting 'and' in a lisp like language.\nLooking again at the central function of the 'and' macro:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"  (defun and_ (CLAUSES)\n    (if (r CLAUSES)\n      (qq (if (unquote (f CLAUSES)) (unquote (and_ (r CLAUSES))) ()))\n      (f CLAUSES)\n      )\n    )\n"})}),"\n",(0,t.jsx)(n.p,{children:"One can see that the 'if' it expands to is:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"(if (unquote (f CLAUSES)) (unquote (and_ (r CLAUSES))) ())"})}),"\n",(0,t.jsx)(n.p,{children:"Which will cause code for the remaining and_ clauses to run if the first one\nwas truthy.  and_ is recursive so it'll make a left-heavy tree for any number\nof checks we want to proceed the final result.  Each 'if' form emitted by and_\nreturns nil if its check was false, protecting the remaining ones from running."}),"\n",(0,t.jsx)(n.p,{children:"We can break down how to develop chialisp macros.  Let's say we want to make 'or'\nwhich returns the first truthy item from a set of input arguments."}),"\n",(0,t.jsx)(n.p,{children:"We can start with a simple check:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:'(mod (X Y Z)\n  (include *standard-cl-23*)\n\n  (defmac or CLAUSES "hi from or")\n\n  (or X Y Z)\n  )\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:'$ run -E or-test.clsp\n(mod (X Y Z) (include *standard-cl-23*) "hi from or")\n'})}),"\n",(0,t.jsx)(n.p,{children:"And expand on it:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:'(mod (X Y Z)\n  (include *standard-cl-23*)\n\n  (defun or_ (CLAUSES) "hi from or")\n\n  (defmac or CLAUSES (if CLAUSES (or_ CLAUSES) ()))\n\n  (c (or) (or X Y Z))\n  )\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:'$ run -E or-test.clsp\n(mod (X Y Z) (include *standard-cl-23*) (c () "hi from or"))\n'})}),"\n",(0,t.jsx)(n.p,{children:"Then decide how 'or' should work:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"if there's one item left, then just return it."}),"\n",(0,t.jsx)(n.li,{children:"if the first item is truthy, return it."}),"\n",(0,t.jsx)(n.li,{children:"otherwise return (or ...) of the rest."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Note that CLAUSES is chialisp code the user put in the actual 'or' form, not\nthe results themselves."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"(qq ...)"})," form is useful for writing what you'd write in chialisp and\nhaving your macro produce that.  It quotes the code you write so that identifiers\npass through and are interpreted by the compiler after the macro is expanded.\nThe special 'unquote' form, causes whatever's inside it to be pasted into the\nquoted code.  It makes for fairly understandable macros."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"(mod (X Y Z)\n  (include *standard-cl-23*)\n\n  (defun or_ (CLAUSES)\n    (if (r CLAUSES) ;; There are more.\n      ;; Mistake: qq is missing.\n      (if (unquote (f CLAUSES)) (unquote (f CLAUSES)) (unquote (or_ (r CLAUSES))))\n      (f CLAUSES)\n      )\n    )\n\n  (defmac or CLAUSES (if CLAUSES (or_ CLAUSES) ()))\n\n  (or X Y Z)\n  )\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"or-test1.clsp(7):12-or-test1.clsp(7):19: no such callable 'unquote'\n"})}),"\n",(0,t.jsx)(n.p,{children:"So we fix that :-)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"(mod (X Y Z)\n  (include *standard-cl-23*)\n\n  (defun or_ (CLAUSES)\n    (if (r CLAUSES) ;; There are more.\n      (qq (if (unquote (f CLAUSES)) (unquote (f CLAUSES)) (unquote (or_ (r CLAUSES)))))\n      (f CLAUSES)\n      )\n    )\n\n  (defmac or CLAUSES (if CLAUSES (or_ CLAUSES) ()))\n\n  (or X Y Z)\n  )\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ run -E or-test.clsp\n(mod (X Y Z) (include *standard-cl-23*) (a (i X (com X) (com (a (i Y (com Y) (com Z)) @))) @))\n"})}),"\n",(0,t.jsx)(n.p,{children:"So this output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"(mod (X Y Z)\n  (include *standard-cl-23*)\n  (a (i X\n    (com X)\n    (com (a (i Y\n      (com Y)\n      (com Z)\n      ) @))\n    ) @)\n  )\n"})}),"\n",(0,t.jsx)(n.p,{children:"If X is true then return X, otherwise if Y is true then return Y, else Z."}),"\n",(0,t.jsx)(n.p,{children:"We can try it:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"$ run or-test.clsp > or-test.clvm\n$ $ brun or-test.clvm '(1 0 0)'\n1\n$ brun or-test.clvm '(0 3 7)'\n3\n$ brun or-test.clvm '(0 0 7)'\n7\n$ brun or-test.clvm '(0 0 0)'\n()\n"})}),"\n",(0,t.jsx)(n.p,{children:"These macros are used together in the ported rosetta code 'ABC' example later."}),"\n",(0,t.jsx)(n.h4,{id:"if-and-list-macros",children:"'if' and 'list' macros"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"            (defmac if (A B C)\n              (qq (a (i (unquote A) (com (unquote B)) (com (unquote C))) @))\n              )\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Which expands ",(0,t.jsx)(n.code,{children:"(if X Y Z)"})," to"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"(a (i X (com Y) (com Z)) @))\n"})}),"\n",(0,t.jsx)(n.p,{children:"'com' is a special form in the chialisp compiler that outputs the code that\ndoes what its argument does, in the context where it's expanded.  Because\nchialisp's 'a' operator can run a CLVM value as code, this allows execution\nto be passed down to one of two alternatives, based on whether X is truthy.\nThe 'i' operator returns one of its second or third argument based on the\ntruthiness of its first."}),"\n",(0,t.jsx)(n.p,{children:"So the 'if' macro has turned a high level concept 'if' into something that,\nwith some language support, outputs chialisp that's completely made up of\nprimitive operators from CLVM."}),"\n",(0,t.jsx)(n.p,{children:"The 'list' macro is similar:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"            (defun __chia__compile-list (args)\n              (if args\n                (c 4 (c (f args) (c (__chia__compile-list (r args)) ())))\n                ()\n                )\n              )\n\n            (defmac list ARGS (__chia__compile-list ARGS))\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Which expands ",(0,t.jsx)(n.code,{children:"(list X Y Z)"})," to"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:"(4 X (4 Y (4 Z ())))\n"})}),"\n",(0,t.jsx)(n.p,{children:"Turning the list again into chialisp that uses CLVM operators in a more\nprimitive way.  This allows chialisp developers to turn high level ideas into\ncode that's frugal at the CLVM level."}),"\n",(0,t.jsx)(n.h2,{id:"complete-example-abc-problem",children:"Complete example: ABC problem"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:';; Adapted from https://rosettacode.org/wiki/ABC_problem#Scheme\n(mod (word)\n    \n  (include *standard-cl-23*)\n    \n  (defconst *blocks*\n    (list\n      (c "B" "O") (c "X" "K") (c "D" "Q") (c "C" "P") (c "N" "A")\n      (c "G" "T") (c "R" "E") (c "T" "G") (c "Q" "D") (c "F" "S")\n      (c "J" "W") (c "H" "U") (c "V" "I") (c "A" "N") (c "O" "B")\n      (c "E" "R") (c "F" "S") (c "L" "Y") (c "P" "C") (c "Z" "M")))\n    \n  (defun-inline block-member (e s)\n    (logior (= e (f s)) (= e (r s)))\n    )\n    \n  ;; Make short-circuiting and.\n  (defun and_ (CLAUSES)\n    (if (r CLAUSES)\n      (qq (if (unquote (f CLAUSES)) (unquote (and_ (r CLAUSES))) ()))\n      (f CLAUSES)\n      )\n    )\n\n  ;; Chialisp doesn\'t natively have \'and\' and \'or\'.\n  ;; These macros rewrite (and x y z) ... to (if x (if y (if z 1) ()) ())\n  ;; ensuring that y and z execute only if x was true etc.\n  ;;\n  ;; \'or\' stops evaluating if it gets a true result, otherwise continuing.\n  (defmac and CLAUSES (if CLAUSES (and_ CLAUSES) 1))\n    \n  ;; Make short-circuiting or.\n  (defun or_ (CLAUSES)\n    (if (r CLAUSES)\n      (qq (if (unquote (f CLAUSES)) 1 (unquote (or_ (r CLAUSES)))))\n      (f CLAUSES)\n      )\n    )\n    \n  (defmac or CLAUSES (if CLAUSES (or_ CLAUSES) ()))\n\n  ;; Demonstrates use of higher order functions at call sites.\n  ;; CLVM uses the apply operator with an argument list, so\n  ;; when functions exist as values, they can be called\n  ;; interoperably with foreign code this way.\n  ;; ;; p? is a function.\n  ;; (a p? (list (f li)) ;; the same as (p? (f li)) if\n  ;;                     ;; p? were a defun.\n  (defun exists (p? li)\n    (and li (or (a p? (list (f li))) (exists p? (r li))))\n    )\n    \n  (defun remove-one (x li)\n    (or\n      (not li)\n      (if (and (= (f (f li)) (f x)) (= (r (f li)) (r x)))\n        (r li)\n        (c (f li) (remove-one x (r li)))\n        )\n      )\n    )\n    \n  (defun can-make-list? (li blocks)\n    (or\n      (not li)\n      (exists\n        ;; Lambdas now work as one would expect.\n        ;; The capture spec (the (& ...) part is similar to\n        ;; C++\' lambda syntax and it should intuitively reflect\n        ;; the cost of the environment capture that the lambda\n        ;; carries off.\n        (lambda ((& li blocks) block)\n          (and\n            (block-member (f li) block)\n            (can-make-list? (r li) (remove-one block blocks))\n            )\n          )\n        blocks\n        )\n      )\n    )\n    \n  (defun can-make-word? (word) (can-make-list? word *blocks*))\n    \n  (defun wordify (W)\n    (if W\n      (c (substr W 0 1) (wordify (substr W 1)))\n      ()\n      )\n    )\n    \n  (can-make-word? (wordify word))\n  )\n'})}),"\n",(0,t.jsx)(n.h2,{id:"complete-example-babbage-problem",children:"Complete example: Babbage problem"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:";; Adapted from: https://rosettacode.org/wiki/Babbage_problem#Scheme\n(mod (N)\n  (include *standard-cl-23*)\n    \n  (defun digits_ (result n)\n    ;; The new assign form allows destructuring assignment.\n    ;; the clvm divmod instruction returns a pair of (dividend . remainder)\n    ;; we can use 'assign' to provide 'd' and 'r' bindings for the two halves\n    ;; of the result expression.\n    ;;\n    ;; Assign can have any number of assignments (they're given as pairs of\n    ;; a binding form and an expression).  The assign form is finished with\n    ;; a body expression which gives the result.\n    (assign\n      (d . r) (divmod n 10)\n          \n      (if d\n        (digits_ (c r result) d)\n        (c r result)\n        )\n      )\n    )\n    \n  (defun digits (n) (if n (digits_ () n) ()))\n    \n  (defun reverse_ (result lst)\n    (if lst\n      (reverse_ (c (f lst) result) (r lst))\n      result\n      )\n    )\n    \n  (defun reverse (lst) (reverse_ () lst))\n    \n  (defun starts-with (lst prefix)\n    (if prefix\n      (if lst\n        (if (= (f prefix) (f lst))\n          (starts-with (r lst) (r prefix))\n          ()\n          )\n        ()\n        )\n      1\n      )\n    )\n    \n  (defun ends-with (lst tail)\n    ;; does list end with tail?\n    (starts-with (reverse lst) (reverse tail))\n    )\n    \n  (defun loop (start fun)\n    ;; We can use a let binding to give a name to the result.\n    (let ((res (a fun (list start))))\n      (if res\n        (f res)\n        (loop (+ 1 start) fun)\n        )\n      )\n    )\n    \n  (loop 1\n    ;; The loop function calls this inner function to return either a\n    ;; wrapped result or nil.  N is captured from the environment where\n    ;; the lambda originates from.\n    (lambda ((& N) idx)\n      (if (ends-with (digits (* idx idx)) (digits N))\n        (list idx)\n        ()\n        )\n      )\n    )\n  )\n"})}),"\n",(0,t.jsx)(n.h2,{id:"complete-example-avl-tree",children:"Complete Example: AVL Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:";; Port of a verified AVL tree in haskell and agda from:\n;; https://doisinkidney.com/posts/2018-07-30-verified-avl.html\n;;\n;; Given an AVL tree representation and a key and value to add, return\n;; the new tree.\n(mod (tree k v)\n  (include *standard-cl-23*)\n\n  (defconstant LB 0)\n  (defconstant IB 1)\n  (defconstant UB 2)\n\n  (defconstant LT -1)\n  (defconstant EQ 0)\n  (defconstant GT 1)\n\n  (defun-inline new_Key (k) k)\n\n  (defun-inline new_Bound (bound key) (c bound key))\n\n  (defconst lb (new_Bound LB ()))\n  (defun ib (k) (new_Bound IB k))\n  (defconst ub (new_Bound UB ()))\n\n  (defconstant BalanceL -1)\n  (defconstant BalanceO 0)\n  (defconstant BalanceR 1)\n\n  (defun-inline max (a b) (if (> a b) a b))\n\n  (defun-inline new_Balance (bt) bt)\n  (defun-inline get_Balance_bt (b) b)\n\n  (defun-inline balr (b)\n    (new_Balance\n      (if\n        (= (get_Balance_bt b) BalanceR)\n          BalanceL\n          BalanceO\n        )\n      )\n    )\n\n  (defun-inline ball (b)\n    (new_Balance\n      (if\n        (= (get_Balance_bt b) BalanceL)\n        BalanceL\n        BalanceO\n        )\n      )\n    )\n\n  (defconstant Stay 0)\n  (defconstant Incr 1)\n\n  (defun-inline new_Rebalance (rt tree) (c rt tree))\n  (defun-inline get_Rebalance_rt ((@ r (rt . tree))) rt)\n  (defun-inline get_Rebalance_tree ((@ r (rt . tree))) tree)\n\n  (defun-inline new_Node (key value balance left right) (list key value balance left right))\n  (defun-inline get_Node_key ((@ n (key value balance left right))) key)\n  (defun-inline get_Node_value ((@ n (key value balance left right))) value)\n  (defun-inline get_Node_balance ((@ n (key value balance left right))) balance)\n  (defun-inline get_Node_left ((@ n (key value balance left right))) left)\n  (defun-inline get_Node_right ((@ n (key value balance left right))) right)\n\n  (defun-inline rotr-l (x xv left cnode)\n    (assign\n      y (get_Node_key left)\n      yv (get_Node_value left)\n      anode (get_Node_left left)\n      bnode (get_Node_right left)\n\n      (new_Rebalance Stay (new_Node y yv (new_Balance BalanceO) anode (new_Node x xv (new_Balance BalanceO) bnode cnode)))\n      )\n    )\n\n  (defun-inline rotr-o (x xv left c)\n    (assign\n      y (get_Node_key left)\n      yv (get_Node_value left)\n      a (get_Node_left left)\n      b (get_Node_right left)\n\n      (new_Rebalance Incr (new_Node y yv (new_Balance BalanceR) a (new_Node x xv (new_Balance BalanceL) b c)))\n      )\n    )\n\n  (defun-inline rotr-r (x xv left d)\n    (assign\n      y (get_Node_key left)\n      yv (get_Node_value left)\n      a (get_Node_left left)\n      left_right (get_Node_right left)\n      z (get_Node_key left_right)\n      zv (get_Node_value left_right)\n      bl (get_Node_balance left_right)\n      b (get_Node_left left_right)\n      c (get_Node_right left_right)\n\n      (new_Rebalance Stay\n        (new_Node z zv\n          (new_Balance BalanceO)\n          (new_Node z zv (balr bl) a b)\n          (new_Node x xv (ball bl) c d)))\n      )\n    )\n\n  (defun rotr (x xv left right)\n    (assign\n      balance (get_Node_balance left)\n      bt (get_Balance_bt balance)\n\n      (if (= bt BalanceO)\n        (rotr-o x xv left right)\n        (if (= bt BalanceL)\n          (rotr-l x xv left right)\n          (rotr-r x xv left right)\n          )\n        )\n      )\n    )\n\n  (defun-inline rotl-o (x xv left right)\n    (assign\n      y (get_Node_key right)\n      yv (get_Node_value right)\n      b (get_Node_left right)\n      a (get_Node_right right)\n\n      (new_Rebalance Incr (new_Node y yv (new_Balance BalanceL) (new_Node x xv (new_Balance BalanceR) left b) a))\n      )\n    )\n\n  (defun-inline rotl-r (x xv left right)\n    (assign\n      y (get_Node_key right)\n      yv (get_Node_value right)\n      b (get_Node_left right)\n      a (get_Node_right right)\n\n      (new_Rebalance Stay (new_Node y yv (new_Balance BalanceO) (new_Node x xv (new_Balance BalanceO) left b) a))\n      )\n    )\n\n  (defun-inline rotl-l (x xv left right)\n    (assign\n      y (get_Node_key right)\n      yv (get_Node_value right)\n      left_right (get_Node_left right)\n      a (get_Node_right right)\n\n      z (get_Node_key left_right)\n      zv (get_Node_value left_right)\n      bl (get_Node_balance left_right)\n      c (get_Node_left left_right)\n      b (get_Node_right left_right)\n\n      (new_Rebalance Stay (new_Node z zv (new_Balance BalanceO) (new_Node x xv (balr bl) left c) (new_Node y yv (ball bl) b a)))\n      )\n    )\n\n  (defun rotl (x xv left right)\n    (assign\n      balance (get_Node_balance right)\n      bt (get_Balance_bt balance)\n\n      (if (= bt BalanceO)\n        (rotl-o x xv left right)\n        (if (= bt BalanceR)\n          (rotl-r x xv left right)\n          (rotl-l x xv left right)\n          )\n        )\n      )\n    )\n\n  (defun insert-with-leaf (k v)\n    (new_Rebalance Incr (new_Node k v (new_Balance BalanceO) () ()))\n    )\n\n  (defun insert-with-node-lt (k kc bl bt tr iw)\n    (assign-lambda\n      rt (get_Rebalance_rt iw)\n      tl_prime (get_Rebalance_tree iw)\n\n      (if (= rt Stay)\n        (new_Rebalance Stay (new_Node k kc bl tl_prime tr))\n        (if (= bt BalanceL)\n          (rotr k kc tl_prime tr)\n          (if (= bt BalanceO)\n            (new_Rebalance Incr (new_Node k kc (new_Balance BalanceL) tl_prime tr))\n            (new_Rebalance Stay (new_Node k kc (new_Balance BalanceO) tl_prime tr))\n            )\n          )\n        )\n      )\n    )\n\n  (defun insert-with-node-gt (k kc bl bt tl iw)\n    (assign\n      rt (get_Rebalance_rt iw)\n      tr_prime (get_Rebalance_tree iw)\n\n      (if (= rt Stay)\n        (new_Rebalance Stay (new_Node k kc bl tl tr_prime))\n        (if (= bt BalanceR)\n          (rotl k kc tl tr_prime)\n          (if (= bt BalanceO)\n            (new_Rebalance Incr (new_Node k kc (new_Balance BalanceR) tl tr_prime))\n            (new_Rebalance Stay (new_Node k kc (new_Balance BalanceO) tl tr_prime))\n            )\n          )\n        )\n      )\n    )\n\n  (defun insert-with-node (cmp f v vc node)\n    (assign\n      tl (get_Node_left node)\n      tr (get_Node_right node)\n      k (get_Node_key node)\n      kc (get_Node_value node)\n      bl (get_Node_balance node)\n      bt (get_Balance_bt bl)\n      compare_result (a cmp (list v k))\n\n      (if (= LT compare_result)\n        (insert-with-node-lt k kc bl bt tr (insert-with cmp f v vc tl))\n        (if (= EQ compare_result)\n          (new_Rebalance Stay (new_Node v (a f (list vc kc)) bl tl tr))\n          (insert-with-node-gt k kc bl bt tl (insert-with cmp f v vc tr))\n          )\n        )\n      )\n    )\n\n  (defun insert-with (cmp f v vc tree)\n    (if tree\n      (insert-with-node cmp f v vc tree)\n      (insert-with-leaf v vc)\n      )\n    )\n\n  (defun key-less (A B) (if (> A B) GT (if (> B A) LT EQ)))\n  (defun replace-value (A B) B)\n\n  (get_Rebalance_tree (insert-with key-less replace-value k v tree))\n  )\n"})}),"\n",(0,t.jsx)(n.h2,{id:"complete-example-hash-array-mapped-trie-hamt",children:"Complete Example: Hash Array Mapped Trie (HAMT)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-chialisp",children:';; HAMT ported from https://github.com/tomjkidd/simple-hamt/blob/master/src/simple_hamt/impl/core.clj\n(mod (h idx . rest)\n  (include *standard-cl-23*)\n\n  (defconstant number-of-segments 4)\n  (defconstant number-of-children 4)\n  (defconstant bits-per-segment 2)\n\n  (defun hash* (key)\n    (r (divmod key (lsh 1 (+ number-of-children number-of-segments))))\n    )\n\n  (defun-inline new_HAMT (type bitmap hash-table) (list type bitmap hash-table))\n  (defun-inline get_HAMT_type ((@ h (type bitmap hash-table))) type)\n  (defun-inline get_HAMT_bitmap ((@ h (type bitmap hash-table))) bitmap)\n  (defun-inline get_HAMT_hash-table ((@ h (type bitmap hash-table))) hash-table)\n  \n  (defun-inline new_HNode (type key value) (list type key value))\n  (defun-inline get_HNode_type ((@ n (type key value))) type)\n  (defun-inline get_HNode_key ((@ n (type key value))) key)\n  (defun-inline get_HNode_value ((@ n (type key value))) value)\n\n  (defun-inline htype (obj) (f obj))\n\n  (defun-inline empty-hash-map* () (new_HAMT "root" 0x00 ()))\n\n  (defun-inline get-hash-segment (hash-value segment)\n    (let ((mask 3)\n          (shifted (lsh hash-value (* segment -2))))\n      (logand mask shifted)\n      )\n    )\n\n  (defun list-nth (lst n)\n    (if n\n        (list-nth (r lst) (- n 1))\n        (f lst)\n        )\n    )\n\n  (defun list-replace-nth (lst idx new-item)\n    (if idx\n        (c (f lst) (list-replace-nth (r lst) (- idx 1) new-item))\n        (c new-item (r lst))\n        )\n    )\n\n  (defun range (n e)\n    (if (> e n)\n        (c (- (- e n) 1) (range (+ 1 n) e))\n        ()\n        )\n    )\n\n  (defun map (fun l)\n    (if l\n        (c (a fun (list (f l))) (map fun (r l)))\n        ()\n        )\n    )\n\n  (defun reduce (fun acc lst)\n    (if lst\n        (reduce fun (a fun (list acc (f lst))) (r lst))\n        acc\n        )\n    )\n\n  (defun drop (idx lst)\n    (if idx\n        (c (f lst) (drop (- idx 1) (r lst)))\n        (r lst)\n        )\n    )\n\n  (defun segment-seq (hash-value)\n    (map\n     (lambda ((& hash-value) v) (get-hash-segment hash-value v))\n     (range 0 number-of-segments)\n     )\n    )\n\n  (defun-inline in-bitmap? (bitmap position)\n    (logand bitmap (lsh 1 position))\n    )\n\n  (defun get-hash-table-index (bitmap position)\n    (reduce\n     (lambda ((& bitmap) acc cur)\n       (if (logand bitmap (lsh 1 cur))\n           (+ 1 acc)\n           acc\n           )\n       )\n     0\n     (range 0 position)\n     )\n    )\n\n  (defun update-bitmap (bitmap child-index)\n    (logior bitmap (lsh 1 child-index))\n    )\n\n  (defun update-hash-table (hash-table bitmap child-index k v)\n    (assign\n\n     in-bitmap-seq\n     (map\n      (lambda ((& hash-table bitmap child-index k v) idx)\n        (let\n            ((node\n              (if (= idx child-index)\n                  (new_HNode "node" k v)\n                  (if (in-bitmap? bitmap idx)\n                      (let ((htidx (get-hash-table-index bitmap idx)))\n                        (list-nth hash-table htidx)\n                        )\n                      ()\n                      )\n                  )\n               ))\n          (list idx node)\n          )\n        )\n      (range 0 number-of-children)\n      )\n\n     (reduce\n      (lambda (acc (index node))\n        (if node\n            (c node acc)\n            acc\n            )\n        )\n      ()\n      in-bitmap-seq\n      )\n     )\n    )\n\n  (defun get* (hm hash-val seg-index)\n    (assign\n     bitmap (get_HAMT_bitmap hm)\n     hash-table (get_HAMT_hash-table hm)\n     index (get-hash-segment hash-val seg-index)\n     empty? (not (in-bitmap? bitmap index))\n\n     (if empty?\n         ()\n         (assign\n          hash-table-index (get-hash-table-index bitmap index)\n          node (list-nth hash-table hash-table-index)\n          type (htype node)\n          key (get_HNode_key node)\n          value (get_HNode_value node)\n\n          (if (= type "node")\n              (if (= key hash-val)\n                  value\n                  ()\n                  )\n\n              (get* node hash-val (+ 1 seg-index))\n              )\n          )\n         )\n     )\n    )\n\n  (defun-inline new_SubhashBuilder (colliding-segs finished subhash-node) (list colliding-segs finished subhash-node))\n  (defun-inline get_SubhashBuilder_colliding-segs ((@ n (colliding-segs finished subhash-node))) colliding-segs)\n  (defun-inline get_SubhashBuilder_finished ((@ n (colliding-segs finished subhash-node))) finished)\n  (defun-inline get_SubhashBuilder_subhash-node ((@ n (colliding-segs finished subhash-node))) subhash-node)\n\n  (defun insert (hm child-index k v)\n    (assign\n     bitmap (get_HAMT_bitmap hm)\n     hash-table (get_HAMT_hash-table hm)\n     new-bitmap (update-bitmap bitmap child-index)\n     new-hash-table (update-hash-table hash-table bitmap child-index k v)\n     (new_HAMT (get_HAMT_type hm) new-bitmap new-hash-table)\n     )\n    )\n\n  (defun recur-subhash-node (acc rem sh)\n    (if (not (f rem))\n        sh\n        (recur-subhash-node\n         acc\n         (r rem)\n         (new_HAMT\n          "subh"\n          (update-bitmap 0 (f rem))\n          (list sh)\n          )\n         )\n        )\n    )\n\n  (defun enumerate-inner (n lst)\n    (if lst\n        (c (c n (f lst)) (enumerate-inner (+ n 1) (r lst)))\n        ()\n        )\n    )\n\n  (defun enumerate (lst) (enumerate-inner 0 lst))\n\n  (defun has-nonempty-sublist (items)\n    (if items\n        (l (f items))\n        ()\n        )\n    )\n\n  (defun slices (items)\n    (if (has-nonempty-sublist items)\n        (c (map (lambda (L) (f L)) items) (slices (map (lambda (L) (r L)) items)))\n        ()\n        )\n    )\n\n  (defun build-subhash (old-node new-node seg-index)\n    (assign\n     old-segs (drop seg-index (segment-seq (hash* (get_HNode_key old-node))))\n\n     new-segs (drop seg-index (segment-seq (hash* (get_HNode_key new-node))))\n\n     segs (enumerate (slices (list old-segs new-segs)))\n\n     sh (reduce\n         (lambda ((& old-node new-node) acc (i o n))\n           (let ((finished (get_SubhashBuilder_finished acc))\n                 (new-shb (get_SubhashBuilder_colliding-segs acc)))\n\n             (if finished\n                 acc\n                 (if (= o n)\n                     (new_SubhashBuilder\n                      (c o new-shb)\n                      ()\n                      (get_SubhashBuilder_subhash-node acc)\n                      )\n                     (assign\n\n                      subhash (new_HAMT "subh" 0x00 ())\n                      old-hnode (get_HNode_value old-node)\n\n                      subhash-with-old\n                      (insert subhash o (get_HNode_key old-node) old-hnode)\n\n                      new-hnode (get_HNode_value new-node)\n                      subhash-with-old-and-new\n                      (insert subhash-with-old n (get_HNode_key new-node) new-hnode)\n\n                      new-subhash-node\n                      (recur-subhash-node\n                       acc\n                       new-shb\n                       subhash-with-old-and-new\n                       )\n\n                      (new_SubhashBuilder\n                       new-shb\n                       1\n                       new-subhash-node\n                       )\n                      )\n                     )\n                 )\n             )\n           )\n\n         (new_SubhashBuilder () () ())\n         segs\n         )\n\n     (get_SubhashBuilder_subhash-node sh)\n     )\n    )\n\n  (defun assoc-collision (hm k v hash-val seg-index)\n    (assign\n     bitmap (get_HAMT_bitmap hm)\n     hash-table (get_HAMT_hash-table hm)\n     child-index (get-hash-segment hash-val seg-index)\n     hash-table-index (get-hash-table-index bitmap child-index)\n     collision-node (list-nth hash-table hash-table-index)\n     type (get_HNode_type collision-node)\n     key (get_HNode_key collision-node)\n     value (get_HNode_value collision-node)\n     hm-type (get_HAMT_type hm)\n     hm-bitmap (get_HAMT_bitmap hm)\n     old-node collision-node\n\n     (if (= type "node")\n         (assign\n          hm-table (get_HAMT_hash-table hm)\n          (if (= k key)\n              (assign\n               new-node (new_HNode type key v)\n               new-hash-table (list-replace-nth hash-table hash-table-index new-node)\n\n               (new_HAMT hm-type hm-bitmap new-hash-table)\n               )\n              (assign\n               new-node (new_HNode type k v)\n               new-subhash-node (build-subhash old-node new-node (+ 1 seg-index))\n               new-hash-table (list-replace-nth hash-table hash-table-index new-subhash-node)\n               (new_HAMT hm-type hm-bitmap new-hash-table)\n               )\n              )\n          )\n         (assign\n          new-subhash-node (assoc* collision-node k v hash-val (+ 1 seg-index))\n          new-hash-table (list-replace-nth hash-table hash-table-index new-subhash-node)\n          (new_HAMT hm-type hm-bitmap new-hash-table)\n          )\n         )\n     )\n    )\n\n  (defun assoc* (hm k v hash-val seg-index)\n    (assign\n     bitmap (get_HAMT_bitmap hm)\n     hash-table (get_HAMT_hash-table hm)\n     child-index (get-hash-segment hash-val seg-index)\n     collision-detected? (in-bitmap? bitmap child-index)\n\n     (if (not collision-detected?)\n         (insert hm child-index k v)\n         (assoc-collision hm k v hash-val seg-index)\n         )\n     )\n    )\n\n  ;; External interface\n  (defun empty-hash-map () empty-hash-map*)\n\n  (defun get (hm k)\n    (get* hm (hash* k) 0)\n    )\n\n  (defun assoc (hm k v)\n    (assoc* hm k v (hash* k) 0)\n    )\n\n  (if (not h)\n      (new_HAMT () () ())\n      (if rest\n          (assoc h idx (f rest))\n          (get h idx)\n          )\n      )\n  )\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>l,x:()=>r});var t=a(6540);const i={},s=t.createContext(i);function l(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);